/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
* cpssDxChHwInit.c
*
* DESCRIPTION:
*       Includes CPSS DXCH level basic Hw initialization functions.
*
* FILE REVISION NUMBER:
*       $Revision: 444 $
*
*******************************************************************************/
/* use dxCh_prvCpssPpConfig[dev]  : for debugging MACRO PRV_CPSS_DXCH_PP_MAC(dev)*/
#define CPSS_LOG_IN_MODULE_ENABLE

#include <cpss/generic/cos/cpssCosTypes.h>
#include <cpss/generic/cpssHwInit/cpssHwInit.h>
#include <cpss/generic/config/private/prvCpssConfigTypes.h>
#include <cpss/generic/private/prvCpssCommonDefs.h>
#include <cpss/generic/tm/prvCpssTmCtl.h>

#include <cpss/driver/interrupts/cpssDrvComIntEvReqQueues.h>
#include <cpss/driver/interrupts/cpssDrvComIntSvcRtn.h>

#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/dxCh/dxChxGen/config/cpssDxChCfgInit.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChModuleConfig.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/cpssDxChHwInit.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwInit.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChHwTables.h>
#include <cpss/dxCh/dxChxGen/networkIf/cpssDxChNetIf.h>
#include <cpss/dxCh/dxChxGen/cpssHwInit/private/prvCpssDxChCpssHwInitLog.h>

#include <cpss/dxCh/dxChxGen/port/cpssDxChPortCtrl.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortBufMg.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortTx.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortStat.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortPfc.h>
#include <cpss/dxCh/dxChxGen/port/cpssDxChPortPip.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortCtrl.h>
#include <cpss/dxCh/dxChxGen/port/private/prvCpssDxChPortIfModeCfgResource.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/cpssDxChPortPizzaArbiter.h>
#include <cpss/dxCh/dxChxGen/port/PizzaArbiter/DynamicPizzaArbiter/prvCpssDxChPortTxQHighSpeedPortsDrv.h>

#include <cpss/dxCh/dxChxGen/systemRecovery/hsu/private/prvCpssDxChHsu.h>
#include <cpss/dxCh/dxChxGen/systemRecovery/catchUp/private/prvCpssDxChCatchUp.h>

#include <cpss/dxCh/dxCh3/policer/cpssDxCh3Policer.h>

#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiag.h>
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiag.h>
#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiagDataIntegrity.h>
#include <cpss/dxCh/dxChxGen/diag/private/prvCpssDxChDiagDataIntegrityMainMappingDb.h>
#include <cpss/dxCh/dxChxGen/diag/cpssDxChDiagPacketGenerator.h>

#include <cpss/dxCh/dxChxGen/trunk/private/prvCpssDxChTrunk.h>
#include <cpss/dxCh/dxChxGen/pcl/private/prvCpssDxChPcl.h>

#include <cpss/dxCh/dxChxGen/private/routerTunnelTermTcam/prvCpssDxChRouterTunnelTermTcam.h>
#include <cpss/dxCh/dxChxGen/bridge/private/prvCpssDxChBrg.h>


#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgFdb.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgGen.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgMc.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgL2Ecmp.h>
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgSecurityBreach.h>
#include <cpss/dxCh/dxChxGen/tunnel/cpssDxChTunnel.h>
#include <cpss/dxCh/dxChxGen/nst/cpssDxChNstPortIsolation.h>
#include <cpss/dxCh/dxChxGen/nst/cpssDxChNst.h>
#include <cpss/dxCh/dxChxGen/mirror/cpssDxChMirror.h>
#include <cpss/dxCh/dxChxGen/cnc/cpssDxChCnc.h>
#include <cpss/dxCh/dxChxGen/cos/private/prvCpssDxChCoS.h>

#include <cpss/dxCh/dxChxGen/ip/cpssDxChIpCtrl.h>

#include <cpss/dxCh/dxChxGen/cscd/cpssDxChCscd.h>
#include <cpss/dxCh/dxChxGen/cscd/private/prvCpssDxChCscd.h>
#include <cpss/dxCh/dxChxGen/ptp/cpssDxChPtp.h>


#include <cpss/dxCh/dxChxGen/phy/cpssDxChPhySmi.h>
#include <cpss/dxCh/dxChxGen/phy/prvCpssDxChSmiUnitDrv.h>
#include <cpss/dxCh/dxChxGen/phy/private/prvCpssDxChPhySmi.h>


#include <cpss/dxCh/dxChxGen/tmGlue/private/prvCpssDxChTmGlue.h>

#include <cpssDriver/pp/config/prvCpssDrvPpCfgInit.h>
#include <cpssDriver/pp/interrupts/generic/prvCpssDrvInterruptsInit.h>
#include <cpssDriver/pp/interrupts/generic/prvCpssDrvInterrupts.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvExMxEventsCheetah3.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvExMxEventsDxChXcat.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvExMxEventsDxChXcat3.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvExMxEventsLionB.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvExMxEventsDxChXcat2.h>
#include <cpssDriver/pp/interrupts/dxExMx/prvCpssDrvExMxEventsLion2.h>
#include <cpssDriver/pp/prvCpssDrvPpDefs.h>
#include <cpssDriver/pp/prvCpssDrvErrataMng.h>

#include <port/silicon/bobk/mvHwsBobKCpll.h>

#include <pcs/mvHwsPcsIf.h>
#include <private/mvPortModeElements.h>

extern void hwsChange1GSpeedCfgV43();

#ifdef ASIC_SIMULATION
    #define DEBUG_OPENED
#endif /*ASIC_SIMULATION*/

#ifdef DEBUG_OPENED
    #ifdef STR
        #undef STR
    #endif /*STR*/

    #define STR(strname)    \
        #strname

    #define ERRATA_NAMES                                                                 \
    STR(PRV_CPSS_DXCH_FDB_AGING_WITH_REMOVAL_MODE_WA_E                                  ),\
    STR(PRV_CPSS_DXCH_TRUNK_CONFIG_FOR_TRUNK_NEXT_HOP_WA_E                              ),\
    STR(PRV_CPSS_DXCH_INCORRECT_SRCDEV_FIELD_IN_MAILBOX_TO_CPU_DSA_TAG_WA_E             ),\
    STR(PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E                            ),\
    STR(PRV_CPSS_DXCH_JUMBO_FRAMES_MODE_SDWRR_WEIGHT_LIMITATION_WA_E                    ),\
    STR(PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E                                       ),\
    STR(PRV_CPSS_DXCH_RATE_LIMIT_GIG_COUNTER_BITS_NUM_WA_E                              ),\
    STR(PRV_CPSS_DXCH_XG_MIB_READ_OVERSIZE_AND_JABBER_COUNTERS_WA_E                     ),\
    STR(PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E                    ),\
    STR(PRV_CPSS_DXCH2_READ_SRC_ID_ASSIGMENT_MODE_CONF_REG_WA_E                         ),\
    STR(PRV_CPSS_DXCH2_BRIDGE_ACCESS_MATRIX_LINE7_WRITE_WA_E                            ),\
    STR(PRV_CPSS_DXCH2_POLICY_ACTION_DIRECT_BURST_ONLY_READ_WA_E                        ),\
    STR(PRV_CPSS_DXCH2_DIRECT_ACCESS_TO_POLICER_ADDRESS_SPACE_WA_E                      ),\
    STR(PRV_CPSS_DXCH2_ROUTER_ARP_AND_TS_TABLE_NOT_SUPPORT_BURST_ACCESS_VIA_PCI_WA_E    ),\
    STR(PRV_CPSS_DXCH2_RDWRTRIG_BIT_IN_VLT_TABLES_ACCESS_CONTROL_REGISTER_IGNORED_E     ),\
    STR(PRV_CPSS_DXCH2_INDIRECT_ACCESS_ROUTER_AND_TT_TCAM_NOT_FUNCTION_CORRECTLY_WA_E   ),\
    STR(PRV_CPSS_DXCH_RM_XG_PHY_PATH_FAILURE_WA_E                                       ),\
    STR(PRV_CPSS_DXCH2_RM_RESERVED_REGISTERS_0x0B820108_WA_E                            ),\
    STR(PRV_CPSS_DXCH_RM_FDB_TABLE_ENTRIES_WA_E                                         ),\
    STR(PRV_CPSS_DXCH2_PCL_EGRESS_ACTION_CNTR_VLAN_WRONG_BITS_POS_WA_E                  ),\
    STR(PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E                                ),\
    STR(PRV_CPSS_DXCH3_VLT_INDIRECT_ACCESS_WA_E                                         ),\
    STR(PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E                              ),\
    STR(PRV_CPSS_DXCH3_SAMPLE_AT_RESET_NET_REF_CLOCK_SELECT_WA_E                        ),\
    STR(PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E                        ),\
    STR(PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E                                       ),\
    STR(PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E                                        ),\
    STR(PRV_CPSS_DXCH3_RM_TCAM_PLL_REG_WA_E                                             ),\
    STR(PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E                              ),\
    STR(PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E                                           ),\
    STR(PRV_CPSS_DXCH3_RM_AN_CNF_REG_WA_E                                               ),\
    STR(PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E                           ),\
    STR(PRV_CPSS_DXCH3_TXQ_PARITY_CALCULATION_E                                         ),\
    STR(PRV_CPSS_DXCH3_SDMA_WA_E                                                        ),\
    STR(PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E                                 ),\
    STR(PRV_CPSS_DXCH3_OUT_OF_PROFILE_QOS_ATTR_E                                        ),\
    STR(PRV_CPSS_DXCH3_TXQ_FULL_INTERRUPT_NOT_FUNCTION_WA_E                             ),\
    STR(PRV_CPSS_DXCH3_RM_GE_SERDES_MISC_CONF_REG_WA_E                                  ),\
    STR(PRV_CPSS_DXCH3_RM_BM_TX_FIFO_THRESHOLD_CONF_REG_WA_E                            ),\
    STR(PRV_CPSS_DXCH3_TCAM_EFUSE_NOT_TRIGGERED_AUTO_WA_E                               ),\
    STR(PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E                 ),\
    STR(PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E                                       ),\
    STR(PRV_CPSS_DXCH3_LIMITED_NUMBER_OF_POLICY_BASED_ROUTES_WA_E                       ),\
    STR(PRV_CPSS_DXCH3_TCAM_REPAIR_WA_E                                                 ),\
    STR(PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E                          ),\
    STR(PRV_CPSS_DXCH3_SERDES_YIELD_IMPROVEMENT_WA_E                                    ),\
    STR(PRV_CPSS_DXCH3_TOGGLE_DEV_EN_UNDER_TRAFFIC_WA_E                                 ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_TOTAL_BUFFER_LIMIT_CONF_IN_TXQ_E                          ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E                                     ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E                                     ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E                ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E                 ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E                   ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E                             ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E                             ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E                                     ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E                  ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E                                          ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E                            ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E                        ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E                           ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E                 ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E                        ),\
    STR(PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E                                   ),\
    STR(PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E                          ),\
    STR(PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E                         ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E                       ),\
    STR(PRV_CPSS_DXCH_XCAT_GIGA_PORT_PRBS_PARAM_INIT_WA_E                               ),\
    STR(PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E                            ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E      ),\
    STR(PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E                                        ),\
    STR(PRV_CPSS_DXCH_XCAT_ETH_OVER_IPV4_GRE_WA_E                                       ),\
    STR(PRV_CPSS_DXCH_XCAT_PASSENGER_ETH_PACKET_CRC_CANT_BE_RETAINED_WA_E               ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E                           ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E                         ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E                            ),\
    STR(PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E                                         ),\
    STR(PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E                               ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_SSMII_PAD_ZNR_ZPR_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_XCAT_RM_PASSENGER_TPID_REG_WA_E                                   ),\
    STR(PRV_CPSS_DXCH_LION_RM_SDMA_ACTIVATION_WA_E                                      ),\
    STR(PRV_CPSS_DXCH_LION_INDIRECT_ACCESS_TO_TCAM_IS_NOT_SUPPORTED_WA_E                ),\
    STR(PRV_CPSS_DXCH_LION_FDB_AU_FU_MESSAGES_FROM_NON_SOURCE_PORT_GROUP_WA_E           ),\
    STR(PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E                            ),\
    STR(PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E                                          ),\
    STR(PRV_CPSS_DXCH_LION_URPF_PER_VLAN_NOT_SUPPORTED_WA_E                             ),\
    STR(PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E                                        ),\
    STR(PRV_CPSS_DXCH_LION_PREVENT_REDUNDANT_AU_FU_MESSAGES_NOT_SUPPORTED_WA_E          ),\
    STR(PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E                             ),\
    STR(PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E                           ),\
    STR(PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E                              ),\
    STR(PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E                         ),\
    STR(PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E                                           ),\
    STR(PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E                       ),\
    STR(PRV_CPSS_DXCH_LION_RM_MCFIFO_DISTRIBUTION_REG_WA_E                              ),\
    STR(PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E                                           ),\
    STR(PRV_CPSS_DXCH_LION_SLOW_RATE_ON_PORT_TB_NOT_SUPPORTED_WA_E                      ),\
    STR(PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E                               ),\
    STR(PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E                                      ),\
    STR(PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E                              ),\
    STR(PRV_CPSS_DXCH_LION_RM_QCN_FOR_CN_FORMAT_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_LION_XLG_WS_SUPPORT_WA_E                                          ),\
    STR(PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E                                   ),\
    STR(PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E                                     ),\
    STR(PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E                             ),\
    STR(PRV_CPSS_DXCH_LION_IPCL_FALSE_PARITY_ERROR_WA_E                                 ),\
    STR(PRV_CPSS_DXCH_LION_PORT_REQUEST_RATE_RM_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E                  ),\
    STR(PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E                                             ),\
    STR(PRV_CPSS_DXCH_LION_EGRESS_STC_TABLE_READ_WA_E                                   ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_STACK_PORT_MIB_CNTR_CONTROL_WA_E                         ),\
    STR(PRV_CPSS_DXCH_XCAT2_EPCL_GLOBAL_EN_NOT_FUNCTIONAL_WA_E                          ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_POLICER_COUNT_FORMAT_WA_E                                ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_INT_EXT_REF_CLK_WA_E                                     ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E                                 ),\
    STR(PRV_CPSS_DXCH_XCAT2_STACK_MAC_COUNT_NO_CLEAR_ON_READ_WA_E                       ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_INCORRECT_XG_SHAPER_TOKEN_BUCKET_WA_E                    ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_BYPASS_PACKET_REFRESH_FDB_AGE_WA_E                       ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_PIPE_SELECT_WA_E                                         ),\
    STR(PRV_CPSS_DXCH_XCAT2_RM_FLEX_LINK_PORTS_RATE_LIMIT_WA_E                          ),\
    STR(PRV_CPSS_DXCH_XCAT2_PTP_UDP_FRAGMENT_WA_E                                       ),\
    STR(PRV_CPSS_DXCH_XCAT2_100FX_WA_E                                                  ),\
    STR(PRV_CPSS_DXCH_LION2_FAST_FAILOVER_WA_E                                          ),\
    STR(PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E                                 ),\
    STR(PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E                                            ),\
    STR(PRV_CPSS_DXCH_XCAT2_PTP_FRAGMENT_PACKET_TRAP_WA_E                               ),\
    STR(PRV_CPSS_DXCH_LION_RM_ENABLE_PFC_TRIGGER_WA_E                                   ),\
    STR(PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_CPFC_THRESHOLDS_WA_E                       ),\
    STR(PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E                        ),\
    STR(PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E                   ),\
    STR(PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E                                  ),\
    STR(PRV_CPSS_DXCH_LION2_RM_GLOBAL_XOFF_ACTIVATION_ON_PORT_WA_E                      ),\
    STR(PRV_CPSS_DXCH_LION2_LOCAL_SRC_PORT_DEV_MAP_ENABLE_WA_E                          ),\
    STR(PRV_CPSS_DXCH_LION2_SHARE_EN_CHANGE_WA_E                                        ),\
    STR(PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E                            ),\
    STR(PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E                               ),\
    STR(PRV_CPSS_DXCH_LION2_SCHEDULER_PROFILE_UNDER_TRAFFIC_WA_E                        ),\
    STR(PRV_CPSS_DXCH_LION2_DISMATCH_PORTS_LINK_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_LION2_GIGE_MAC_LINK_STATUS_WA_E                                   ),\
    STR(PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E                               ),\
    STR(PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_MLL_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E      ),\
    STR(PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_BMA_MC_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E   ),\
    STR(PRV_CPSS_DXCH_LION2_RM_WRONG_GIG_DESC_FIFO_THRESHOLD_WA_E                       ),\
    STR(PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E                       ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E                          ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E                        ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E                       ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E                    ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E                         ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E                 ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E                          ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E                    ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_MPLS_TRANSIT_TUNNEL_PARSING_WA_E                          ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E                          ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E                             ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_TAI_CAPTURE_STATUS_SET_WA_E                            ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_NOT_ALLOW_TTI_ACTION_TO_SET_MODIFY_UP_DSCP_WA_E           ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E             ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_ENH_TAILDROP_MODE_WRED_CONFLICT_WA_E                      ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_PFC_NOT_SUPPORTED_PORTS_48_71_WA_E                        ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_FC_802_3X_NOT_SUPPORTED_TM_MAPPED_PORTS_WA_E              ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E                ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E     ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E),\
    STR(PRV_CPSS_DXCH_BOBCAT2_FDB_ROUTE_UC_DELETE_BY_MESSAGE_WA_E                       ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_TCAM_WRITE_PARITY_ERROR_WA_E                              ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_EQ_TO_CPU_RATE_LIMIT_WINDOW_RESOLUTION_WA_E               ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E                                      ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E                                    ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RXDMA_PIP_IPV6_WRONG_TC_BITS_WA_E                         ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_LED_LINK_GIG_INDICATION_WA_E                              ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E                                        ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_SGMII_TO_CPU_NOT_SUPPORTED_WA_E                           ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E                   ),\
    STR(PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E                   ),\
    STR(PRV_CPSS_DXCH_XCAT3_UC_LOCAL_SWITCH_FILTER_FOR_VIRTUAL_PORTS_WA_E               ),\
    STR(PRV_CPSS_DXCH_XCAT3_TRUNK_ID_ASSIGN_INSTEAD_OF_VIRTUAL_PORT_WA_E                ),\
    STR(PRV_CPSS_DXCH_XCAT3_OAM_LB_PORT_NOT_GETTING_HIGHEST_QOS_WA_E                    ),\
    STR(PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E                   ),\
    STR(PRV_CPSS_DXCH_XCAT3_XLG_PORT_DROP_EVENT_PROBLEM_RM_E                            ),\
    STR(PRV_CPSS_DXCH_XCAT3_RM_RX_SDMA_WRONG_QUEUE_WA_E                                 ),\
    STR(PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E                             ),\
    STR(PRV_CPSS_DXCH_CAELUM_INGRESS_VLAN_RANGE_CONFIG_WA_E                             ),\
    "--last one--"

    static char * errataNames[PRV_CPSS_DXCH_ERRATA_MAX_NUM_E+1] = {ERRATA_NAMES};
#endif /*DEBUG_OPENED*/

/* used print routine   */
#define DUMP_PRINT_MAC(x) cpssOsPrintf x
/* get the name (string) and value of field */
#define NAME_AND_VALUE_MAC(field)   #field , field

/* pointers of DXCH devices into prvCpssPpConfig[] --> for debugging only */
static PRV_CPSS_DXCH_PP_CONFIG_STC* dxCh_prvCpssPpConfig[PRV_CPSS_MAX_PP_DEVICES_CNS];

GT_BOOL dxChInitRegDefaults = GT_FALSE;
GT_BOOL dxChFastBootSkipOwnDeviceInit = GT_FALSE;

/* pointer to a function used for DXCH devices that will do enhanced
   initialization of SW and HW parameters --  for FUTURE compatibility */
PRV_CPSS_DXCH_PP_CONFIG_ENHANCED_INIT_FUNC prvCpssDxChPpConfigEnhancedInitFuncPtr = NULL;

/* define constant for quick search for code that not support device types */
#define GT_DEVICE_FAMILY_NOT_SUPPORTED_CNS      GT_NOT_SUPPORTED
#define HW_INIT_SMI_POOLING_TIMEOUT_CNS 200000

/* definitions for interrupt coalescing */
#define MIN_INTERRUPT_COALESCING_PERIOD_CNS 320
#define MAX_INTERRUPT_COALESCING_PERIOD_CNS 5242560
/* number of VIDXs in the device */
#define VIDX_NUM_CNS  (_4K-1)
/* number of STG (spanning tree groups) in the device */
#define STG_NUM_CNS     256

/* 127 trunks support */
#define TRUNKS_127_NUM_CNS   127

/* 4 TX Queues number */
#define TX_QUEUE_NUM_4_CNS                4

/* 8 TX Queues number */
#define TX_QUEUE_NUM_8_CNS                8

/* not applicable (NA) table */
#define NA_TABLE_CNS    0

/* auto calc field */
#define AUTO_CALC_FIELD_CNS 0xFFFFFFFF

/* indication that the number of CNC blocks and size of block should be
    'auto calculated' from the 'total number of cnc counters ...*/
#define CNC_AUTO_CALC                       AUTO_CALC_FIELD_CNS

/* indication that the number of trunks that the device supports are according
   to number of bits that the device hold for trunk
   meaning no extra limitation on the number of trunks
   */
#define TRUNK_NUM_MAX_AUTO_CALC             AUTO_CALC_FIELD_CNS
/* indication that the value is not 'number of trunks' but number of 'l2ecmp table entries'*/
#define TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS          (BIT_31)
/* macro to indication that the value is not 'number of trunks' but number of 'l2ecmp table entries'
    + the number of 'l2ecmp table entries' */
#define L2_ECMP_TRUNK_ENTRIES_MAC(numEntries)   (TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS | (numEntries))

/* auto calc the pcl rules from the tti number of rules (shared tcam)*/
#define PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC             AUTO_CALC_FIELD_CNS

/* in Lion only portGroupId#3 has the RGMII registers for the CPU port */
#define LION_RGMII_PORT_GROUP_ID_CNS  3

/* indication that there was no need to replace a tcam row using the efuse */
#define NO_TCAM_ROW_TO_REPLACE_CNS 0xFFFFFFFF

/* maximum number of PLL recovery loops in the first level wrapper */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_1ST_WRAPPER_CNS 25

/* maximum number of PLL recovery loops in the second level wrapper for each setting change */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_2ND_WRAPPER_CNS 5

/* maximum number of PLL setting changes in the second level wrapper */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_SET_CHANGE_CNS 15

/* maximum number of PLL recovery loops in the third level wrapper for each setting change */
#define PLL_UNLOCK_WORKAROUND_MAX_LOOPS_3RD_WRAPPER_CNS 5

/* number of network SERDES */
#define PRV_CH3_NETWORK_SERDES_NUM_CNS 24

/* pre allocated descriptors - HW value used for resource calculations */
#define PRV_DXCH_XCAT_PRE_ALLOC_DESC_CNS 242

#define _13K    (13 * _1K)

/* Maximal address range inside one unit in words ((bits 0..22) >> 2) */
#define PRV_DXCH_MAX_UNIT_ADDR_RANGE_CNS    (1 << 21)

/* Calculate the last row of the TCAM logical sub-block for the row that was replaced */
/* to invalidate. A TCAM logical sub-block comprises 128 rows.                        */
#define LAST_SUB_BLOCK_ROW_CALC_MAC(_row)  _row = (_row/128 + 1)*128 - 1

/* Lion2 data integrity - max number of memory location per memory type for errata */
#define LION2_DATA_INTEGRITY_MAX_LOCATION_NUM_PER_MEMORY_CNS 8

/* bitmap of MC relay ports between hemispheres */
#define PRV_MC_RELAY_PORTS_BMP_CNS 0x10001000

/* needed by Bobcat3 : 16 words to support 512 ports */
#define EGF_SHT_MAX_PORTS_BMP_NUM_CNS       16

/* BobK Cetus PLL WA Related Flag */
static GT_BOOL isResetDbEnabled = GT_TRUE;

GT_VOID prvCpssDxChPortTypeSet
(
    IN  GT_U8                          devNum,
    IN  GT_PHYSICAL_PORT_NUM           portNum,
    IN  CPSS_PORT_INTERFACE_MODE_ENT   ifMode,
    IN  CPSS_PORT_SPEED_ENT             speed
);

static GT_STATUS hwPpPhase1Part4
(
    IN  GT_U8               devNum
);

static GT_STATUS hwPpPhase1Part5
(
    IN  GT_U8               devNum
);

static GT_STATUS hwPpPhase1Part6
(
    IN  GT_U8               devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr
);

GT_STATUS prvCpssDxChBrgMcEntryWrite
(
    IN GT_U8                devNum,
    IN GT_U16               vidx,
    IN CPSS_PORTS_BMP_STC   *portBitmapPtr
);

/*extern*/ GT_STATUS prvCpssDxChPortMappingTxQPort2TxDMAMapSet
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 txqNum,
    IN GT_U32 txDmaNum
);
GT_STATUS prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortMapSet
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 physPort,
    IN GT_U32 txqNum
);
static GT_STATUS prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit
(
    IN  GT_U8   devNum
);
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperInit
(
    IN  GT_U8   devNum
);
static GT_STATUS internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  maxPhysicalPorts
);


/* Check for SERDES existence and skip if SERDES does not exist */
#define PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(_serdes, _sbitmap) \
    if (((_sbitmap) & (1 << (_serdes))) == 0) \
        continue;

/* Check for power down SERDES bitmap and skip if SERDES should not be powered up */
#define PRV_CPSS_DXCH_SKIP_POWER_DOWN_PORTS_MAC(_port, _sbitmap) \
    if (((_sbitmap) & (1 << (_port))) != 0) \
        continue;

/* interrupt register for the GE MAC port
 * APPLICABLE DEVICES:
 *        xCat; xCat3; xCat2.
 */
#define GE_MAC_PORT_INTERRUPT_CAUSE_MAC(port) (0x0A800020  + ((port) * 0x400))

/* interrupt cause index for the GE MAC port link status change
 * APPLICABLE DEVICES:
 *        xCat; xCat3; xCat2.
 */
#define GE_MAC_PORT_INTERRUPT_INDEX_MAC(dev, port)   \
            ((PRV_CPSS_PP_MAC(dev)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E) ?  \
                (PRV_CPSS_XCAT2_PORTS_NETW_0_LINK_STATUS_CHANGED_E + ((port)*32)) : \
                (PRV_CPSS_XCAT_LINK_STATUS_CHANGED_PORT0_E + ((port)*32)))

/* #define FLEX_LINK_UP_WA_DBG */
#ifdef FLEX_LINK_UP_WA_DBG
    #define FLEX_LINK_UP_WA_DBG_PRINT_MAC(x) cpssOsPrintf x
#else
    #define FLEX_LINK_UP_WA_DBG_PRINT_MAC(x)
#endif

/* indication for the last device in devices lists */
#define LAST_DEV_IN_LIST_CNS   0xFFFFFFFF

/* Alleycat Unmanaged devs 24GE */
#define ALLEYCAT_UNMANAGED_DEVS_24GE_MAC \
    CPSS_98DX3011_CNS,             \
    CPSS_98DX3021_CNS

/* Alleycat2 Unmanaged devs 24GE */
#define ALLEYCAT_XCAT2_UNMANAGED_DEVS_24GE_MAC \
    CPSS_98DX3011B_CNS,             \
    CPSS_98DX3011C_CNS,             \
    CPSS_98DX3021B_CNS,             \
    CPSS_98DX3021C_CNS

/* Alleycat WebSmart devs 24FE */
#define ALLEYCAT_WEBSMART_DEVS_24FE_MAC  \
    CPSS_98DX1005_CNS,             \
    CPSS_98DX1025_CNS,             \
    CPSS_98DX1026_CNS,             \
    CPSS_98DX1027_CNS

/* Alleycat xCat2 WebSmart devs 24FE */
#define ALLEYCAT_XCAT2_WEBSMART_DEVS_24FE_MAC  \
    CPSS_98DX1033_CNS,             \
    CPSS_98DX1034_CNS,             \
    CPSS_98DX1035_CNS,             \
    CPSS_98DX1053_CNS,             \
    CPSS_98DX1055_CNS

/* Alleycat WebSmart devs 24GE */
#define ALLEYCAT_WEBSMART_DEVS_24GE_MAC  \
    CPSS_98DX3005_CNS,             \
    CPSS_98DX3015_CNS,             \
    CPSS_98DX3025_CNS,             \
    CPSS_98DX3026_CNS,             \
    CPSS_98DX3027_CNS,             \
    CPSS_98DXJ324_CNS

/* Alleycat xCat2 WebSmart devs 24GE */
#define ALLEYCAT_XCAT2_WEBSMART_DEVS_24GE_MAC  \
    CPSS_98DX3027B_CNS,             \
    CPSS_98DX3033B_CNS,            \
    CPSS_98DX3034B_CNS,            \
    CPSS_98DX3035B_CNS,            \
    CPSS_98DX3053_CNS,             \
    CPSS_98DX3054_CNS,             \
    CPSS_98DX3055_CNS,             \
    CPSS_98DX3036_CNS

/* the devices with up to 24GE+4stacking */
#define ALLEYCAT_UNMANAGED_DEVS_MAC \
    ALLEYCAT_UNMANAGED_DEVS_24GE_MAC,   \
    ALLEYCAT_XCAT2_UNMANAGED_DEVS_24GE_MAC

#define ALLEYCAT_WEBSMART_DEVS_MAC \
    ALLEYCAT_WEBSMART_DEVS_24GE_MAC,  /* the devices with up to 24GE+4stacking */\
    ALLEYCAT_WEBSMART_DEVS_24FE_MAC   /* the devices with up to 24FE+4stacking */\

#define ALLEYCAT2_WEBSMART_DEVS_MAC \
    ALLEYCAT_XCAT2_WEBSMART_DEVS_24FE_MAC, \
    ALLEYCAT_XCAT2_WEBSMART_DEVS_24GE_MAC

#define ALLEYCAT2_ARB_WEBSMART_DEVS_MAC \
    CPSS_98DX3036A_CNS

/* PONcat devs 24FE */
#define PONCAT_DEVS_24FE_MAC  \
    CPSS_98DX1002_CNS,       \
    CPSS_98DX1022_CNS,       \
    CPSS_98DX1023_CNS

/* PONcat2 devs 24FE */
#define PONCAT2_DEVS_24FE_MAC  \
    CPSS_98DX1133_CNS,         \
    CPSS_98DX1134_CNS,         \
    CPSS_98DX1135_CNS,         \
    CPSS_98DX1163_CNS,         \
    CPSS_98DX1165_CNS

/* PONcat devs 24GE */
#define PONCAT_DEVS_24GE_MAC  \
    CPSS_98DX3002_CNS,       \
    CPSS_98DX3031_CNS,       \
    CPSS_98DX3032_CNS,       \
    CPSS_98DX3034_CNS

/* PONcat2 xcat devs */
#define PONCAT2_XCAT_DEVS_MAC  \
    CPSS_98DX3136_CNS,         \
    CPSS_98DXZ366_CNS

/* PONcat2 devs 24GE */
#define PONCAT2_DEVS_24GE_MAC  \
    CPSS_98DX3031B_CNS,       \
    CPSS_98DX3133_CNS,        \
    CPSS_98DX3134_CNS,        \
    CPSS_98DX3135_CNS,        \
    CPSS_98DXZ365_CNS,        \
    CPSS_98DX3163_CNS,        \
    CPSS_98DX3165_CNS

#define PONCAT_DEVS_MAC \
    PONCAT_DEVS_24FE_MAC, /* the devices with up to 24FE+4stacking */\
    PONCAT_DEVS_24GE_MAC  /* the devices with up to 24GE+4stacking */

#define VONCAT_DEVS_24FE_MAC \
    CPSS_98DX1083_CNS,     \
    CPSS_98DX1085_CNS

#define VONCAT_DEVS_24GE_MAC \
    CPSS_98DX3083_CNS,      \
    CPSS_98DX3085_CNS

/* tomcat devs 24GE */
#define TOMCAT_DEVS_24GE_MAC \
    CPSS_98DX3101_CNS,       \
    CPSS_98DX3121_CNS,       \
    CPSS_98DX3122_CNS,       \
    CPSS_98DX3123_CNS,       \
    CPSS_98DX3124_CNS,       \
    CPSS_98DX3125_CNS

/* tomcat devs 24FE */
#define TOMCAT_DEVS_24FE_MAC \
    CPSS_98DX1122_CNS,       \
    CPSS_98DX1123_CNS

/* tomcat metro devs 24FE */
#define TOMCAT_METRO_DEVS_24FE_MAC \
    CPSS_98DX1222_CNS,       \
    CPSS_98DX1223_CNS

/* tomcat metro devs 24GE */
#define TOMCAT_METRO_DEVS_24GE_MAC \
    CPSS_98DX3201_CNS,       \
    CPSS_98DX3222_CNS,       \
    CPSS_98DX3223_CNS

#define TOMCAT_DEVS_MAC \
    TOMCAT_DEVS_24GE_MAC,  /* the devices with up to 24GE+4stacking */\
    TOMCAT_DEVS_24FE_MAC   /* the devices with up to 24FE+4stacking */

/* DXH devs 24FE */
#define DXH_DEVS_24FE_MAC  \
    CPSS_98DXH125_CNS,     \
    CPSS_98DXH126_CNS,     \
    CPSS_98DXH127_CNS

/* DXH devs 24GE */
#define DXH_DEVS_24GE_MAC  \
    CPSS_98DXH325_CNS,     \
    CPSS_98DXH326_CNS,     \
    CPSS_98DXH327_CNS

#define DXH_DEVS_MAC \
    DXH_DEVS_24FE_MAC, /* the devices with up to 24FE+4stacking */\
    DXH_DEVS_24GE_MAC  /* the devices with up to 24GE+4stacking */

/* AC2 DXH devs */
#define AC2_DXH_DEVS_MAC   \
    CPSS_98DXH335_CNS,     \
    CPSS_98DXH336_CNS,     \
    CPSS_98DXH337_CNS

/* bobcat devs up to 24GE */
#define BOBCAT_DEVS_24GE_MAC \
    CPSS_98DX3110_CNS,       \
    CPSS_98DX3110_1_CNS,     \
    CPSS_98DX4101_CNS,       \
    CPSS_98DX4121_CNS,       \
    CPSS_98DX4122_CNS,       \
    CPSS_98DX4123_CNS,       \
    CPSS_98DX4124_CNS,       \
    CPSS_98DX4125_CNS,       \
    CPSS_98DX5248_CNS,       \
    CPSS_98DX5258_CNS,       \
    CPSS_98DX5158_CNS,       \
    CPSS_98DX5159_CNS,       \
    CPSS_98DX5168_CNS,       \
    CPSS_98DXH525_CNS,       \
    CPSS_98DXH426_CNS,       \
    CPSS_98DX4A01_CNS,       \
    CPSS_98DX4A02_CNS,       \
    CPSS_98DX5313_CNS

/* bobcat devs 24FE */
#define BOBCAT_DEVS_24FE_MAC \
    CPSS_98DX2101_CNS,       \
    CPSS_98DX2122_CNS,       \
    CPSS_98DX2123_CNS,       \
    CPSS_98DX2151_CNS

#define BOBCAT_DEVS_MAC \
    BOBCAT_DEVS_24GE_MAC,  /* the devices with up to 24GE+4stacking */\
    BOBCAT_DEVS_24FE_MAC   /* the devices with up to 24FE+4stacking */

/* tomcat metro devs */
#define TOMCAT_METRO_DEVS_MAC \
    TOMCAT_METRO_DEVS_24FE_MAC,  /* the devices with up to 24FE+4stacking */\
    TOMCAT_METRO_DEVS_24GE_MAC   /* the devices with up to 24GE+4stacking */

/* Alleycat xCat3 devs 24GE */
#define ALLEYCAT_XCAT3_DEVS_24FE_MAC    \
    CPSS_98DX1233_CNS,  \
    CPSS_98DX1235_CNS

/* Alleycat xCat3 devs 24GE */
#define ALLEYCAT_XCAT3_DEVS_24GE_MAC    \
    CPSS_98DX3233_CNS,  \
    CPSS_98DX3234_CNS,  \
    CPSS_98DX3235_CNS,  \
    CPSS_98DX3236_CNS,  \
    CPSS_98DXH333_CNS,  \
    CPSS_98DXT321_CNS,  \
    CPSS_98DXT323_CNS,  \
    CPSS_98DXC323_CNS,  \
    CPSS_98DXN323_CNS

#define ALLEYCAT_XCAT3_DEVS_MAC   \
    ALLEYCAT_XCAT3_DEVS_24FE_MAC, \
    ALLEYCAT_XCAT3_DEVS_24GE_MAC

#define ALLEYCAT_XCAT3_REDUCED_DEVS_MAC   \
    CPSS_98DX3223_1_CNS,\
    CPSS_98DX3224_CNS,  \
    CPSS_98DX3225_CNS,  \
    CPSS_98DX3226_CNS

/* poncat xCat3 devs 24FE */
#define PONCAT_XCAT3_DEVS_24FE_MAC    \
    CPSS_98DX1333_CNS,  \
    CPSS_98DX1335_CNS,  \
    CPSS_98DX1336_CNS

/* poncat xCat3 devs 24GE */
#define PONCAT_XCAT3_DEVS_24GE_MAC    \
    CPSS_98DX3333_CNS,  \
    CPSS_98DX3334_CNS,  \
    CPSS_98DX3335_CNS,  \
    CPSS_98DX3336_CNS

#define PONCAT_XCAT3_DEVS_MAC   \
    PONCAT_XCAT3_DEVS_24FE_MAC, \
    PONCAT_XCAT3_DEVS_24GE_MAC

/* XCAT Unit 5, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit5RangesArray[] =
{
    {0x02802000 , 0x02802FFC, 0x0, 0x0},
    {0x02900000 , 0x02AFFFFC, 0x0, 0x0},
    {0x02C00000 , 0x02CFFFFC, 0x0, 0x0}
};

/* XCAT Unit 15, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit15RangesArray[] =
{
    {0x07E40000 , 0x07FFFFFC, 0x0, 0x0}
};

/* XCAT Unit 17, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit17RangesArray[] =
{
    {0x08800000 , 0x08805FFC, 0x0, 0x0},
    {0x08807000 , 0x0880FFFC, 0x0, 0x0}
};

/* XCAT Unit 18, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit18RangesArray[] =
{
    {0x09000000 , 0x092FFFFC, 0x0, 0x0},
    {0x09380000 , 0x097FFFFC, 0x0, 0x0}
};

/* XCAT Unit 19, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit19RangesArray[] =
{
    {0x09800800 , 0x09800C00, 0x0, 0x0},
    {0x09801800 , 0x09801C00, 0x0, 0x0},
    {0x09802800 , 0x09802C00, 0x0, 0x0},
    {0x09803800 , 0x09803C00, 0x0, 0x0},
    {0x09804800 , 0x09804C00, 0x0, 0x0},
    {0x09805800 , 0x09805C00, 0x0, 0x0},
    {0x09806800 , 0x09806C00, 0x0, 0x0},
    {0x09807800 , 0x09807C00, 0x0, 0x0},
    {0x09808800 , 0x09808C00, 0x0, 0x0},
    {0x09809800 , 0x09809C00, 0x0, 0x0},
    {0x0980B000 , 0x0980FFFC, 0x0, 0x0}
};

/* XCAT Unit 21, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit21RangesArray[] =
{
    {0x0A807000 , 0x0A80FBFC, 0x0, 0x0}
};

/* xCat, Unit 23 (0x17), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit23RangesArray[] =
{
    {0x0B800800, 0x0B800FFC, 0x0, 0x0},
    {0x0B830000, 0x0B83FFFC, 0x0, 0x0},
    {0x0B900800, 0x0BFFFFFC, 0x0, 0x0} /* Duplication of 0x0B8XXXXX */
};

/* xCat, Unit 24 (0x18), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit24RangesArray[] =
{
    {0x0C000600, 0x0C0008FC, 0x0, 0x0},
    {0x0C001700, 0x0C001FFC, 0x0, 0x0},
    {0x0C006000, 0x0C006FFC, 0x0, 0x0},
    {0x0C020000, 0x0C02106C, 0x0, 0x0},
    {0x0C030000, 0x0C03FFFC, 0x0, 0x0},
    {0x0C100600, 0x0C72106C, 0x0, 0x0},
    {0x0C730000, 0x0C73FFFC, 0x0, 0x0},
};

/* xCat, Unit 25 (0x19), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit25RangesArray[] =
{
    {0x0C801000, 0x0C8017FC, 0x0, 0x0},
    {0x0C900000, 0x0CFFFFFC, 0x0, 0x0}/* Duplication of 0x0C8XXXXX */
};

/* xCat, Unit 26 (0x1A), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit26RangesArray[] =
{
    {0x0D001000, 0x0D0017FC, 0x0, 0x0},
    {0x0D100000, 0x0D7FFFFC, 0x0, 0x0}/* Duplication of 0x0D0XXXXX */
};

/* xCat, Unit 28 (0x1C), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit28RangesArray[] =
{
    {0x0E002080, 0x0E0020FC, 0x0, 0x0},
    {0x0E100000, 0x0E7FFFFC, 0x0, 0x0}/* Duplication of 0x0E0XXXXX */
};

/* xCat, Unit 29 (0x1D), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit29RangesArray[] =
{
    {0x0E802080, 0x0E8020FC, 0x0, 0x0},
    {0x0E900000, 0x0EFFFFFC, 0x0, 0x0}/* Duplication of 0x0E8XXXXX */
};

static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC unit30RangesArray[] =
{
    {0x0F018000, 0x0F0187FC, 0x0, 0x0},
    {0x0F100000, 0x0F7FFFFC, 0x0, 0x0}/* Duplication of 0x0F0XXXXX */
};


/* Lion, Unit 7, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC lionUnit7RangesArray[] =
{
    {0x03800000 , 0x0387FFFC, 0x0, 0x0}
};

/* Lion, Unit 14, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC lionUnit14RangesArray[] =
{
    {0x07000000 , 0x0707FFFC, 0x0, 0x0}
};

/* Lion, Unit 20, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC lionUnit20RangesArray[] =
{
    {0x0A000000 , 0x0A7FFFFC, 0x0, 0x0}
};


/* Lion, Unit 33, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC lionUnit33RangesArray[] =
{
    {0x10800000 , 0x10FFFFFC, 0x0, 0x0}
};

/* Lion, Unit 35, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC lionUnit35RangesArray[] =
{

    {0x11800000 , 0x11FFFFFC, 0x0, 0x0}
};

/* xCat2, Unit 3, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit3RangesArray[] =
{
    {0x01B40000, 0x01B40140, 0x0, 0x0},
    {0x01B40160, 0x01B40160, 0x0, 0x0},
    {0x01B40188, 0x01B7FFFC, 0x0, 0x0},
    {0x01C00000, 0x01CBFFFC, 0x0, 0x0},
    {0x01D00000, 0x01D3FFFC, 0x0, 0x0},
    {0x01DC0000, 0x01DFFFFC, 0x0, 0x0},
    {0x01E4000C, 0x01E7FFFC, 0x0FFC000F, 0x01E4000C}
};


/* xCat2, Unit 7, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit7RangesArray[] =
{
    {0x03801000, 0x038017FC, 0x0, 0x0},
    {0x03901000, 0x03F017FC, 0x0, 0x0}
};


/* xCat2, Unit 0xC, restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit12RangesArray[] =
{
    {0x06000100, 0x063FFFFC, 0x0, 0x0},
    {0x06500100, 0x067FFFFC, 0x0, 0x0}
};


/* xCat2, Unit 15 (0x13), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit15RangesArray[] =
{
    {0x07E40000, 0x07FFFFFC, 0x0, 0x0}
};

/* xCat2, Unit 19 (0x13), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit19RangesArray[] =
{
    {0x09805000, 0x0980FFFC, 0x0, 0x0}
};


/* xCat2, Unit 21 (0x15), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit21RangesArray[] =
{
    {0x0A807000, 0x0A80FBFC, 0x0, 0x0}
};


/* xCat2, Unit 23 (0x17), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit23RangesArray[] =
{
    {0x0B800800, 0x0B800FFC, 0x0, 0x0},
    {0x0B840000, 0x0BF481FC, 0x0, 0x0}
};

/* xCat2, Unit 24 (0x18), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit24RangesArray[] =
{
    {0x0C000600, 0x0C0008FC, 0x0, 0x0},
    {0x0C001800, 0x0C001FFC, 0x0, 0x0},
    {0x0C006000, 0x0C006FFC, 0x0, 0x0},
    {0x0C020000, 0x0C02106C, 0x0, 0x0},
    {0x0C100600, 0x0C72106C, 0x0, 0x0}
};


/* xCat2, Unit 25 (0x19), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit25RangesArray[] =
{
    {0x0C801000, 0x0C8017FC, 0x0, 0x0},
    {0x0C901000, 0x0CF017FC, 0x0, 0x0}
};


/* xCat2, Unit 26 (0x1A), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit26RangesArray[] =
{
    {0x0D001000, 0x0D0017FC, 0x0, 0x0},
    {0x0D101000, 0x0D7017FC, 0x0, 0x0}
};

/* xCat2, Unit 28 (0x1C), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit28RangesArray[] =
{
    {0x0E000400, 0x0E0010FC, 0x0, 0x0},
    {0x0E002000, 0x0E0027FC, 0x0, 0x0},
    {0x0E100400, 0x0E7027FC, 0x0, 0x0}
};


/* xCat2, Unit 29 (0x1D), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit29RangesArray[] =
{
    {0x0E800100, 0x0E8027FC, 0x0, 0x0},
    {0x0E900100, 0x0EF027FC, 0x0, 0x0}
};

/* xCat2, Unit 30 (0x1E), restricted ranges */
static PRV_CPSS_DXCH_ERRATA_ADDR_RANGE_STC xCat2Unit30RangesArray[] =
{
    {0x0F018000, 0x0F0187FC, 0x0, 0x0},
    {0x0F118000, 0x0F7187FC, 0x0, 0x0}
};

/* definition for empty (restricted addresses) unit ranges */
#define EMPTY_UNIT_MAC  {0,NULL}

/* definition for total number of units */
#define UNITS_NUM_CNS   64

/* Units bad addresses ranges array for XCAT */
static PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC xcatBadAddressRanges[UNITS_NUM_CNS];


/* Units bad addresses ranges array for XCAT, Lion */
static PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC
        lionBadAddressRanges[CPSS_MAX_PORT_GROUPS_CNS][UNITS_NUM_CNS];

/* Units bad addresses ranges array for xCat2 */
static PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC xCat2BadAddressRanges[UNITS_NUM_CNS];

/*
 * typedef: struct FINE_TUNING_STC
 *
 * Description:
 *     structure for the devices flavors, about table sizes
 *
 * Fields:
 *      devTypePtr   - (pointer to) device type
 *      config       - device parameters being object of fine tuning
 *
 * Comment:
 */
typedef struct
{
    CPSS_PP_DEVICE_TYPE                     *devTypePtr;
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC config;
}FINE_TUNING_STC;


/*
 * typedef: struct BUFFER_MANAGEMENT_PARAMS_STC
 *
 * Description:
 *     structure for buffer,descriptors sizes/numbers
 *
 * Fields:
 *      bufferMemory   - Buffer Memory
 *      transmitDescr  - Transmit Descriptors
 * Comment:
 */
typedef struct
{
    GT_U32 bufferMemory;
    GT_U32 transmitDescr;
}BUFFER_MANAGEMENT_PARAMS_STC;

/*
 * typedef: struct FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC
 *
 * Description:
 *     structure for the devices flavors,
 *     about buffer,descriptors sizes/numbers
 *
 * Fields:
 *      devTypePtr   - (pointer to) device type
 *      config       - buffer,descriptors sizes/numbers
 *
 * Comment:
 */
typedef struct
{
    CPSS_PP_DEVICE_TYPE             *devTypePtr;

    BUFFER_MANAGEMENT_PARAMS_STC    config;
}FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC;

/* for those devices set 8M buffers */
static CPSS_PP_DEVICE_TYPE devOverrideDefaultTo_8M_buffers[]=
        {
            /* "GE AlleyCat WebSmart"  */
            CPSS_98DX3005_CNS,
            CPSS_98DX3015_CNS,
            CPSS_98DX3025_CNS,
            CPSS_98DX3026_CNS,
            CPSS_98DX3027_CNS,
            CPSS_98DXJ324_CNS,
            /* Poncat2 xCat based */
            CPSS_98DXZ366_CNS,
            /* add here other families */

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* array for 'Override buffers' numbers */
static FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC dxChXcatBufferMemory[]=
{
    {  /* 8M buffers */
        devOverrideDefaultTo_8M_buffers,
        {
            _8M  /* bufferMemory */
           ,AUTO_CALC_FIELD_CNS /* transmitDescr -- calc from buffer memory size */
        }
    }
};

static GT_U32 dxChXcatBufferMemory_size = sizeof(dxChXcatBufferMemory)/sizeof(dxChXcatBufferMemory[0]);

/* list of the alleycat unmanaged devices */
static CPSS_PP_DEVICE_TYPE devs_alleycat_unmanaged[]=
        {ALLEYCAT_UNMANAGED_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the alleycat websmart devices */
static CPSS_PP_DEVICE_TYPE devs_alleycat_websmart[]=
        {
            ALLEYCAT_WEBSMART_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };


/* list of the alleycat2 websmart devices */
static CPSS_PP_DEVICE_TYPE devs_alleycat2_websmart[]=
        {
            ALLEYCAT2_WEBSMART_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the alleycat2 websmart devices */
static CPSS_PP_DEVICE_TYPE devs_alleycat2_arb_websmart[]=
        {
            ALLEYCAT2_ARB_WEBSMART_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };


/* list of the poncat devices */
static CPSS_PP_DEVICE_TYPE devs_poncat[]=
        {PONCAT_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the voncat and poncat2 devices */
static CPSS_PP_DEVICE_TYPE devs_voncat_poncat2[]=
        {
            VONCAT_DEVS_24FE_MAC,
            VONCAT_DEVS_24GE_MAC,
            PONCAT2_DEVS_24FE_MAC,
            PONCAT2_DEVS_24GE_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the voncat and poncat2 devices */
static CPSS_PP_DEVICE_TYPE devs_poncat2_xcat[]=
        {
            PONCAT2_XCAT_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the tomcat devices */
static CPSS_PP_DEVICE_TYPE devs_tomcat[]=
        {TOMCAT_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the dxh devices */
static CPSS_PP_DEVICE_TYPE devs_dxh[]=
        {DXH_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the ac2 dxh devices */
static CPSS_PP_DEVICE_TYPE devs_ac2_dxh[]=
        {AC2_DXH_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the bobcat devices */
static CPSS_PP_DEVICE_TYPE devs_bobcat[]=
        {BOBCAT_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the tomcat metro devices */
static CPSS_PP_DEVICE_TYPE devs_tomcat_metro[]=
        {TOMCAT_METRO_DEVS_MAC,

         LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the alleycat xCat3 devices */
static CPSS_PP_DEVICE_TYPE devs_alleycat_xCat3[]=
        {
            ALLEYCAT_XCAT3_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the alleycat xCat3 devices with reduced table sizes */
static CPSS_PP_DEVICE_TYPE devs_alleycat_xCat3_reduced[]=
        {
            ALLEYCAT_XCAT3_REDUCED_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the poncat xCat3 devices */
static CPSS_PP_DEVICE_TYPE devs_poncat_xCat3[]=
        {
            PONCAT_XCAT3_DEVS_MAC,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* xCat, xCat2, xCat3 - fine tuning table  sizes according to devices flavors */
static FINE_TUNING_STC dxChXcatTables[]=
{

    { /* start "AlleyCat Unmanaged" */
        devs_alleycat_unmanaged,
        {
            NULL,
            {
                /* bridge section                                             */
                _8K,            /* fdb                                         */
                NA_TABLE_CNS,   /* vidxNum                                       */
                NA_TABLE_CNS,   /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                NA_TABLE_CNS,   /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                NA_TABLE_CNS,   /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                NA_TABLE_CNS,   /* GT_U32 cncBlocks;                          */
                NA_TABLE_CNS,   /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                NA_TABLE_CNS,   /* policersNum                                */
                NA_TABLE_CNS,   /* egressPolicersNum                          */
                NA_TABLE_CNS,   /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _2K,            /* transmitDescr;                             */
                                /*                                            */
                /* Buffer Memory                                              */
                _4M,            /* bufferMemory;                              */
                TX_QUEUE_NUM_4_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "AlleyCat Unmanaged" */
    ,
    { /* start "AlleyCat WebSmart" */
        devs_alleycat_websmart,
        {
            NULL,
            {
                /* bridge section                                             */
                _8K,            /* fdb                                         */
                256,            /* vidxNum                                       */
                32,             /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                NA_TABLE_CNS,   /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                512/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                NA_TABLE_CNS,   /* GT_U32 cncBlocks;                          */
                NA_TABLE_CNS,   /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                256,            /* policersNum                                */
                NA_TABLE_CNS,   /* egressPolicersNum                          */
                32,             /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _2K,            /* transmitDescr;                             */
                                /*                                            */
                /* Buffer Memory                                              */
                _4M,/* for GE devices uses 8M --> devOverrideDefaultTo_8M_buffers *//* GT_U32 bufferMemory;*/
                TX_QUEUE_NUM_4_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "AlleyCat WebSmart" */
    ,
    { /* start "AlleyCat2 WebSmart" */
        devs_alleycat2_websmart,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,            /* fdb                                         */
                _1K,            /* vidxNum                                       */
                64,             /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                512/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                NA_TABLE_CNS,   /* GT_U32 cncBlocks;                          */
                NA_TABLE_CNS,   /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                256,            /* policersNum                                */
                NA_TABLE_CNS,   /* egressPolicersNum                          */
                32,             /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _4K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _8M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_4_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "AlleyCat2 WebSmart" */
    ,
    { /* start "AlleyCat2 ARB WebSmart" */
        devs_alleycat2_arb_websmart,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,            /* fdb                                         */
                _1K,            /* vidxNum                                       */
                64,             /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _13K/4,         /* GT_U32 router;                             */
                _13K/4,         /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                _1K,            /* GT_U32  tunnelStart;                       */
                _2K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                512,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                512,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                32,             /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _4K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _8M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_4_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "AlleyCat2 ARB WebSmart" */
    ,
    { /* start "PONCat" */
        devs_poncat,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,            /* fdb                                         */
                _1K,            /* vidxNum                                       */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                _1K,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                (256+28),            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _4K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _8M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "PONCat" */
    ,
    { /* start "VonCat && PonCat2" */
        devs_voncat_poncat2,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                         */
                _1K,            /* vidxNum                                       */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,            /* GT_U32 router;                    */
                _1K,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                256,            /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;  PBR only           */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                (256+28),       /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC,/* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _4K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _8M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "VonCat && PonCat2" */
    ,
{ /* start "PonCat2 XCat" */
        devs_poncat2_xcat,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                         */
                _1K,            /* vidxNum                                       */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _1K,            /* GT_U32 router;                             */
                _1K,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                512,            /* GT_U32  tunnelStart;                       */
                _2K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                _4K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _2K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                (256+28),       /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC,/* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "PonCat2 XCat" */
    ,
    { /* start "dxh" */
        devs_dxh,
        {
            NULL,
            {
                /* bridge section                                             */
                _8K,            /* fdb                                         */
                _1K,            /* vidxNum                                       */
                32,             /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                256,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                64,             /* policersNum                                */
                NA_TABLE_CNS,   /* egressPolicersNum                          */
                31,             /* trunksNum                                  */
                                /*                                            */
                /* Transmit Descriptors                                       */
                _2K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _4M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_4_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "dxh" */
    ,
    { /* start "ac2_dxh" */
        devs_ac2_dxh,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,            /* fdb                                         */
                _1K,            /* vidxNum                                       */
                32,             /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                256,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                NA_TABLE_CNS,   /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                128,            /* policersNum                                */
                64,             /* egressPolicersNum                          */
                TRUNKS_127_NUM_CNS, /* trunksNum                              */
                                /*                                            */
                /* Transmit Descriptors                                       */
                _4K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _8M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_4_CNS, /* txQueuesNum - TX Queues number         */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "ac2_dxh" */
    ,
    { /* start "TomCat L2+" */
        devs_tomcat,
        {
            NULL,
            {
                /* bridge section                                             */
                _8K,            /* fdb                                         */
                _1K,            /* vidxNum                                       */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                _1K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _2K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                512,            /* policersNum                                */
                NA_TABLE_CNS,   /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _4K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _8M,            /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "TomCat L2+" */
    ,
    { /* start "Bobcat L3+/Metro" */
        devs_bobcat,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                         */
                VIDX_NUM_CNS,   /* vidxNum                                       */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _13K/4,         /* GT_U32 router;                             */
                _13K/4,         /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                _1K,            /* GT_U32  tunnelStart;                       */
                AUTO_CALC_FIELD_CNS,/* GT_U32  routerArp;                     */
                                /*                                            */
                /* ip section                                                 */
                _4K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _4K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _3K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _2K,            /* policersNum                                */
                512,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                                  */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "Bobcat L3+/Metro" */
    ,
    { /* start "TomCat Metro" */
        devs_tomcat_metro,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                         */
                VIDX_NUM_CNS,   /* vidxNum                                       */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                NA_TABLE_CNS,   /* GT_U32 router;                             */
                _13K/4,         /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                _1K,            /* GT_U32  tunnelStart;                       */
                _2K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                _2K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                NA_TABLE_CNS,   /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _3K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _2K,            /* policersNum                                */
                512,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC,   /* trunksNum                                */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "TomCat Metro" */
    ,
    { /* start "AlleyCat xCat3" */
        devs_alleycat_xCat3,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                _2K,            /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _1K/4,          /* GT_U32 router;                             */
                512,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                _1K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _1K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _1K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _1K,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _1K            /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "AlleyCat xCat3" */
    ,
    { /* start "AlleyCat xCat3" reduced */
        devs_alleycat_xCat3_reduced,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                _1K,            /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                512/4,          /* GT_U32 router;                             */
                256,            /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                NA_TABLE_CNS,   /* GT_U32  tunnelStart;                       */
                _1K,            /* GT_U32  routerArp;                         */
                                /*                                            */
                /* ip section                                                 */
                512,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _1K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                512/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _2K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                512,            /* policersNum                                */
                128,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "AlleyCat xCat3" reduced */
    ,
    { /* start "PonCat xCat3" */
        devs_poncat_xCat3,
        {
            NULL,
            {
                /* bridge section                                             */
                _16K,           /* fdb                                        */
                VIDX_NUM_CNS,   /* vidxNum                                    */
                STG_NUM_CNS,    /* stgNum                                     */
                                /*                                            */
                /* TCAM section                                               */
                _13K/4,         /* GT_U32 router;                             */
                _13K/4,         /* GT_U32 tunnelTerm;                         */
                                /*                                            */
                /* tunnel section                                             */
                _1K,            /* GT_U32  tunnelStart;                       */
                AUTO_CALC_FIELD_CNS,/* GT_U32  routerArp;                     */
                                /*                                            */
                /* ip section                                                 */
                _4K,            /* GT_U32  routerNextHop;                     */
                NA_TABLE_CNS,   /* GT_U32  ecmpQos;                           */
                _4K/2,          /* GT_U32  mllPairs;                          */
                                /*                                            */
                /* PCL section                                                */
                _3K/4,          /* GT_U32 policyTcamRaws;                     */
                                /*                                            */
                /* CNC section                                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,            /* GT_U32 cncBlockNumEntries;                 */
                                /*                                            */
                _2K,            /* policersNum                                */
                512,            /* egressPolicersNum                          */
                TRUNK_NUM_MAX_AUTO_CALC, /* trunksNum                         */
                /* Transmit Descriptors                                       */
                _6K,            /* GT_U32 transmitDescr;                      */
                                /*                                            */
                /* Buffer Memory                                              */
                _12M,           /* GT_U32 bufferMemory;                       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number        */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                _4K            /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support                                      */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support                                   */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag                                */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "PonCat xCat3" */
};

static GT_U32 dxChXcatTables_size = sizeof(dxChXcatTables)/sizeof(dxChXcatTables[0]);

/* list of the lion group 0 devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_group0[]=
        {
            CPSS_98CX8265_CNS,
            CPSS_98CX8266_CNS,
            CPSS_98CX8267_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the lion group 1 devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_group1[]=
        {
            CPSS_98CX8226_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion-L2 Street Fighter/ATCA devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_L2StreetFighter[]=
        {
            CPSS_98CX8113_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion-DC/Metro Data Center/Metro devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_DC_metro[]=
        {
            CPSS_98CX8248_1_CNS,
            CPSS_98CX8112_CNS,
            CPSS_98CX8224_1_CNS,
            CPSS_98CX8203_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion Metro GPON devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_metro_GPON[]=
        {
            CPSS_98CX8248_CNS,
            CPSS_98CX8224_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion-40G tier1/40GbE devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_40G[]=
        {
            CPSS_98CX8222_CNS,
            CPSS_98CX8223_CNS,
            CPSS_98CX8234_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion-Ch5-Metro */
static CPSS_PP_DEVICE_TYPE devs_Lion_Ch5_Metro[]=
        {
            CPSS_98DX5198_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion-Ch5-Enterprise devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_Ch5_Enterprise[]=
        {
            CPSS_98DX5178_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion-Crossbar devices */
static CPSS_PP_DEVICE_TYPE devs_Lion_Crossbar[]=
        {
            CPSS_98FX9216_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Lion - fine tuning table  sizes according to devices flavors */
static FINE_TUNING_STC lionTables[]=
{
    { /* Lion-L2 Street Fighter/ATCA devices */
        devs_Lion_L2StreetFighter,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _16K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                NA_TABLE_CNS,   /* GT_U32 router;             */
                NA_TABLE_CNS,   /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                NA_TABLE_CNS,    /*GT_U32  tunnelStart;       */
                NA_TABLE_CNS,    /*GT_U32  routerArp;         */
                                 /*                           */
                /* ip section                                 */
                NA_TABLE_CNS,    /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                NA_TABLE_CNS,    /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _1K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _4K/4,           /*policersNum                */
                NA_TABLE_CNS,    /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _4M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion-L2 Street Fighter/ATCA devices" */

    { /* Lion-DC/Metro Data Center/Metro devices */
        devs_Lion_DC_metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,   /* GT_U32 router;                   */
                _16K/4,   /* GT_U32 tunnelTerm;               */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion-DC/Metro Data Center/Metro devices" */

    { /* Lion Metro GPON */
        devs_Lion_metro_GPON,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,          /* GT_U32 router;            */
                _16K/4,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion Metro GPON devices" */

    { /* Lion-40G tier1/40GbE devices */
        devs_Lion_40G,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,          /* GT_U32 router;            */
                _16K/4,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion-40G tier1/40GbE devices" */

    { /* lion group 0 devices */
        devs_Lion_group0,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,          /* GT_U32 router;            */
                _16K/4,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "lion group 0 devices" */

    { /* lion group 1 devices */
        devs_Lion_group1,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,          /* GT_U32 router;            */
                _16K/4,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum         */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "lion group 1 devices" */

    { /* Lion-Ch5-Metro devices */
        devs_Lion_Ch5_Metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /* vidxNum                      */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,          /* GT_U32 router;            */
                _16K/4,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion-Ch5-Metro devices" */

    { /* Lion-Ch5-Enterprise devices */
        devs_Lion_Ch5_Enterprise,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _16K/4,          /* GT_U32 router;            */
                _16K/4,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K/4,           /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _3K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;                          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /*  Policer Section                           */
                _8K/4,           /*policersNum                */
                _2K/4,           /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS, /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion-Ch5-Enterprise devices" */

    { /* Lion-Crossbar devices */
        devs_Lion_Crossbar,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                         */
                0,               /*vidxNum                       */
                0,               /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                0,               /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                0,               /*GT_U32  tunnelStart;       */
                0,               /*GT_U32  routerArp;         */
                                 /*                           */
                /* ip section                                 */
                0,               /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                0,               /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                0,               /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                0,               /*GT_U32 cncBlocks;          */
                0,               /*GT_U32 cncBlockNumEntries; */
                /* Policer Section                            */
                0,               /*policersNum                */
                0,               /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum                  */
                                 /*                           */
                /* Transmit Descriptors                       */
                0,               /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                0,               /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "Lion-Crossbar devices" */

};

static GT_U32 lionTables_size = sizeof(lionTables)/sizeof(lionTables[0]);

/* list of the Lion-DC/Metro Data Center/Metro devices */
static CPSS_PP_DEVICE_TYPE devs_Lion2_DC_metro[]=
        {
            CPSS_98CX8296_CNS,
            CPSS_98CX8297_CNS,
            CPSS_98CX8308_CNS,
            CPSS_98CX8297_1_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Lion2 Hooper devices */
static CPSS_PP_DEVICE_TYPE devs_Lion2_Hooper[]=
        {
            CPSS_98CX8121_CNS,
            CPSS_98CX8123_CNS,
            CPSS_98CX8124_CNS,
            CPSS_98CX8129_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };


/* list of the Lion2-Crossbar devices */
static CPSS_PP_DEVICE_TYPE devs_Lion2_Crossbar[]=
        {
            CPSS_98FX9287_CNS,
            CPSS_98FX9288_CNS,

            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* Lion2 - fine tuning table  sizes according to devices flavors */
static FINE_TUNING_STC lion2Tables[]=
{
{ /* Lion2 Hooper devices */
        devs_Lion2_Hooper,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _2K,             /* GT_U32 router;            */
                _2K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _2K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _2K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,   /* GT_U32 cncBlocks;         */
                _4K,             /*GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,             /*policersNum                */
                512,             /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,          /*trunksNum */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number*/
                0,               /* lpmRam */
                0,               /* pipeBWCapacityInGbps */
                0                /* bpePointToPointEChannels */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }, /* end "Lion2 Hooper devices" */

    { /* Lion-DC/Metro Data Center/Metro devices */
        devs_Lion2_DC_metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                         */
                VIDX_NUM_CNS,    /*vidxNum                       */
                STG_NUM_CNS,     /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                _2K,             /* GT_U32 router;            */
                _2K,             /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _2K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                _2K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _2K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,   /* GT_U32 cncBlocks;         */
                _4K,             /*GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,             /*policersNum                */
                512,             /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,          /*trunksNum */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },    /* end "Lion-DC/Metro Data Center/Metro devices" */

    { /* Lion2-Crossbar devices */
        devs_Lion2_Crossbar,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                         */
                0,               /*vidxNum                       */
                0,               /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                0,               /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                0,               /*GT_U32  tunnelStart;       */
                0,               /*GT_U32  routerArp;         */
                                 /*                           */
                /* ip section                                 */
                0,               /*GT_U32  routerNextHop;     */
                NA_TABLE_CNS,    /*GT_U32  ecmpQos;           */
                0,               /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                _2K/4,           /*GT_U32 policyTcamRaws;     */
                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,   /*GT_U32 cncBlocks;          */
                _4K,             /*GT_U32 cncBlockNumEntries; */
                /* Policer Section                            */
                _2K,             /*policersNum                */
                512,             /*egressPolicersNum          */
                                 /*                           */
                /* trunk Section                              */
                TRUNK_NUM_MAX_AUTO_CALC,  /*trunksNum         */
                                 /*                           */
                /* Transmit Descriptors                       */
                _2K,             /*GT_U32 transmitDescr;      */
                                 /*                           */
                /* Buffer Memory                              */
                _8M,             /*GT_U32 bufferMemory;       */
                TX_QUEUE_NUM_4_CNS,  /* txQueuesNum - TX Queues number */
                NA_TABLE_CNS,  /* lpmRam                                      */
                NA_TABLE_CNS,  /* pipeBWCapacityInGbps                        */
                NA_TABLE_CNS   /* bpePointToPointEChannels                    */
            },

            {
                /* TR101 Feature support */
                GT_FALSE, /*tr101Supported*/

                /* VLAN translation support */
                GT_FALSE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag */
                GT_FALSE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_FALSE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }    /* end "Lion2-Crossbar devices" */
};

static GT_U32 lion2Tables_size = sizeof(lion2Tables)/sizeof(lion2Tables[0]);

/* list of the Bobcat2/Metro Data Center/Metro devices */
static CPSS_PP_DEVICE_TYPE devs_Bobcat2_DC_metro[]=
        {
            CPSS_98DX42XX_CNS,
            CPSS_98DX4251_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2/Metro stackable devices */
static CPSS_PP_DEVICE_TYPE devs_Bobcat2_DC_metro_stackable[]=
        {
            CPSS_98DX4220_CNS,
            CPSS_98DX4221_CNS,
            CPSS_98DX4222_CNS,
            CPSS_98DX4223_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2-bobk caelum devices - 48+12 */
static CPSS_PP_DEVICE_TYPE devs_Bobcat2_bobk_carrier_48and12[]=
        {
            CPSS_98DX42KK_CNS,
            CPSS_98DX4203_CNS,
            CPSS_98DX4204_CNS,
            CPSS_98DX4211_CNS,
            CPSS_98DX4210_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2-bobk cetus devices */
static CPSS_PP_DEVICE_TYPE devs_Bobcat2_bobk_cetus[]=
        {
            CPSS_98DX4235_CNS,
            CPSS_98DX8212_CNS,
            CPSS_98DX8208_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Aldrin devices */
static CPSS_PP_DEVICE_TYPE devs_Aldrin[]=
        {
            CPSS_98DX8316_CNS,
            CPSS_98DX8324_CNS,
            CPSS_98DX8332_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
        };

/* list of the Bobcat2-control plane switch medium scale devices */
static CPSS_PP_DEVICE_TYPE devs_Bobcat2_control_plane[]=
        {
            CPSS_98DX8216_CNS,
            CPSS_98DX8219_CNS,
            CPSS_98DX8224_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* list of the Bobcat2/Carrier small scale */
static CPSS_PP_DEVICE_TYPE devs_Bobcat2_Carrier_small[]=
        {
            CPSS_98DX4253_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };

/* Bobcat2 - fine tuning table  sizes according to devices flavors */
static FINE_TUNING_STC bobcat2Tables[]=
{
    { /* Bobcat2/Metro Data Center/Metro devices */
        devs_Bobcat2_DC_metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _32K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _8K,           /*policersNum                  */
                _8K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,                 /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                168,                 /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */

            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }   /* end "Bobcat2/Metro Data Center/Metro devices" */
    ,
    {
        devs_Bobcat2_DC_metro_stackable,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _32K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _8K,           /*policersNum                  */
                _8K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,       /* GT_U32  lpmRam, 128K --> 320K LPM lines */
                168,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    },   /* end "Bobcat2/Metro stackable devices" */

    /* Caelum - Campus (48+12)*/
    /* Carrier (48+12, Medium scale)
       Carrier (24+12, Medium scale) */
    {
        devs_Bobcat2_bobk_carrier_48and12,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _6K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_4K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _48K,       /* GT_U32  lpmRam, 48K --> 120K LPM lines */
                120,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }   /* Caelum - Campus (48+12) */,

    /* Carrier Low End (6+6), control plane low scale (8*10G) and (12*10G) */
    {
        devs_Bobcat2_bobk_cetus,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _6K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_4K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _8K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _16M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                67 ,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }   /* Carrier Low End (6+6), control plane low scale (8*10G) and (12*10G) */,

    {   /* Aldrin devices */
        devs_Aldrin,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                9*_1K,          /* GT_U32 tunnelTerm;         */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _4K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _2K,           /*policersNum                  */
                _2K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(_4K),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _8K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _24M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,       /* GT_U32  lpmRam, 16K --> 40K LPM lines */
                67 ,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        } /* Aldrin devices */
    },
    {   /* Medium scale), Drake - Control Plane Medium Scale (16/24G) */
        devs_Bobcat2_control_plane,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _64K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,              /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,              /*GT_U32  routerNextHop;    */
                _4K,              /*GT_U32  ecmpQos;          */
                _8K,              /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                _6K,           /*policersNum                  */
                _4K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,             /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _48K,       /* GT_U32  lpmRam, 48K --> 120K LPM lines */
                168,                  /* pipeBWCapacityInGbps */
                NA_TABLE_CNS          /* bpePointToPointEChannels  */
            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        } /* Medium scale), Drake - Control Plane Medium Scale (16/24G) */
    },
    { /* Bobcat2/Carrier Small scale devices */
        devs_Bobcat2_Carrier_small,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _32K,            /*fdb                        */
                _4K,             /*vidxNum                    */
                _1K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                18*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _8K,             /*GT_U32  tunnelStart;       */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _8K,             /*GT_U32  routerNextHop;     */
                _12K,            /*GT_U32  ecmpQos;           */
                _8K,             /*GT_U32  mllPairs;          */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
                6*_1K,          /*policersNum                 */
                _4K,            /*egressPolicersNum           */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _8K,              /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _16M,                 /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _16K,                /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                58,                  /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */

            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }   /* end "Bobcat2/Carrier Small scale devices" */
};
static GT_U32 bobcat2Tables_size = sizeof(bobcat2Tables)/sizeof(bobcat2Tables[0]);

/* list of the Bobcat2/Metro Data Center/Metro devices */
static CPSS_PP_DEVICE_TYPE devs_Bobcat3_DC_metro[]=
        {
            CPSS_98DX42FF_CNS,
            LAST_DEV_IN_LIST_CNS /* must be last one */
         };


/* Bobcat3 - fine tuning table  sizes according to devices flavors */
static FINE_TUNING_STC bobcat3Tables[]=
{
    { /* Bobcat3/Metro Data Center/Metro devices */
        devs_Bobcat3_DC_metro,
        {
            NULL,  /*enhancedInfoPtr*/
            {
                /* bridge section                             */
                _128K,           /*fdb                        */
                _4K,             /*vidxNum                    */
                _4K,             /*stgNum                     */
                                 /*                           */
                /* TCAM section                               */
                0,               /* GT_U32 router;            */
                36*_1K,          /* GT_U32 tunnelTerm;        */
                                 /*                           */
                /* tunnel section                             */
                _32K,             /*GT_U32  tunnelStart;      */
                AUTO_CALC_FIELD_CNS,/*GT_U32  routerArp;      */
                                 /*                           */
                /* ip section                                 */
                _24K,             /*GT_U32  routerNextHop;    */
                _12K,             /*GT_U32  ecmpQos;          */
                _16K,             /*GT_U32  mllPairs;         */
                                 /*                           */
                /* PCL section                                */
                PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC,/*GT_U32 policyTcamRaws;    */

                                 /*                           */
                /* CNC section                                */
                CNC_AUTO_CALC,  /* GT_U32 cncBlocks;          */
                _32K,           /* GT_U32 cncBlockNumEntries; */

                /*  Policer Section                           */
        CPSS_TBD_BOOKMARK_BOBCAT3 /* shared memory between IPLR0,1,EPLR (unlike legacy devices) */
                _16K,           /*policersNum                  */
                _16K,           /*egressPolicersNum            */
                                 /*                           */
                /* trunk Section                              */
                L2_ECMP_TRUNK_ENTRIES_MAC(TRUNK_NUM_MAX_AUTO_CALC),/*trunk,L2Ecmp - members */
                                 /*                           */
                /* Transmit Descriptors                       */
                _16K,             /*GT_U32 transmitDescr;     */
                                 /*                           */
                /* Buffer Memory                              */
                _32M,                 /*GT_U32 bufferMemory;      */
                TX_QUEUE_NUM_8_CNS,  /* txQueuesNum - TX Queues number */
                _128K,               /* GT_U32  lpmRam,  128K --> 320K LPM lines */
                168,                 /* pipeBWCapacityInGbps for revision B0, revision A0 is set from code , abd not from table*/
                NA_TABLE_CNS         /* bpePointToPointEChannels  */

            },

            {
                /* TR101 Feature support */
                GT_TRUE, /*tr101Supported*/

                /* VLAN translation support */
                GT_TRUE, /*vlanTranslationSupported*/

                /* Policer Ingress second stage support flag                  */
                GT_TRUE, /*iplrSecondStageSupported*/

                /* trunk CRC hash support flag */
                GT_TRUE, /*trunkCrcHashSupported*/

                /* TM support flag */
                GT_FALSE /* TmSupported */
            }
        }
    }   /* end "Bobcat2/Metro Data Center/Metro devices" */
};
static GT_U32 bobcat3Tables_size = sizeof(bobcat3Tables)/sizeof(bobcat3Tables[0]);


/* array of additional FEr/RM WA for the xcat and above */
static GT_U32 xcatA1ErrAndRmArray[]=
{
    /* RM - xcat */
    PRV_CPSS_DXCH_XCAT_RM_TOTAL_BUFFER_LIMIT_CONF_IN_TXQ_E,/*RM#3008*/
    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,/*RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E,/*RM#3007*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E,/*RM#3004*/
    PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E,/*RM#3002*,RM#3003*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/
    PRV_CPSS_DXCH_XCAT_ETH_OVER_IPV4_GRE_WA_E,
    PRV_CPSS_DXCH_XCAT_PASSENGER_ETH_PACKET_CRC_CANT_BE_RETAINED_WA_E, /*FEr#2785*/

    PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E,
    PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E,
    PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E,

    PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E,/*FEr#3048*/
    PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E,/*FEr#3033*/
    PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,/*FEr#3060*/
    PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E, /*FEr#2739*/
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E, /*FEr#2794*/
    PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E, /*FEr#3102*/
    PRV_CPSS_DXCH_XCAT_RM_SSMII_PAD_ZNR_ZPR_WA_E, /*RM#3042*/
    PRV_CPSS_DXCH_XCAT_RM_PASSENGER_TPID_REG_WA_E, /*RM#3043*/

    /* FEr from legacy device */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E,/*FEr#89*/
    PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E,/*FEr#3119*/

    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004*/
    PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E,/*RM#2024*/
    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E,/*FEr#2028*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/

    /* RM - from legacy device */
    PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E,/*RM#2003*/
    PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E,/*RM#2007*/
    PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E,/*RM#2008*/
    PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E,/*RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/

    /*  VLT direct access write problem with VLAN and STP tables (entry > 1 word) */
    PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of additional FEr/RM WA for the xcat3 */
static GT_U32 xcat3ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_XCAT3_UC_LOCAL_SWITCH_FILTER_FOR_VIRTUAL_PORTS_WA_E,/*FEr#31600*/
    PRV_CPSS_DXCH_XCAT3_TRUNK_ID_ASSIGN_INSTEAD_OF_VIRTUAL_PORT_WA_E,/*FEr#1000365*/
    PRV_CPSS_DXCH_XCAT3_OAM_LB_PORT_NOT_GETTING_HIGHEST_QOS_WA_E,/*FEr#27970*/
    PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E,/* FE-5101126 */
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E,
    PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E,/*RM-6302994*/
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E,
    PRV_CPSS_DXCH_XCAT3_XLG_PORT_DROP_EVENT_PROBLEM_RM_E,/*RM#6565603*/
    PRV_CPSS_DXCH_XCAT3_RM_RX_SDMA_WRONG_QUEUE_WA_E, /* RM-8732277*/

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of additional FEr/RM WA for the Lion */
static GT_U32 lionErrAndRmArray[]=
{
    /* Lion FEr */
    PRV_CPSS_DXCH_LION_URPF_PER_VLAN_NOT_SUPPORTED_WA_E,/*FEr#2732*/
    PRV_CPSS_DXCH_LION_PREVENT_REDUNDANT_AU_FU_MESSAGES_NOT_SUPPORTED_WA_E,/*2769*/
    PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E, /*FEr#2771*/
    PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E,/*FEr#2768*/
    PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E,/*???*/
    PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E , /*???*/
    PRV_CPSS_DXCH_LION_RM_MCFIFO_DISTRIBUTION_REG_WA_E, /*???*/
    PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E, /* HWE#27060 */
    PRV_CPSS_DXCH_LION_SLOW_RATE_ON_PORT_TB_NOT_SUPPORTED_WA_E,
    PRV_CPSS_DXCH_LION_IPCL_FALSE_PARITY_ERROR_WA_E, /* FEr#2774 */
    PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E, /* FEr#3116 */
    PRV_CPSS_DXCH_LION_EGRESS_STC_TABLE_READ_WA_E, /*FEr#3142*/

    /* RM Lion */
    PRV_CPSS_DXCH_LION_RM_SDMA_ACTIVATION_WA_E,/*Rm#2701*/
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,/*RM#2705*/
    PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E,/*RM#3013*/
    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E,/*RM#2702*/
    PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E,/*RM#2706*/
    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E,/*RM#2707*/
    PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E, /*RM#2710*/
    PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E, /*RM#2709*/
    PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E, /*RM#2711*/
    PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E, /*RM#2712*/
    PRV_CPSS_DXCH_LION_RM_QCN_FOR_CN_FORMAT_WA_E, /*RM#2713*/
    PRV_CPSS_DXCH_LION_PORT_REQUEST_RATE_RM_WA_E, /*RM#2716*/
    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E, /*RM#1752573*/
    PRV_CPSS_DXCH_LION_RM_ENABLE_PFC_TRIGGER_WA_E, /*???*/

    /* FEr from legacy devices */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/
    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004 --> part of FEr#2744*/
    PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,/*FEr#3060*/
    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E,/*FEr#2028*/
    PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E,/*FEr#89*/
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E, /*FEr#2794*/

    /* RM - from legacy device */
/*  not needed in Lion-B (like xcat) already in correct values.  PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E, RM#2026*/
    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E,/*RM# 2704*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,/*RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/

    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/

    PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E,/*RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/
    /* FEr#2009: SDMA resource errors may cause PCI Express packets reception malfunction */
    PRV_CPSS_DXCH3_SDMA_WA_E,


    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of additional FEr/RM WA for the Lion2 */
static GT_U32 lion2ErrAndRmArray[]=
{
    /* Lion2 FEr */
    PRV_CPSS_DXCH_LION2_FAST_FAILOVER_WA_E,
    PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E,
    PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E,
    PRV_CPSS_DXCH_LION2_LOCAL_SRC_PORT_DEV_MAP_ENABLE_WA_E,

    PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_MLL_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E, /* FE-8054972 */
    PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_BMA_MC_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E, /* FE-8071239 */
    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_CPFC_THRESHOLDS_WA_E, /* RM-9082194*/
    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E,  /* RM-8035267*/
    PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E, /*RM-8439088*/
    PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E, /*RM-9987707*/
    PRV_CPSS_DXCH_LION2_RM_GLOBAL_XOFF_ACTIVATION_ON_PORT_WA_E, /*RM-2466587*/
    PRV_CPSS_DXCH_LION2_RM_WRONG_GIG_DESC_FIFO_THRESHOLD_WA_E,  /* RM-261461 */

    /* Lion FEr */
#if 0 /* this erratum was partially fixed , and can be together with filter according to hemisphere# */
    PRV_CPSS_DXCH_LION_PREVENT_REDUNDANT_AU_FU_MESSAGES_NOT_SUPPORTED_WA_E,/*2769*/
#endif/*0*/
    PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E, /*FEr#2771*/
    PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E,/*FEr#2768*/
    PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E,/*???*/
    PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E , /*???*/
    PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E, /* HWE#27060 */
    PRV_CPSS_DXCH_LION_SLOW_RATE_ON_PORT_TB_NOT_SUPPORTED_WA_E,
    PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E, /* FEr#3116 */

    /* RM Lion */
    PRV_CPSS_DXCH_LION_RM_SDMA_ACTIVATION_WA_E,/*Rm#2701*/
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,/*RM#2705*/
    PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E,/*RM#3013*/
    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E,/*RM#2702*/
    PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E,/*RM#2706*/
    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E,/*RM#2707*/
    PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E, /*RM#2710*/
    PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E, /*RM#2709*/
    PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E, /*RM#2711*/
    PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E, /*RM#2712*/
    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E,/*???*/

    /* FEr from legacy devices */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/
    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004 --> part of FEr#2744*/
    PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,/*FEr#3060*/
    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E,/*FEr#2028*/
    PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E,/*FEr#89*/

    /* RM - from legacy device */
/*  not needed in Lion-B (like xcat) already in correct values.  PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E, RM#2026*/
    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E,/*RM# 2704*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,/*RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/

    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/

    PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E,/*RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/

    PRV_CPSS_DXCH_LION_XLG_WS_SUPPORT_WA_E, /* FEr#2709 */
    /* not relevant to lion2 PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E*, *FEr#2787 */
    PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E, /* FEr#2703 */
    PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E, /* RM#2788 */
    PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E, /* FEr#2776 */

    PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E, /*RM#3029*/

    PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E,/* FE-7263524 */

    PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E, /*FE_6041254*/

    PRV_CPSS_DXCH_LION2_SCHEDULER_PROFILE_UNDER_TRAFFIC_WA_E, /* FE-221066 */

    PRV_CPSS_DXCH3_SDMA_WA_E,
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E, /* FE-9085687 */

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* array of FEr/RM WA for the Bobcat2 */
static GT_U32 bobcat2ErrAndRmArray[]=
{
    /* Lion2 FEr */
/* Bobcat2; Caelum; Bobcat3 fixed - no hemisphere limitations -   PRV_CPSS_DXCH_LION2_FAST_FAILOVER_WA_E,*/
/* Bobcat2; Caelum; Bobcat3 - no dual device issues -   PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E,*/
/* Bobcat2; Caelum; Bobcat3 - no meaning for simulation , and cause crash ...    PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E,*/
/* Bobcat2; Caelum; Bobcat3 fixed - no local port limitations -       PRV_CPSS_DXCH_LION2_LOCAL_SRC_PORT_DEV_MAP_ENABLE_WA_E,*/

    PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E,  /* RM-8035267*/
    PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E, /*RM-8439088*/
    PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E, /*RM-9987707*/

    /* Lion FEr */
/* Bobcat2; Caelum; Bobcat3 fixed - as only single FDB instance - PRV_CPSS_DXCH_LION_PREVENT_REDUNDANT_AU_FU_MESSAGES_NOT_SUPPORTED_WA_E,2769*/
/*    PRV_CPSS_DXCH_LION_POLICER_COUNTING_MEM_ACCESS_WA_E, */ /*FEr#2771*/

    CPSS_TBD_BOOKMARK_EARCH
/*  closed only for TXQ alignment - should be checked later  PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E, */ /*FEr#2768*/

/* removed in Bobcat2; Caelum; Bobcat3 - not relevant   PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E,*???*/
/* Bobcat2; Caelum; Bobcat3 - removed until proven needed -   PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E ,*/ /*???*/
/* Bobcat2; Caelum; Bobcat3 - (no such MG registers that relevant to the WA)-
    PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E,  HWE#27060 */
/* removed in Bobcat2; Caelum; Bobcat3 - not relevant       PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E, --- FEr#3116 */

    /* RM Lion */
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,/*RM#2705*/
/*  removed Bobcat2; Caelum; Bobcat3 - PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E, RM#3013*/
/* Bobcat2; Caelum; Bobcat3 fixed - as only single FDB instance    PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E,RM#2702*/
    PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E,/*RM#2706*/
/* Bobcat2; Caelum; Bobcat3 fixed - as all EGF uses the same CPU port -   PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E, RM#2707*/
/* removed Bobcat2; Caelum; Bobcat3 - no such configuration    PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E, RM#2710*/

/* removed Bobcat2; Caelum; Bobcat3 - the default value is OK   PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E, RM#2711*/

/*  closed only for TXQ alignment - should be checked later PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E,*/ /*RM#2712*/
    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E,/*???*/

    /* FEr from legacy devices */
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/
    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004 --> part of FEr#2744*/
/*  removed Bobcat2; Caelum; Bobcat3 -  PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,FEr#3060*/
/* removed in Bobcat2; Caelum; Bobcat3 - no indirect registers ! -    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E, FEr#2028*/
    PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E,/*FEr#89*/

    /* RM - from legacy device */
/*  not needed in Lion-B (like xcat) already in correct values.  PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E, RM#2026*/
    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E,/*RM# 2704*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,  /* RM#3009*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_TOD_NANO_SEC_SET_WA_E,/*FEr#2773*/

    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E,/*(part of RM#3012)*/
/*removed in Bobcat2; Caelum; Bobcat3 -already correct value - PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
/*removed in Bobcat2; Caelum; Bobcat3 -register not exists -     PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E, (part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,(part of RM#3012)*/
/* not relevant to lion   PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
/* not relevant to Bobcat2; Caelum; Bobcat3 - defaults are ok -  PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E, RM#3018*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/

    /* not relevant to lion2 PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E*, *FEr#2787 */
/* metal fix - not relevant to Lion3 -  PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E, * FEr#2703 */
/* metal fix - not relevant to Bobcat2; Caelum; Bobcat3 -  PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E, * RM#2788 */

/*  closed only for TXQ alignment - should be checked later     PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E,*/ /* FEr#2776 */

    PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E, /*RM#3029*/
    PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E, /* RM: L2I-503 , L2I-546 */
    PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E,
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E, /*XCAT FEr#2794*/
    PRV_CPSS_DXCH_LION2_PORT_MAC_MIB_COUNTERS_CORRUPTION_WA_E, /* FE-9085687 */

    /* bobcat2 new FEr */
    PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E,         /* FE-7089929 */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E,       /* RM-3702958 */
    PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E,      /* RM: L2I-451 */
    PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E,   /* RM: TTI-1088 */
    PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E,        /* FE: TTI-1114 */
    PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E,/* RM: L2I-517 */
    PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E,   /* EGF-868 */
    PRV_CPSS_DXCH_BOBCAT2_MPLS_TRANSIT_TUNNEL_PARSING_WA_E,         /* FE-4300730 */
    PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E,            /* FE: TXQ-901 */
    PRV_CPSS_DXCH_BOBCAT2_NOT_ALLOW_TTI_ACTION_TO_SET_MODIFY_UP_DSCP_WA_E, /* FE: TTI-1267 */
#ifndef ASIC_SIMULATION
    PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_ENH_TAILDROP_MODE_WRED_CONFLICT_WA_E, /* (FE-4381191)*/
    PRV_CPSS_DXCH_BOBCAT2_PFC_NOT_SUPPORTED_PORTS_48_71_WA_E,   /* (FE-6841659)*/
    PRV_CPSS_DXCH_BOBCAT2_FC_802_3X_NOT_SUPPORTED_TM_MAPPED_PORTS_WA_E, /* (FE-7583456)*/
    PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E, /* FE-5101126 */
    PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E, /* FE-9897292 */
    PRV_CPSS_DXCH_BOBCAT2_TCAM_WRITE_PARITY_ERROR_WA_E, /* FE-5092995 */
#endif /* ASIC_SIMULATION */
    PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E,/* [JIRA] [TXQ-1097] - (BC2_A0) the TXQ egress mib counters should do 'clear on read' , but are not */
    PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E,  /* RM-7299863 */
    PRV_CPSS_DXCH_BOBCAT2_FDB_ROUTE_UC_DELETE_BY_MESSAGE_WA_E,/* [JIRA]:[MT-231] [FE-2293984] CPU NA message for deleting an entry does not work for UC route entries */
    PRV_CPSS_DXCH_BOBCAT2_EQ_TO_CPU_RATE_LIMIT_WINDOW_RESOLUTION_WA_E,/* [JIRA]: [EQ-559] CPU rate limiter is not working at low values of Conf<ToCPU RLWindow Resolution> */
    PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E, /* JIRA [POLICER-1465] */
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RXDMA_PIP_IPV6_WRONG_TC_BITS_WA_E,/* JIRA [RXDMA-982] : PIP : the 'TC' for the IPv6 packets should be bits 116..123 of the packet but actually taken from bits 118..125 */
    PRV_CPSS_DXCH_BOBCAT2_LED_LINK_GIG_INDICATION_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E, /* RM-7056426*/
#ifndef ASIC_SIMULATION
    /* the WA make problems on BC2 systems with TM disabled. The problem under investigation. */
    /*PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E,  *//* RM-9308357 */
#endif /* ASIC_SIMULATION */
    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that not exist in bobcat2_A0 (that existed in bobcat2) */
static GT_U32 notExistsInBobcat2A0ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/* list of Errata/RM that not exist in bobcat2_B0 (that existed in bobcat2) */
static GT_U32 notExistsInBobcat2B0ErrAndRmArray[]=
{
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};


/* list of Errata/RM that are fixed in bobk (that existed in bobcat2) */
static GT_U32 fixedInBobkErrAndRmArray[]=
{
    PRV_CPSS_DXCH_BOBCAT2_GPP_INTERRUPT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_FC_SENT_COUNTERS_PROBLEM_WHEN_FCU_BYPASS_DISABLE_WA_E,
    PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E,
    PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E,
#ifndef  GM_USED
    PRV_CPSS_DXCH_BOBCAT2_EGRESS_MIB_COUNTERS_NOT_ROC_WA_E,
#endif /*! GM_USED*/
    PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E,
#ifndef ASIC_SIMULATION
    PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E,
#endif /* ASIC_SIMULATION */

    LAST_DEV_IN_LIST_CNS/* must be last */
};


/* list of Errata/RM that are fixed in bobcat3 (that existed in bobcat2/bobk) */
static GT_U32 fixedInBobcat3ErrAndRmArray[]=
{
    /* currently empty */

    LAST_DEV_IN_LIST_CNS/* must be last */
};



/* array of additional FEr/RM WA for the xCat2 */
static GT_U32 xcat2ErrAndRmArray[]=
{
    /* FEr - xCat2 */
    PRV_CPSS_DXCH_XCAT2_EPCL_GLOBAL_EN_NOT_FUNCTIONAL_WA_E,/*FEr#3056*/
    PRV_CPSS_DXCH_XCAT2_STACK_MAC_COUNT_NO_CLEAR_ON_READ_WA_E, /*FEr#3092*/

    /* RM - xCat2  */
    PRV_CPSS_DXCH_XCAT2_RM_POLICER_COUNT_FORMAT_WA_E,/*RM#3026*/
    PRV_CPSS_DXCH_XCAT2_RM_INT_EXT_REF_CLK_WA_E,/*RM#3027*/
    PRV_CPSS_DXCH_XCAT2_RM_STACK_PORT_MIB_CNTR_CONTROL_WA_E,/*RM#3028*/
    PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E, /*RM#3029*/
    PRV_CPSS_DXCH_XCAT2_RM_INCORRECT_XG_SHAPER_TOKEN_BUCKET_WA_E,  /*RM#3030*/
    PRV_CPSS_DXCH_XCAT2_RM_BYPASS_PACKET_REFRESH_FDB_AGE_WA_E,  /*RM#3031*/
    PRV_CPSS_DXCH_XCAT2_RM_PIPE_SELECT_WA_E, /*RM#3032*/
    PRV_CPSS_DXCH_XCAT2_RM_FLEX_LINK_PORTS_RATE_LIMIT_WA_E, /*(RM#3038)*/

    /* RM - from legacy device */
    PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E,/*RM#3007*/
    PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E,/*RM#3009*/
    PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E,/*RM#3013*/
    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E,/*RM#3014*/
    PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E,/*RM#3018*/
    PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E,/*(part of RM#3012)*/
    PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E,/*RM#3005*/
    PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E,/*RM#3004*/
    PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E,/*RM#3002,RM#3003*/
    PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E,/*RM#2024*/
    PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E,/*RM#3024*/
    PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E, /* RM#6210962 */

    /* FEr from legacy device */
    PRV_CPSS_DXCH_XCAT_IEEE_RESERVED_MC_CONFG_REG_READ_WA_E,/*FEr#3060*/
    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E,/*FEr#2028*/
    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E,/*FEr#2004*/
    PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E,/*FEr#47*/
    PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E,/*FEr#89*/
    PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E,/*FEr#3119*/
    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E,/*FEr#2033,FEr#2050*/
    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E, /*FEr#2794*/
    PRV_CPSS_DXCH_XCAT_PASSENGER_ETH_PACKET_CRC_CANT_BE_RETAINED_WA_E, /*FEr#2785*/

    /*  VLT direct access write problem with VLAN and STP tables (entry > 1 word) */
    PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E,

    LAST_DEV_IN_LIST_CNS/* must be last */
};

/*
static GT_STATUS deviceListSearch
(
   IN CPSS_PP_DEVICE_TYPE * devList,
   IN CPSS_PP_DEVICE_TYPE devType
)
{
    GT_U32 i;
    for (i = 0 ; devList[i] != LAST_DEV_IN_LIST_CNS ; i++)
    {
        if (devList[i] == devType)
        {
            return GT_OK;
        }
    }
    return GT_NOT_FOUND;
}
*/



/*******************************************************************************
* hwPpDxChBobkEplrMemoriesDefaultSet
*
* DESCRIPTION:
*       Write correct default values into registers.
*
* APPLICABLE DEVICES:
*       Caelum.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2; Bobcat2; Bobcat3.
*
* INPUTS:
*       devNum  - device number
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpDxChBobkEplrMemoriesDefaultSet
(
    IN GT_U8 devNum
)
{
    GT_STATUS rc = GT_OK; /* return code */
    GT_U32 regAddr;      /* register's address */

    CPSS_DXCH_POLICER_STAGE_TYPE_ENT stage = CPSS_DXCH_POLICER_STAGE_EGRESS_E;

    GT_U32                           entryIndex;
    GT_U32                           entryValue[2] = {0, 0};

    /* Initialize Egress Policer Remarking Table to 0 */
    for (entryIndex = 0; entryIndex < 80; entryIndex++)
    {
        rc = prvCpssDxChWriteTableEntry(devNum,
                                        PRV_CPSS_DXCH_XCAT_TABLE_EGRESS_POLICER_REMARKING_E,
                                        entryIndex,
                                        &entryValue[0]);
        if(rc != GT_OK)
            return rc;
    }

    /* Initialize IP Fix Port Group Wraparound Table */
    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).ipfixWrapAroundAlertTbl;
    for (entryIndex = 0; entryIndex < 128; entryIndex++)
    {
        rc = prvCpssDrvHwPpWriteRegister(devNum,
                                            (regAddr + entryIndex*4),
                                            0);
        if(rc != GT_OK)
            return rc;
    }

    /* Initialize IP Fix Port Group Aging Status Table */
    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,stage).ipfixAgingAlertTbl;
    for (entryIndex = 0; entryIndex < 128; entryIndex++)
    {
        rc = prvCpssDrvHwPpWriteRegister(devNum,
                                            (regAddr + entryIndex*4),
                                            0);
        if(rc != GT_OK)
            return rc;
    }

    /* Initialize Egress Policer Trigger Table to 0 */
    for (entryIndex = 0; entryIndex < _6K; entryIndex++)
    {
        rc = prvCpssDxChWriteTableEntry(devNum,
                                           PRV_CPSS_DXCH_LION3_TABLE_EGRESS_POLICER_E_ATTRIBUTES_E,
                                           entryIndex,
                                           &entryValue[0]);
        if(rc != GT_OK)
            return rc;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3NetworkSerdesBitmapGet
*
* DESCRIPTION:
*       Get device available SERDES bitmap
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - device number
*       powerDownBmpPtr - (pointer to) bitmask of ports that have not to be powered up
*
* OUTPUTS:
*       networkSerdesPowerUpBmpPtr - (pointer to) device SERDES bitmap for powerUp operation
*       networkSerdesBmpPtr - (pointer to) device SERDES bitmap
*
* RETURNS:
*       None.
*
* COMMENTS:
*       SERDES group represents four SERDESes (6 Network SERDES groups, 1 - combo SERDES group)
*       This function creates bitmap only for Network SERDESes and not relevants for
*       combo SERDES group.
*
*******************************************************************************/
static GT_VOID prvCpssDxCh3NetworkSerdesBitmapGet
(
    IN GT_U8   devNum,
    IN CPSS_PORTS_BMP_STC   *powerDownBmpPtr,
    OUT GT_U32              *networkSerdesPowerUpBmpPtr,
    OUT GT_U32              *networkSerdesBmpPtr
)
{
    GT_U32 port;    /* Port */
    GT_U32 serdes;  /* Start SERDES in the group */
    GT_U32 lane;    /* SERDES group lane */

    /* Reset initial bitmap to zero */
    *networkSerdesBmpPtr = 0;
    *networkSerdesPowerUpBmpPtr = 0;

    /* Loop all network ports */
    for(port = 0; port < 24; port++)
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

        if (PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum, port) == PRV_CPSS_PORT_XG_E)
        {
            /* Convert network port to corresponding SERDES */
            serdes = (port / 4) * 4;

            /* Set SERDES bitmap per existed XG port */
            for(lane = 0; lane < 4; lane++)
            {
                *networkSerdesBmpPtr |= (1 << (serdes + lane));
                if ((powerDownBmpPtr->ports[0] & (1 << port)) == 0 )
                {   /* port is not in power down bitmap. Need power UP SERDES for it */
                    *networkSerdesPowerUpBmpPtr |= (1 << (serdes + lane));
                }
            }
        }
        else
        {
            /* Set SERDES bitmap per network port */
            *networkSerdesBmpPtr |= (1 << port);
            *networkSerdesPowerUpBmpPtr |= ((1 << port) & ~powerDownBmpPtr->ports[0]);
        }
    }
}

/*******************************************************************************
* prvCpssDxXcatNetworkSerdesBitmapGet
*
* DESCRIPTION:
*       Get device available SERDES bitmap
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - device number
*       powerDownBmpPtr - bitmask of ports that have not to be powered up
*
* OUTPUTS:
*       networkSerdesBmpPtr - (pointer to) device SERDES bitmap
*
* RETURNS:
*       None.
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID prvCpssDxXcatNetworkSerdesBitmapGet
(
    IN GT_U8   devNum,
    IN CPSS_PORTS_BMP_STC   *powerDownBmpPtr,
    OUT GT_U32              *networkSerdesBmpPtr
)
{
    GT_U32 port;    /* Port */
    GT_U32 serdes;  /* Start SERDES in the group */

    /* Reset initial bitmap to zero */
    *networkSerdesBmpPtr = 0;

    /* Loop all network ports */
    for(port = 0; port < 24; port++)
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);
        serdes = (port / 4);

        if ((powerDownBmpPtr->ports[0] & (1 << port)) == 0 )
        {   /* port is not in power down bitmap. Need power UP SERDES for it */
            *networkSerdesBmpPtr |= (1 << (serdes));
        }
    }
}

/*******************************************************************************
* prvCpssDxCh3TcamEfuseWa
*
* DESCRIPTION:
*       Implement the replacement operations for the tcam efuse WA (FEr#2191)
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       tcamTestPointerAddrPtr  - (pointer to) array of the tcam test pointer registers address
*       numOfPointerRegs        - number of tcam test pointer registers
*       tcamTestConfigAddr      - address of the tcam test config status register
*
* OUTPUTS:
*       replaceRowPtr   - (pointer to) the row number which is used to replace
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3TcamEfuseWa
(
    IN GT_U8    devNum,
    IN GT_U32   *tcamTestPointerAddrPtr,
    IN GT_U32   numOfPointerRegs,
    IN GT_U32   tcamTestConfigAddr,
    OUT GT_U32  *replaceRowPtr
)
{
    GT_STATUS rc;           /* return status */
    GT_U32    i;            /* loop counter */
    GT_U32    regData;      /* register data */
    GT_U32    busyIterator; /* Counter for busy wait loops */

    *replaceRowPtr = NO_TCAM_ROW_TO_REPLACE_CNS;

    for(i = 0; i < numOfPointerRegs ; i++)
    {
        rc = prvCpssDrvHwPpReadRegister(devNum, tcamTestPointerAddrPtr[i], &regData);
        if( rc != GT_OK )
        {
            return rc;
        }

        /* valid data at pointer register */
        if( (regData & 0x100) == 0x100 )
        {
            *replaceRowPtr = (regData & 0xFF) + (i << 8);
            break;
        }
    }

    /* no replacement needed */
    if( i == numOfPointerRegs )
    {
        return GT_OK;
    }

    /* The entries in the last row of the TCAM logical sub-block for the row that was */
    /* replaced. A TCAM logical sub-block comprises 128 rows.                         */
    LAST_SUB_BLOCK_ROW_CALC_MAC(*replaceRowPtr);

    /* The following sequence (inside the "for" clause) is done two times to ensure */
    /* that the replacement operation has been completed.                             */
    for(i = 0; i < 2 ; i++)
    {
        rc = prvCpssDrvHwPpWriteRegister(devNum, tcamTestConfigAddr, 0x1038B);
        if( rc != GT_OK )
        {
            return rc;
        }

        busyIterator = 0;
        /* now busy wait until the write process is finished */
        do
        {
            rc = prvCpssDrvHwPpReadRegister(devNum, tcamTestConfigAddr, &regData);
            if( rc != GT_OK )
            {
                return rc;
            }
            /* check that number of iteration not over the limit */
            PRV_CPSS_MAX_NUM_ITERATIONS_CHECK_CNS(devNum,(busyIterator++));
        } while (regData != 0x1028B);
    }

    rc = prvCpssDrvHwPpWriteRegister(devNum, tcamTestConfigAddr, 0x28B);

    return rc;
}

/*******************************************************************************
* prvCpssDxCh3TcamWa
*
* DESCRIPTION:
*       runs BISTs on PCL & Router TCAM if efuse not burned.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - The device number
*
* OUTPUTS:
*       None.

* RETURNS:
*       GT_OK         - on success
*       GT_HW_ERROR   - on hardware error
*       GT_BAD_PARAM  - on bad devNum
*       GT_UNFIXABLE_BIST_ERROR  - on unfixable problem in the TCAM
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3TcamWa
(
    IN GT_U8 devNum
)
{
    GT_BOOL blockFixed = GT_FALSE;
    GT_U32 replacedIndex;
    GT_U32 i;
    GT_STATUS rc;

    /* Checks if Efuse was burned - PCL TCAM */
    for (i=0;i < 14;i++)
    {
        rc = cpssDxChDiagMemoryBistBlockStatusGet(devNum,
              CPSS_DIAG_PP_MEM_BIST_PCL_TCAM_E,i,&blockFixed,&replacedIndex);
        if (rc != GT_OK)
        {
            return rc;
        }
        if (blockFixed == GT_TRUE)
        {
            break;
        }
    }

    /* Efuse has not been burnt - run BISTs on PCL TCAM */
    if (blockFixed == GT_FALSE)
    {
        rc = cpssDxChDiagMemoryBistsRun(devNum,
                                        CPSS_DIAG_PP_MEM_BIST_PCL_TCAM_E,
                                        CPSS_DIAG_PP_MEM_BIST_PURE_MEMORY_TEST_E,
                                        2000,
                                        GT_TRUE,
                                        NULL,
                                        NULL);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    /* Checks if Efuse was burned - ROUTER TCAM */
    for (i=0;i < 20;i++)
    {
        rc = cpssDxChDiagMemoryBistBlockStatusGet(devNum,
              CPSS_DIAG_PP_MEM_BIST_ROUTER_TCAM_E,i,&blockFixed,&replacedIndex);
        if (rc != GT_OK)
        {
            return rc;
        }
        if (blockFixed == GT_TRUE)
        {
            break;
        }
    }

    /* Efuse has not been burnt - run BISTs on ROUTER TCAM */
    if (blockFixed == GT_FALSE)
    {
        rc = cpssDxChDiagMemoryBistsRun(devNum,
                                        CPSS_DIAG_PP_MEM_BIST_ROUTER_TCAM_E,
                                        CPSS_DIAG_PP_MEM_BIST_PURE_MEMORY_TEST_E,
                                        2000,
                                        GT_TRUE,
                                        NULL,
                                        NULL);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    return GT_OK;
}

/*******************************************************************************
* hwPpCheetahCommonRegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Cheetah registers
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpCheetahCommonRegsDefault
(
    IN GT_U8   devNum
)
{
    GT_U32 regAddr;      /* register's address */

    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
              PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E) == GT_TRUE)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_FDB_MAC(devNum).FDBCore.FDBGlobalConfig.FDBGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.macControlReg;
        }

        if (prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, 0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpCheetahRegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Cheetah registers
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond.
*
* NOT APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - device number
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpCheetahRegsDefault
(
    IN GT_U8   devNum
)
{
    GT_STATUS rc;     /* return code */
    GT_U32 regAddr;   /* register's address */
    GT_U8  port;      /* iterator */

    /* start with the common settings */
    rc =  hwPpCheetahCommonRegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Mirrored Packets to Analyzer Port Descriptors Limit
       Configuration Register.
       Mirrored Packets to Analyzer Port Descriptors Limit is too high.
       This value should be low enough in order not to generate FC packets
       due to Mirroring.
       Since Xoff value is 70, and 1.5K packets require 6 buffers, this value
       should be set to 0xA. (70-10*6=10 spare).
       (RM#9) - relevant for all DxCh devices
       WA: default value of of bits[0..11] should be 4 */

    if (prvCpssDrvHwPpWriteRegister(devNum,0x01800024,0xA004) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    /* GE and XG ports configurations */
    for( port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
    {
        if ((PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[port].portType ==
             PRV_CPSS_PORT_NOT_EXISTS_E) ||
            (PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[port].portType ==
             PRV_CPSS_PORT_FE_E))
            continue;

        if (PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[port].portType ==
             PRV_CPSS_PORT_GE_E)
        {

            /* Set Port SERDES Config Register3
              - Bits [10:9] <EQ_BIAS> => 0x3
              - Bits[15:14] <BG_VSelBits> => 0x2
              - Bits [13:11] <TPVL> => 0x0 */
            regAddr = 0x0A800034 + (port << 8);
            if (prvCpssDrvHwPpWriteRegister(devNum,regAddr,0x8600) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Set Port SERDES Config Register0 - set amplitude = 600mv,
               field OutAmp = 3 */
            regAddr = 0x0A800028 + (port << 8);
            if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 13, 3, 3) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        else
        {
            /* Port<n> FIFOs Thresholds Configuration Register:
               Bits [14:10], <TXRdThr> => 0x6, Avoid underruns in the fifo*/
            /* FIFOs Thresholds Configuration register (24<=n<27) default value
               is incorrect (RM#7). WA - Change default value */
            regAddr = 0x0A800010 + (port << 8);
            if (prvCpssDrvHwPpSetRegField(devNum, regAddr,0, 16, 0x000019EA)
                != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[port].portTypeOptions !=
                PRV_CPSS_XG_PORT_HX_QX_ONLY_E)
            {
                /***********  Midway Settings ********
                  Set pre-emphasis to 0% and reset the lane.- HWCFG_MODE = 0xA  */

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                                 0x8000,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0x800A) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                                 0x8001,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0x800A) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                                 0x8002,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0x800A) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                                 0x8003,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0x800A) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);


                /* Loop Gain (Cheetah-A1/A2) - Loop Gain = 0x0 */
                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0,GT_FALSE,
                                                0xff2c,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0x2C01) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0,GT_FALSE,
                                                0xff2c,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0x2C01)!= GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                /* Amplitude / Pre-Emphasis / Interpolator setting
                 - Cheetah A0 -Interpolator input 7 bits control/Ampl=4/PreEmp=0
                 - Cheetah A1 / Cheetah+ A1 Interpolator input 6 bits
                                            control/Ampl=4/PreEmp=0/ */
                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                                0xff28,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff28,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff29,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff29,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff2A,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff2A,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff2B,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff2B,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0xC000) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

               /* SERDES Rx equalizer settings. (RM#161) */

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff40,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0x3D) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff41,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0x3D) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff42,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0x3D) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                0, GT_FALSE,
                                                0xff43,
                                                PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                0x3D) != GT_OK)
                     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_RM_XG_PHY_PATH_FAILURE_WA_E))
                {
                    /* Fix XG PHY path failure, Rm#83 */
                    if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                     0, GT_FALSE,
                                                     0xff34,
                                                     PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                     0xff00) != GT_OK)
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                    if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                     0, GT_FALSE,
                                                     0xff34,
                                                     PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                     0xff00) != GT_OK)
                       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                    if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                     0, GT_FALSE,
                                                     0xff34,
                                                     PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                     0xe000) != GT_OK)
                       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }

                /* Improve the XAUI performance for A2 silicon and for DX249/269
                   A0, by implementing RN#169. */
                if((PRV_CPSS_PP_MAC(devNum)->revision >= 2) ||
                   (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX249_CNS) ||
                   (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX269_CNS) ||
                   (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX169_CNS))
                {
                    if(cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                 0, GT_FALSE,
                                                 0xff44,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0x18) != GT_OK)
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
            }
        }
    }

    /* CPU port configuration
       Port<63> Auto-Negotiation Configuration Register:
       Bit [11], AnFcEn - For CPU port, this field should be 0x0 and not 0x1. */
    regAddr = 0x0A803F0C;
    if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 11, 1, 0) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    /* Buffer Memory MPPM Configuration Register:
      Bits [15:11], <GigEFIFORdthreshold> => 0xA,
      Avoid bufmem-port protocol violations in case of collisions.*/
    /* Buffer Memory MPPM Configuration Register default value is incorrect.
       (RM#8) */
    regAddr = 0x0780000C;
    if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00005042) != GT_OK)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    /*  (RM#26) Setting buffer DRAM to 1Mb for Dx106 and Dx107 devices */
    if(PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX106_CNS ||
       PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX107_CNS)
    {
        /* Buffer Management Global Buffers Limits Configuration Register,
           offset 0x3000000 */
        regAddr = 0x3000000;
        if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 0, 31, 0xFC70896)
            != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        /* Buffer Management GigE Port Group Limits Configuration Register,
           offset 0x3000004  */
        regAddr = 0x3000004;
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x1F880100) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        /* Transmit Queue Control Register - Set total desriptors number  */
        regAddr = 0x01800000;
        if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 16, 16,  0x1A2) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        /* Total buffer limit configuration register  */
        regAddr = 0x01800084;
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x15E) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

    if(PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX107_CNS)
    {
       /* (RM#163) - zero SERDES configuration registers for not existing ports */
        for(port = 10; port < 24; port++)
        {
            if (prvCpssDrvHwPpWriteRegister(devNum, 0x0A800028 + (port << 8), 0)
                 != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    }
     /*  (RM#27) Correct memory configuration for DX249/169 devices */
    else if((PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX249_CNS) ||
            (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX169_CNS) ||
            (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX163_CNS) ||
            (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX243_CNS))
    {
        /* Buffer Management Global Buffers Limits Configuration Register,
           offset 0x03000000 */
        regAddr = 0x03000000;
        if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 0, 31, 0x301591CC) !=
            GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        /* Buffer Management GigE Port Group Limits Configuration Register,
           offset 0x03000004  */
        regAddr = 0x03000004;
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x60180300) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        /* Transmit Queue Control Register - Set total desriptors number  */
        regAddr = 0x01800000;
        if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 16, 16, 0x53A) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

        /* Total buffer limit configuration register  */
        regAddr = 0x01800084;
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x498) != GT_OK)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX133_CNS)
    {
       /* zero SERDES configuration registers for not existing ports */
        for(port = 12; port < 24; port++)
        {
            if (prvCpssDrvHwPpWriteRegister(devNum, 0x0A800028 + (port << 8), 0)
                 != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;


}

/*******************************************************************************
* hwPpCheetah2RegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Cheetah registers
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond.
*
* INPUTS:
*       devNum  - device number
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/

static GT_STATUS hwPpCheetah2RegsDefault
(
    IN GT_U8   devNum
)
{
    GT_STATUS rc;        /* return code */
    GT_U32 regAddr;      /* register's address */
    GT_U8  port;         /* iterator           */
    GT_U8  gigaPortsNum; /* giga Ports Num     */
    GT_U8  xgPortsNum;   /* xg Ports Num       */

    /* start with the common settings */
    rc =  hwPpCheetahCommonRegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

      /* GE and XG ports configurations */
    for( port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
    {
        if (PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[port].portType ==
             PRV_CPSS_PORT_NOT_EXISTS_E)
            continue;

        if (PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[port].portType ==
             PRV_CPSS_PORT_GE_E)
        {

            /* Set Port SERDES Config Register3
              - Bits [10:9] <EQ_BIAS> => 0x3
              - Bits[15:14] <BG_VSelBits> => 0x2
              - Bits [13:11] <TPVL> => 0x0 */
            regAddr = 0x0A800034 + (port << 8);
            if (prvCpssDrvHwPpWriteRegister(devNum,regAddr,0x8600) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Set Port SERDES Config Register0 - set amplitude = 600mv,
               field OutAmp = 3 */
            regAddr = 0x0A800028 + (port << 8);
            if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 13, 3, 3) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        else
        {


            /***********  Midway Settings ********
              Set pre-emphasis to 0% and reset the lane.- HWCFG_MODE = 0xA  */
            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                             0x8000,
                                             PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                             0x800A) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                             0x8001,
                                             PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                             0x800A) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                             0x8002,
                                             PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                             0x800A) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                             0x8003,
                                             PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                             0x800A) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);


            /* Loop Gain (Cheetah-A1/Cheetah+-A0) - Loop Gain = 0x0 */
                /* set data for next settings- Cheetah A0 */


            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0,GT_FALSE,
                                        0xff2c,
                                        PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                        0x2C01) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0,GT_FALSE,
                                        0xff2c,
                                        PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                        0x2C01)!= GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);


            /* Amplitude / Pre-Emphasis / Interpolator setting
             - Cheetah A1 /  A2 Interpolator input 6 bits
                                        control/Ampl=4/PreEmp=0/ */
            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,0, GT_FALSE,
                                            0xff28,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff28,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff29,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff29,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff2A,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff2A,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff2B,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff2B,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0xC000) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);



            /* SERDES Rx equalizer settings (RM#161) */

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff40,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0x3D) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff41,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0x3D) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff42,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0x3D) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                            0, GT_FALSE,
                                            0xff43,
                                            PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                            0x3D) != GT_OK)
                 CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_RM_XG_PHY_PATH_FAILURE_WA_E))
            {
                /* Fix XG PHY path failure, Rm#83 */
                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                 0, GT_FALSE,
                                                 0xff34,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0xff00) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                 0, GT_FALSE,
                                                 0xff34,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0xff00) != GT_OK)
                   CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);

                if (cpssDxChPhyPort10GSmiRegisterWrite(devNum,port,
                                                 0, GT_FALSE,
                                                 0xff34,
                                                 PRV_CPSS_PHY_XENPAK_DEV_ADDRESS_CNS,
                                                 0xe000) != GT_OK)
                   CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }


        }

    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH2_RM_RESERVED_REGISTERS_0x0B820108_WA_E))
    {
        /* (RM#1081) */
        if (prvCpssDrvHwPpWriteRegister(devNum,0x0B820108,0xB80) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    if(GT_TRUE ==
        PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E))
    {
        /* Reset NST( Network Shield ) registers  -
           Bridge Global Configuration Registers */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                     bridgeRegs.bridgeGlobalConfigRegArray[0];

        /* Disable dropping ARP packets with MAC SA not equal to the ARP
           payload data contains a field called <source hardware address>
           + all TCP Sanity checks */
        if(prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x20030000, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Disable all TCP related bits(0-4) + disable ICMP dropping(bit 5) */
        if(prvCpssDrvHwPpWriteRegBitMask(devNum,(regAddr + 0xC),0x0000003F, 0x0)
            != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    gigaPortsNum = 24;
    xgPortsNum   = 0;
    switch (PRV_CPSS_PP_MAC(devNum)->devType)
    {
        case CPSS_98DX125_CNS: gigaPortsNum = 12; break;
        case CPSS_98DX145_CNS: gigaPortsNum = 12; xgPortsNum = 2; break;
        case CPSS_98DX255_CNS: xgPortsNum = 0; break;
        case CPSS_98DX265_CNS: xgPortsNum = 2; break;
        case CPSS_98DX275_CNS: xgPortsNum = 3; break;
        case CPSS_98DX285_CNS: xgPortsNum = 4; break;
        case CPSS_98DX804_CNS: gigaPortsNum = 0; xgPortsNum = 4; break;
        default: break;
    }

    /* power off SERDES of not existing GIGA ports */
    for (port = gigaPortsNum; (port < 24); port++)
    {
        if (prvCpssDrvHwPpWriteRegister(
            devNum, (0x0A800028 + (port << 8)), 1)
            != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }


    /* power off SERDES of not existing 10-GIGA ports */
    for (port = (GT_U8)(24 + xgPortsNum); (port < 28); port++)
    {
        if (prvCpssDrvHwPpWriteRegister(
            devNum, (0x0A80181C + ((port - 24) * 0x100)), 0x804)
            != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
              PRV_CPSS_DXCH2_READ_SRC_ID_ASSIGMENT_MODE_CONF_REG_WA_E) == GT_TRUE)
    {
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                   bridgeRegs.srcIdReg.srcIdAssignedModeConfReg;
        if (prvCpssDrvHwPpWriteRegister(devNum,regAddr,0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        (PRV_CPSS_DXCH_PP_MAC(devNum))->errata.srcIdAssignedModeConfRegData = 0;

    }
    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
              PRV_CPSS_DXCH2_BRIDGE_ACCESS_MATRIX_LINE7_WRITE_WA_E) == GT_TRUE)
    {
        if (prvCpssDrvHwPpWriteRegister(devNum,0x0200061C,0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        (PRV_CPSS_DXCH_PP_MAC(devNum))->
                                      errata.bridgeAccessMatrixLine7RegData = 0;
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpCheetah3PortsAndSerdesRegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Cheetah3 ports and SERDES registers
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - (pointer to) Packet processor hardware specific
*                            parameters.
*
* OUTPUTS:
*       networkSerdesPowerUpBmpPtr - (pointer to) bitmap of network SERDES to
*                                    be power UP.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpCheetah3PortsAndSerdesRegsDefault
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr,
    OUT GT_U32                                 *networkSerdesPowerUpBmpPtr
)
{
    GT_U32 regAddr;     /* register's address   */
    GT_U32 regValue;    /* register value       */
    GT_U32 portNum;     /* port number          */
    GT_U32 lane;        /* lane number          */
    GT_U32 devType;     /* device type          */
    GT_BOOL ch3XgDevice; /* XG Cheetah 3 family */
    GT_U32 serdesNum;   /* SERDES number        */
    GT_U32 networkSerdesBmp = 0;   /* device SERDES bitmap */

    /* define type of DxCh3 device either Gig or XG */
    devType = PRV_CPSS_PP_MAC(devNum)->devType;

    switch(devType)
    {
        case PRV_CPSS_CHEETAH3_XG_PORTS_DEVICES_CASES_MAC:
            ch3XgDevice = GT_TRUE;
            break;
        default:
            ch3XgDevice = GT_FALSE;
            break;
    }

    /* Set device SERDES bitmap */
    prvCpssDxCh3NetworkSerdesBitmapGet(devNum,
                                       &ppPhase1ParamsPtr->powerDownPortsBmp,
                                       networkSerdesPowerUpBmpPtr,
                                       &networkSerdesBmp);

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH3_SERDES_YIELD_IMPROVEMENT_WA_E))
    {
        /* SERDES yield improvement due to PLL unlocking issue. */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[0].serdesReservConf[0];
        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum++ )
        {
            if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 12, 1, 0) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr+=0x400;
        }
    }

    if (ppPhase1ParamsPtr->initSerdesDefaults == GT_TRUE)
    {
    /* FEr#2014 - Select the 156.25 MHz differential clock */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_SAMPLE_AT_RESET_NET_REF_CLOCK_SELECT_WA_E))
    {
        /* NP ref clock configurations */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[0].serdesSpeed1[0];
        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);

            /* Set register value for all DxCh3 devices with XG ports  */
            if(ch3XgDevice == GT_TRUE)
            {
                regValue = 0x0000264A;
            }
            else
            {
                regValue = 0x0000213A;
            }

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, regValue) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr += 0x400;
        }

        /* NP SERDES common register, change NP clock to differential mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[0].serdesCommon[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000000B) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* NP SERDES electrical configuration
     * Change TxSyncEn to 1.
     * RM#2106 - SERDES Tx Sync Conf Registers
    */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[0].serdesTxSyncConf[0];
     for( serdesNum = 0 ; serdesNum < 24 ; serdesNum++ )
     {
         PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);
         if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000003) != GT_OK)
         {
             CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
         }
         regAddr += 0x400;
    }

    /* NP SERDES electrical configuration
     * RX Conf. Register - FFE_RES_SEL=4, FFE_CAP_SEL=0
    */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[0].serdesRxConfReg1[0];
    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);

        /* SERDES Rx Configuration register */
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000C22) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        regAddr += 0x400;
    }

    if(ch3XgDevice == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[0].serdesIvrefConf1[0];

        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);

            /* NP SERDES electrical configuration
             * IVREF Conf Register1 - TxVdd=3, for 98DX81xx
             * RM#2107 - Network ports electrical settings violation at defaults
            */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000575A) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr += 0x400;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[0].serdesIvrefConf2[0];

        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);

            /* NP SERDES electrical configuration
             * IIVREF Conf Register2 - Vddr10Pll=2, for 98DX81xx
             * RM#2107 - Network ports electrical settings violation at defaults
            */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000003) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr += 0x400;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[0].serdesMiscConf[0];

        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);

            /* NP SERDES electrical configuration
             * Misc Conf Register - CLK_DET_EN=0, for 98DX81xx
             * RM#2107 - Network ports electrical settings violation at defaults
            */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000008) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr += 0x400;
        }
    }

    /* NP SERDES powerup and calibration */
    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum += 4 )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

        /* PowerUp Register 1.
        SerdesPowerUp1 and serdesPowerUp2 or serdesReset registers are per SERDES group.
        Group is 4 SERDESes. If first SERDES exists in SERDES bitmap then all exist in a group */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[serdesNum].serdesPowerUp1[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x000000FF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* PowerUp Register 2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[serdesNum].serdesPowerUp2[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x000000FF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait at least 10 usec */
    cpssOsTimerWkAfter(1);

    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum += 4 )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

        /* Analog Reset.
        SerdesPowerUp1 and serdesPowerUp2 or serdesReset registers are per SERDES group.
        Group is 4 SERDESes. If first SERDES exists in SERDES bitmap then all exist in a group */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000FF0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* Calibration Conf register, start automatic impedance calibration and PLL calibration */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[0].serdesCalibConf1[0];
    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00003333) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        regAddr += 0x400;
    }

    /* wait at least 5 msec */
    cpssOsTimerWkAfter(5);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[0].serdesMiscConf[0];

    if (ch3XgDevice == GT_TRUE)
    {   /* XG - 98DX81x */

        /* Misc. Configuration Register: Reset TxSyncFIFO; Sample Tx Data at Posedge; CLK_DET_EN=0 */
        regValue = 0x4;
    }
    else
    {   /* GIG - 98DX5x */

        /* Misc. Configuration Register: Reset TxSyncFIFO; Sample Tx Data at Posedge */
        regValue = 0x5;
    }

    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

        /* Reset TxSyncFIFO */
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, regValue) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        regAddr += 0x400;
    }

    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum += 4 )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

        /* Rx\DTL --> Normal operation.
        SerdesPowerUp1 and serdesPowerUp2 or serdesReset registers are per SERDES group.
        Group is 4 SERDESes. If first SERDES exists in SERDES bitmap then all exist in a group */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000000) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[0].serdesMiscConf[0];

    if (ch3XgDevice == GT_TRUE)
    {   /* XG - 98DX81x */

        /* Misc. Configuration Register: DeAssert Reset TxSyncFIFO; Sample Tx Data at Posedge; CLK_DET_EN=0 */
        regValue = 0x0000000C;
    }
    else
    {   /* GIG - 98DX5x */

        /* "Misc. Configuration Register: DeAssert Reset TxSyncFIFO and Sample Tx Data at Posedge */
        regValue = 0x0000000D;
    }

    for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

        /* DeAssert Reset */
        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, regValue) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        regAddr += 0x400;
    }

    /* RX Conf. Register */

    if (ch3XgDevice == GT_TRUE)
    {

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[0].serdesRxConfReg1[0];

        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

            /* RX Conf. Register - FFE_RES_SEL=4, FFE_CAP_SEL=0, RESET_INTP_EXT_RX=1 */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00004C22) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr += 0x400;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[0].serdesRxConfReg1[0];

        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum ++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, (*networkSerdesPowerUpBmpPtr));

            /* RX Conf. Register - FFE_RES_SEL=4, FFE_CAP_SEL=0, RESET_INTP_EXT_RX=0 */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000C22) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr += 0x400;
        }
    }
    } /* ppPhase1ParamsPtr->initSerdesDefaults == GT_TRUE */
    else
        *networkSerdesPowerUpBmpPtr = 0;

    /* NP MAC/PCS Reset */
    if(ch3XgDevice == GT_FALSE)
    {
        regAddr = 0x0A800008; /* macCtrl2 */
        for( serdesNum = 0 ; serdesNum < 24 ; serdesNum++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);

            /* De-assert port reset */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000C008) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
            regAddr += 0x400;
        }

    }
    else
    {
        /*De-assert reset on PCS, for 98DX81xx only
          De-assert reset on XG MAC, for 98DX81xx only */
        for( portNum = 0 ; portNum < 24 ; portNum++ )
        {
            if(PRV_CPSS_PP_MAC(devNum)->phyPortInfoArray[portNum].portType !=
               PRV_CPSS_PORT_NOT_EXISTS_E)
            {
                /* Activate NP XPCS - Deassert reset on group XPCS */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].xgGlobalConfReg0;

                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000047) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }

                /* Activate NP XG MAC - Deassert reset on group XG MAC */
                PRV_CPSS_DXCH_PORT_MAC_CTRL_REG_MAC(devNum,portNum,PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,portNum),&regAddr);


                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00002403) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
            }
        }
    }

    if (ppPhase1ParamsPtr->initSerdesDefaults == GT_TRUE)
    {
    /* HGS SERDES electrical configurations, 3.125G configurations */
    for( portNum = 24 ; portNum < 28 ; portNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);

        for( lane = 0 ; lane < 4 ; lane++ )
        {
            /* Speed Register 1, bit 10, FBDIV = 0x08 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesSpeed1[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00002421) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Speed Register 3, FcEn bit to SAS/SATA mode and bit 1 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesSpeed3[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000003) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Tx Conf Register 1, Amp=0x31, 50% pre-emphasis */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesTxConfReg1[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x000027BE) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Rx Conf Register 1, Ffelsel=2, FfeResSel=0, FfeCapSel=0 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesRxConfReg1[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000C04) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* DTL Conf Register 2, Selmupi=1 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesDtlConfReg2[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00002800) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* DTL Conf Register 3, Selmupf = 0x1, selmufi = 0x2, Selmuff = 0x2 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesDtlConfReg3[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x000002A9) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* Reserv Conf Register, DFE_UPDATE_EN=0 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesReservConf[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000F070) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            /* IVREF Conf Register 1, RxVdd10=11 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesIvrefConf1[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000557B) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    /*********************/
    /* SP SERDES Powerup */
    /*********************/
    for( portNum = 24 ; portNum < 28 ; portNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
        PRV_CPSS_DXCH_SKIP_POWER_DOWN_PORTS_MAC(portNum, ppPhase1ParamsPtr->powerDownPortsBmp.ports[0]);

        /* PowerUp Register 1.
        SerdesPowerUp1 and serdesPowerUp2 or serdesReset registers are per SERDES group.
        Group is 4 SERDESes. If first SERDES exists in SERDES bitmap then all exist in a group */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesPowerUp1[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x000000FF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* PowerUp Register 2 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesPowerUp2[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x000000FF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Wait at least 10 usec */
        cpssOsTimerWkAfter(1);

        /* Analog Reset, Reset calibration logic.
        SerdesPowerUp1 and serdesPowerUp2 or serdesReset registers are per SERDES group.
        Group is 4 SERDESes. If first SERDES exists in SERDES bitmap then all exist in a group */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000FFF0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    for( portNum = 24 ; portNum < 28 ; portNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
        PRV_CPSS_DXCH_SKIP_POWER_DOWN_PORTS_MAC(portNum, ppPhase1ParamsPtr->powerDownPortsBmp.ports[0]);

        for( lane = 0 ; lane < 4 ; lane++ )
        {
            /* Start PLL Calibration */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                macRegs.perPortRegs[portNum].serdesCalibConf1[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000400) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        for( lane = 0 ; lane < 4 ; lane++ )
        {
                /* Start DLL Calibration */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    macRegs.perPortRegs[portNum].serdesCalibConf2[lane];

                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000001) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
        }

        for( lane = 0 ; lane < 4 ; lane++ )
        {
                /* Start Impedance Calibration */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    macRegs.perPortRegs[portNum].serdesCalibConf1[lane];

                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000401) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
        }

        for( lane = 0 ; lane < 4 ; lane++ )
        {
                /* Start Process Calibration */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    macRegs.perPortRegs[portNum].serdesProcessMon[lane];

                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00001B61) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
        }

        for( lane = 0 ; lane < 4 ; lane++ )
        {
                /* Start Sampler Calibration */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    macRegs.perPortRegs[portNum].serdesCalibConf2[lane];

                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000041) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
        }

        for( lane = 0 ; lane < 4 ; lane++ )
        {
                /* Reset TxSyncFIFO; Sample Tx Data at Posedge */
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    macRegs.perPortRegs[portNum].serdesMiscConf[lane];

                if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000004) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
        }
    }

    /* Wait at least 10 usec */
    cpssOsTimerWkAfter(1);

    /* Rx/DTL --> Normal operation, per Group (each group contains 4 ports) */
    for( portNum = 24 ; portNum < 28 ; portNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
        PRV_CPSS_DXCH_SKIP_POWER_DOWN_PORTS_MAC(portNum, ppPhase1ParamsPtr->powerDownPortsBmp.ports[0]);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000000) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* Wait at least 10 msec */
    cpssOsTimerWkAfter(10);

    /* DeAssert Reset TxSyncFIFO; Sample Tx Data at Posedge */
    for( portNum = 24 ; portNum < 28 ; portNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
        PRV_CPSS_DXCH_SKIP_POWER_DOWN_PORTS_MAC(portNum, ppPhase1ParamsPtr->powerDownPortsBmp.ports[0]);

        for( lane = 0 ; lane < 4 ; lane++ )
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].serdesMiscConf[lane];

            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x0000000C) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }
    } /* ppPhase1ParamsPtr->initSerdesDefaults == GT_TRUE */

    /* HGS MAC/PCS Reset */
    for( portNum = 24 ; portNum < 28 ; portNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);

        /* Disable reset on PCS */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[portNum].xgGlobalConfReg0;

        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00000047) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* De-assert port reset */
        PRV_CPSS_DXCH_PORT_MAC_CTRL_REG_MAC(devNum,portNum,PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,portNum),&regAddr);


        if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x00002403) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPortSerdesWriteRegBitMask
*
* DESCRIPTION:
*       Write to all related port SERDES the masked value
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - device number
*       xgDevice    - GT_TRUE for XG device, GT_FALSE for GE device
*       regAddrPtr  - (pointer to) register address or array start of
*                     register addresses.
*       mask        - Mask for selecting the written bits.
*       value       - Data to be written to register or registers
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       The bits in value to be written are the masked bit of 'mask'.
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPortSerdesWriteRegBitMask
(
    IN GT_U8    devNum,
    IN GT_BOOL  xgDevice,
    IN GT_U32   *regAddrPtr,
    IN GT_U32   mask,
    IN GT_U32   value
)
{
    GT_U32      laneNum;    /* number of lanes per port */
    GT_U32      i;          /* loop index */

    if( xgDevice == GT_TRUE )
    {
        /* XG port */
        laneNum = 4;
    }
    else /* xgDevice == GT_FALSE */
    {
        /* GE port */
        laneNum = 1;
    }

    for( i = 0 ; i < laneNum ; i++ )
    {
        if ( prvCpssDrvHwPpWriteRegBitMask(devNum, regAddrPtr[i], mask, value) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllCalibrationSeq
*
* DESCRIPTION:
*       Perform the PLL calibration sequence which repeats in several places:
*       1. Turn SERDES PLL and Impedance calibration OFF
*       2. Turn SERDES PLL calibration ON
*       3. Turn SERDES Impedance calibration ON
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*       xgDevice                - GT_TRUE for XG device, GT_FALSE for GE device
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*       For GE devices the macro does nothing usefull since previouse one
*       (PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC) make all necessary checks.
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPllCalibrationSeq
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    IN GT_BOOL  xgDevice
)
{
    GT_U32  *regAddrPtr; /* pointer to register address */
    GT_U32  serdesNum;   /* SERDES number - for GE devices SERDES number is a */
                         /* actually also the port number, for XG devices it  */
                         /* is used like port number literaly */

    /* Turn SERDES PLL and Impedance calibration OFF */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesCalibConf1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x3, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Turn SERDES PLL calibration ON */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesCalibConf1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x3, 0x2) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Turn SERDES Impedance calibration ON */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesCalibConf1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x3, 0x3) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 2 ms */
    cpssOsTimerWkAfter(2);

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpCheckAllPortSyncOk
*
* DESCRIPTION:
*       Check if all ports are in sync OK state
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*       xgDevice                - GT_TRUE for XG device, GT_FALSE for GE device
*
* OUTPUTS:
*       syncOkPtr               - (pointer to) GT_TRUE: all port in sync OK,
*                                              GT_FALSE: at least one port not
*                                                        in sync OK
*
* RETURNS:
*       GT_OK       - on success
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*       For GE devices the macro does nothing usefull since previouse one
*       (PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC) make all necessary checks.
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpCheckAllPortSyncOk
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    IN GT_BOOL  xgDevice,
    OUT GT_BOOL *syncOkPtr
)
{
    GT_U32  regAddr;     /* register's address   */
    GT_U32  regValue;    /* register value       */
    GT_U32  serdesNum;   /* SERDES number - for GE devices SERDES number is a */
                         /* actually also the port number, for XG devices it  */
                         /* is used like port number literaly */
    GT_U32  lane;        /* lane number          */

    /* Check Port Sync Status */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        if( xgDevice == GT_TRUE )
        {
            for( lane = 0 ; lane < 4 ; lane++ )
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[serdesNum].laneStatus[lane];

                if (prvCpssDrvHwPpGetRegField(devNum, regAddr, 4, 1, &regValue) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }

                if( regValue == 0 )
                {
                    break;
                }
            }
            if( lane < 4 )
            {
                break;
            }
        }
       else
       {
           regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].macStatus;

           if (prvCpssDrvHwPpGetRegField(devNum, regAddr, 14, 1, &regValue) != GT_OK)
           {
               CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
           }

           if( regValue == 0 )
           {
               break;
           }
       }
    }

    if( serdesNum == PRV_CH3_NETWORK_SERDES_NUM_CNS )
    {
        /* all ports received SyncOk indication */
        *syncOkPtr = GT_TRUE;
    }
    else
    {
        /* at least one port did not receive SyncOk indication */
        *syncOkPtr = GT_FALSE;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllUnlockWorkaroundSave
*
* DESCRIPTION:
*       Save values for later restore after PLL unlock workaround.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*
* OUTPUTS:
*       speedPllPtr             - (pointer to) restore SERDES speed PLL values
*       ffePtr                  - (pointer to) restore SERDES FFE values
*       txPreEmphasisBmpPtr     - (pointer to) restore SERDES Tx Pre-emphasis values
*
* RETURNS:
*       GT_OK       - on success
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*       For GE devices the macro does nothing usefull since previouse one
*       (PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC) make all necessary checks.
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPllUnlockWorkaroundSave
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    OUT GT_U16   *speedPllPtr,
    OUT GT_U16   *ffePtr,
    OUT GT_U32   *txPreEmphasisBmpPtr
)
{
    GT_U32  regAddr;     /* register's address  */
    GT_U32  regData;     /* register data       */
    GT_U32  serdesNum;   /* SERDES number - for GE devices SERDES number is a */
                         /* actually also the port number, for XG devices it  */
                         /* is used like port number literaly */

    *txPreEmphasisBmpPtr = 0x0;

    /* For XG devices settings for all 4 lanes in the group must be same, */
    /* therefore we can save data from one of the group lanes for all.    */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        /* save SERDES Speed PLL value   */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesSpeed1[0];

        if (prvCpssDrvHwPpReadRegBitMask(devNum, regAddr, 0x7FF, &regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        speedPllPtr[serdesNum] = (GT_U16)regData;

        /* save SERDES FFE value */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesRxConfReg1[0];

        if (prvCpssDrvHwPpReadRegBitMask(devNum, regAddr, 0x3FF, &regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        ffePtr[serdesNum] = (GT_U16)regData;

        /* save SERDES Tx Pre-emphasis value */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesTxConfReg1[0];

        if (prvCpssDrvHwPpGetRegField(devNum, regAddr, 7, 1, &regData) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        *txPreEmphasisBmpPtr |= ((0x1 & regData) << serdesNum);
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllUnlockWorkaroundRestore
*
* DESCRIPTION:
*       Back to normal operation mode and restore previously saved values for
*       PLL unlock workaround.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*       xgDevice                - GT_TRUE for XG device, GT_FALSE for GE device
*       speedPllPtr             - (pointer to) restore SERDES speed PLL values
*       ffePtr                  - (pointer to) restore SERDES FFE values
*       txPreEmphasisBmp        - restore SERDES Tx Pre-emphasis values
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*       For GE devices the macro does nothing usefull since previouse one
*       (PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC) make all necessary checks.
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPllUnlockWorkaroundRestore
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    IN GT_BOOL  xgDevice,
    IN GT_U16   *speedPllPtr,
    IN GT_U16   *ffePtr,
    IN GT_U32   txPreEmphasisBmp
)
{
    GT_U32  regAddr;     /* register's address   */
    GT_U32  *regAddrPtr; /* pointer to register address */
    GT_U32  serdesNum;   /* SERDES number - for GE devices SERDES number is a */
                         /* actually also the port number, for XG devices it  */
                         /* is used like port number literaly */
    GT_U32  laneNum;     /* number of lanes per port */
    GT_U32  i;           /* loop index */

    if( xgDevice == GT_TRUE )
    {
        /* XG port */
        laneNum = 4;
    }
    else /* xgDevice == GT_FALSE */
    {
        /* GE port */
        laneNum = 1;
    }

    /* For XG devices settings for all 4 lanes in the group must be same, */
    /* therefore we can use data from one of the group lanes for all.     */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        /* restore SERDES Speed PLL value   */
        for( i = 0 ; i < laneNum ; i++ )
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesSpeed1[i];

            if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x400, (GT_U32)speedPllPtr[serdesNum]) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        /* restore SERDES FFE value, unset loopback */
        for( i = 0 ; i < laneNum ; i++ )
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesRxConfReg1[i];

            if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x3FF, (GT_U32)ffePtr[serdesNum]) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        /* restore SERDES Tx Pre-emphasis value */
        for( i = 0 ; i < laneNum ; i++ )
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesTxConfReg1[i];

            if (prvCpssDrvHwPpSetRegField(devNum, regAddr, 7, 1,
                                          ((txPreEmphasisBmp >> serdesNum) & 0x1)) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        /* Set Squelch Detector to control the CDR */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesDtlConfReg5[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x100, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        if( xgDevice == GT_TRUE )
        {
            /* Don't Bypass Signal Detect indication from the SERDES */
            regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                           macRegs.perPortRegs[serdesNum].laneConfig0[0]);

            if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                          regAddrPtr, 0x40, 0x0) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    /* wait 3 ms */
    cpssOsTimerWkAfter(3);

    if (prvCpssDxCh3HwPpPllCalibrationSeq(devNum, networkSerdesPowerUpBmp, xgDevice) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }


    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllUnlockWorkaround3rdWrapper
*
* DESCRIPTION:
*       3rd wrapper of workaround to eliminate the PLL unlocking issue for G ports.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPllUnlockWorkaround3rdWrapper
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp
)
{
    GT_U32  regAddr;     /* register's address  */
    GT_U32  serdesNum;   /* SERDES number       */

    /* Reset Rx & Digital*/
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFF0, 0xFF0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 5 ms */
    cpssOsTimerWkAfter(5);

    /* Unreset Digital */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFF0, 0xF00) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Unreset Rx */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFF0, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllUnlockWorkaround1stWrapper
*
* DESCRIPTION:
*       1st wrapper of workaround to eliminate the PLL unlocking issue for XG ports.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*       variableDelay           - delay used during the sequence the value
*                                 of which varies between diffrent runs.
*       speedPllPtr             - (pointer to) restore SERDES speed PLL values
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPllUnlockWorkaround1stWrapper
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    IN GT_U32   variableDelay,
    IN GT_U16   *speedPllPtr
)
{
    GT_U32  regAddr;     /* register's address   */
    GT_U32  *regAddrPtr; /* pointer to register address */
    GT_U32  serdesNum;   /* SERDES number - for XG devices it  */
                         /* is used like port number literaly  */
    GT_U32  lane;        /* lane loop index      */

    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        /* Set PLL to 1.25G mode */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesSpeed1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x7FF, 0x13A) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Change Icp */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesSpeed2[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0xF, 0xF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 3 ms */
    cpssOsTimerWkAfter(3);

    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        /* Reset XPCS */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].xgGlobalConfReg0;

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x1, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Reset Analog, Rx & Digital */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFFF, 0xFFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }


    /* Power down the Common current and voltage reference circuits power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesCommon[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x1, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Power down SERDES current and voltage reference circuits power control, */
    /* and PLL frequency synthesizer power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp1[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xF, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* Power down SERDES Rx and Tx power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp2[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xF, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Reset Rx Phase-Interpolator */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesRxConfReg1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x4000, 0x4000) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Unreset Rx Phase-Interpolator */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesRxConfReg1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x4000, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Power up the Common current and voltage reference circuits power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesCommon[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x1, 0x1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 4,8 or 40 ms */
    cpssOsTimerWkAfter(2*variableDelay);

    /* Power up SERDES current and voltage reference circuits power control, */
    /* and PLL frequency synthesizer power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp1[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFF, 0xFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* Power up SERDES Rx power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp2[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFF, 0xF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 2,4 or 20 ms */
    cpssOsTimerWkAfter(variableDelay);

    /* Unreset Analog */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFFF, 0xFF0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    if (prvCpssDxCh3HwPpPllCalibrationSeq(devNum, networkSerdesPowerUpBmp, GT_TRUE) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        /* Set PLL to 3.125G mode */
        for( lane = 0 ; lane < 4 ; lane++ )
        {
            /* For XG devices settings for all 4 lanes in the group must be same, */
            /* therefore we can use data from one of the group lanes for all.     */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesSpeed1[lane];

            if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x7FF, (GT_U32)speedPllPtr[serdesNum]) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        /* Change Icp */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesSpeed2[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0xF, 0x6) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 3 ms */
    cpssOsTimerWkAfter(3);

    /* Power up SERDES Tx power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp2[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFF, 0xFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Reset TxSyncFIFO */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesMiscConf[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x8, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Unreset Rx */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFFF, 0x0F0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    if (prvCpssDxCh3HwPpPllCalibrationSeq(devNum, networkSerdesPowerUpBmp, GT_TRUE) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    /* Unreset Digital */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesReset[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFFF, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Unreset TxSyncFIFO */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesMiscConf[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, GT_TRUE,
                                                      regAddrPtr, 0x8, 0x8) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Unreset XPCS */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].xgGlobalConfReg0;

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x1, 0x1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllUnlockWorkaroundWrapper
*
* DESCRIPTION:
*       Wrapper of workaround to eliminate the PLL unlocking issue.
*       The sequence of operations in this wrapper is used during:
*       1. 1st wrapper for GE ports.
*       2. 2nd wrapper for GE ports.
*       3. 2nd wrapper for XG ports.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*       xgDevice                - GT_TRUE for XG device, GT_FALSE for GE device
*       variableDelay           - delay used during the sequence the value
*                                 of which varies between diffrent runs.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*       For GE devices the macro does nothing usefull since previouse one
*       (PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC) make all necessary checks.
*
*******************************************************************************/
static GT_STATUS prvCpssDxCh3HwPpPllUnlockWorkaroundWrapper
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    IN GT_BOOL  xgDevice,
    IN GT_U32   variableDelay
)
{
    GT_U32  regAddr;     /* register address */
    GT_U32  *regAddrPtr; /* pointer to register address */
    GT_U32  serdesNum;   /* SERDES number - for GE devices SERDES number is a */
                         /* actually also the port number, for XG devices it  */
                         /* is used like port number literaly */

    /* Power down the Common current and voltage reference circuits power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesCommon[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x1, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Power down SERDES current and voltage reference circuits power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp1[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xF, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    /* Power up the Common current and voltage reference circuits power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[serdesNum].serdesCommon[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x1, 0x1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 4, 8 or 40 ms */
    cpssOsTimerWkAfter(2*variableDelay);

    /* Power up SERDES current and voltage reference circuits power control */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                    macRegs.perPortRegs[serdesNum].serdesPowerUp1[0];

        if (prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xF, 0xF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* wait 2, 4 or 20 ms */
    cpssOsTimerWkAfter(variableDelay);

    if (prvCpssDxCh3HwPpPllCalibrationSeq(devNum, networkSerdesPowerUpBmp, xgDevice) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxCh3HwPpPllUnlockWorkaround
*
* DESCRIPTION:
*       Workaround to eliminate the PLL unlocking issue.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum                  - device number
*       networkSerdesPowerUpBmp - bitmap of network SERDES to be power UP
*       xgDevice                - GT_TRUE for XG device, GT_FALSE for GE device
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*       PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC usage has actual influence
*       only for XG devices, where it is used to get the port number from
*       the power up SERDES bitmap (networkSerdesPowerUpBmp).
*       For GE devices the macro does nothing usefull since previouse one
*       (PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC) make all necessary checks.
*
*******************************************************************************/
GT_STATUS prvCpssDxCh3HwPpPllUnlockWorkaround
(
    IN GT_U8    devNum,
    IN GT_U32   networkSerdesPowerUpBmp,
    IN GT_BOOL  xgDevice
)
{
    GT_U32  *regAddrPtr; /* pointer to register address */
    GT_U32  regData;     /* register data */
    GT_U32  serdesNum;   /* SERDES number - for GE devices SERDES number is a */
                         /* actually also the port number, for XG devices it  */
                         /* is used like port number literaly */
    GT_U32  i, j;        /* loop iteration indexes */
    GT_U16  speedPll[PRV_CH3_NETWORK_SERDES_NUM_CNS];       /* array to save SERDES speed PLL */
    GT_U16  ffe[PRV_CH3_NETWORK_SERDES_NUM_CNS];            /* array to save SERDES FFE       */
    GT_U32  txPreEmphasisBmp;   /* bitmap to save SERDES Tx Pre-emphasis */
    GT_BOOL syncOk;             /* sync OK indication for all ports */
    GT_U32  variableDelay;      /* delay used during the sequence the value */
                                /* of which varies between diffrent runs.   */

    if( prvCpssDxCh3HwPpPllUnlockWorkaroundSave(devNum,
                                                networkSerdesPowerUpBmp,
                                                &speedPll[0],
                                                &ffe[0],
                                                &txPreEmphasisBmp) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    /* Set Serdes Analog Loopback Testing Mode */
    for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
    {
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

        /* Set loopback, Set FFE */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesRxConfReg1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x3FF, 0x7) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Disable Tx Pre-emphasis */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesTxConfReg1[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x80, 0x0) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        /* Unset Squelch Detector to control the CDR */
        regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                       macRegs.perPortRegs[serdesNum].serdesDtlConfReg5[0]);

        if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x100, 0x100) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        if( xgDevice == GT_TRUE )
        {
            /* Bypass Signal Detect indication from the SERDES */
            regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                           macRegs.perPortRegs[serdesNum].laneConfig0[0]);

           if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                      regAddrPtr, 0x40, 0x40) != GT_OK)
           {
               CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
           }
        }
    }

    /* wait 1 ms */
    cpssOsTimerWkAfter(1);

    for( i = 0 ; i < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_1ST_WRAPPER_CNS ; i++ )
    {
        if (prvCpssDxCh3HwPpCheckAllPortSyncOk(devNum,
                                               networkSerdesPowerUpBmp,
                                               xgDevice,
                                               &syncOk) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        if( syncOk == GT_TRUE )
        {
            /* all ports received SyncOk indication */
            break;
        }

        if( xgDevice == GT_TRUE )
        {
            if (prvCpssDxCh3HwPpPllUnlockWorkaround1stWrapper(devNum,
                                                              networkSerdesPowerUpBmp,
                                                              2, &speedPll[0]) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
        else
        {
            if (prvCpssDxCh3HwPpPllUnlockWorkaroundWrapper(devNum, networkSerdesPowerUpBmp,
                                                           xgDevice, 2) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    if( i < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_1ST_WRAPPER_CNS )
    {
        /* no PLL unlock problem occured or first wrapper solved the problem */
        return prvCpssDxCh3HwPpPllUnlockWorkaroundRestore(devNum,
                                                          networkSerdesPowerUpBmp,
                                                          xgDevice,
                                                          &speedPll[0],
                                                          &ffe[0],
                                                          txPreEmphasisBmp);
    }

    for( i = 0 ; i < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_SET_CHANGE_CNS ; i++ )
    {
        if( i < 5 )
        {
            variableDelay = 2;
        }
        else if ( i < 10)
        {
            variableDelay = 4;
        }
        else
        {
            variableDelay = 20;
        }

        if( xgDevice == GT_TRUE )
        {
            for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

                regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                               macRegs.perPortRegs[serdesNum].serdesSpeed1[0]);

                /* Set Speed PLL to 1.25G */
                if (prvCpssDxCh3HwPpPortSerdesWriteRegBitMask(devNum, xgDevice,
                                                              regAddrPtr, 0x400, 0x0) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
            }

            /* wait 3 ms */
            cpssOsTimerWkAfter(3);

            if (prvCpssDxCh3HwPpPllUnlockWorkaroundWrapper(devNum, networkSerdesPowerUpBmp,
                                                           xgDevice, 2) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
        else /* xgDevice == GT_FALSE */
        {
            for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);

                regAddrPtr = &(PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                               macRegs.perPortRegs[serdesNum].serdesSpeed1[0]);

                /* Toggle Speed PLL */
                if (prvCpssDrvHwPpReadRegBitMask(devNum, *regAddrPtr, 0x400, &regData) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }

                regData ^= 0x400;

                if (prvCpssDrvHwPpWriteRegBitMask(devNum, *regAddrPtr, 0x400, regData) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
            }

            /* wait 3 ms */
            cpssOsTimerWkAfter(3);
        }

        for( j = 0 ; j < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_2ND_WRAPPER_CNS ; j++ )
        {
            if( xgDevice == GT_TRUE )
            {
                if (prvCpssDxCh3HwPpPllUnlockWorkaround1stWrapper(devNum,
                                                                  networkSerdesPowerUpBmp,
                                                                  variableDelay, &speedPll[0]) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                if (prvCpssDxCh3HwPpPllUnlockWorkaroundWrapper(devNum, networkSerdesPowerUpBmp,
                                                               xgDevice, variableDelay) != GT_OK)
                {
                   CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
                }
            }

            if (prvCpssDxCh3HwPpCheckAllPortSyncOk(devNum,
                                                   networkSerdesPowerUpBmp,
                                                   xgDevice,
                                                   &syncOk) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            if( syncOk == GT_TRUE )
            {
                /* all ports received SyncOk indication */
                break;
            }
        }

        if( j < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_2ND_WRAPPER_CNS )
        {
            /* all ports received SyncOk indication */
            break;
        }
    }

    if( i < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_SET_CHANGE_CNS )
    {
        /* second wrapper solved the PLL unlock problem */
        return prvCpssDxCh3HwPpPllUnlockWorkaroundRestore(devNum,
                                                          networkSerdesPowerUpBmp,
                                                          xgDevice,
                                                          &speedPll[0],
                                                          &ffe[0],
                                                          txPreEmphasisBmp);
    }


    if( xgDevice == GT_FALSE )
    {
        /* restore SERDES Speed PLL value   */
        for( serdesNum = 0 ; serdesNum < PRV_CH3_NETWORK_SERDES_NUM_CNS ; serdesNum++ )
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesPowerUpBmp);
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, serdesNum);

            regAddrPtr = &PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                            macRegs.perPortRegs[serdesNum].serdesSpeed1[0];

            if (prvCpssDrvHwPpWriteRegBitMask(devNum, *regAddrPtr,
                                              0x400, (GT_U32)speedPll[serdesNum]) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        for( i = 0 ; i < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_3RD_WRAPPER_CNS ; i++)
        {
            if (prvCpssDxCh3HwPpPllUnlockWorkaround3rdWrapper(devNum,
                                                              networkSerdesPowerUpBmp) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            if (prvCpssDxCh3HwPpCheckAllPortSyncOk(devNum,
                                                   networkSerdesPowerUpBmp,
                                                   xgDevice,
                                                   &syncOk) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            if( syncOk == GT_TRUE )
            {
                /* all ports received SyncOk indication */
                break;
            }
        }

        if( i < PLL_UNLOCK_WORKAROUND_MAX_LOOPS_3RD_WRAPPER_CNS )
        {
            /* third wrapper solved the PLL unlock problem */
            return prvCpssDxCh3HwPpPllUnlockWorkaroundRestore(devNum,
                                                          networkSerdesPowerUpBmp,
                                                          xgDevice,
                                                          &speedPll[0],
                                                          &ffe[0],
                                                          txPreEmphasisBmp);
        }
    }

    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
}

/*******************************************************************************
* hwPpCheetah3RegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Cheetah registers
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpCheetah3RegsDefault
(
    IN GT_U8                                       devNum,
    IN CPSS_DXCH_PP_PHASE1_INIT_INFO_STC           *ppPhase1ParamsPtr
)
{
    GT_U32 regAddr;     /* register's address */
    GT_U32 devType;     /* device type          */
    GT_BOOL ch3XgDevice; /* XG Cheetah 3 family */
    GT_STATUS rc;       /* return code */
    GT_U32    replacedRow; /* row number replaced in the eFuse WA */
    GT_U32    xValid;      /* X value to invalidate row */
    GT_U32    yValid;      /* Y value to invalidate row */
    GT_U32    networkSerdesPowerUpBmp;  /* bitmap of network SERDES to be power UP */
    GT_U32    i;           /* loop counter */

    /* start with the common settings */
    rc =  hwPpCheetahCommonRegsDefault(devNum);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* CPSS_98DX8110_CNS for CH3 XG device, else CH3 G device */
    devType = PRV_CPSS_PP_MAC(devNum)->devType;
    switch(devType)
    {
        case PRV_CPSS_CHEETAH3_XG_PORTS_DEVICES_CASES_MAC:
            ch3XgDevice = GT_TRUE;
            break;
        default:
            ch3XgDevice = GT_FALSE;
            break;
    }

    if(GT_TRUE ==
        PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            /* Disable dropping ARP packets with MAC SA not equal to the ARP
               payload data contains a field called <source hardware address> */
           rc = cpssDxChNstProtSanityCheckSet(devNum,
                    CPSS_NST_CHECK_ARP_MAC_SA_MISMATCH_E,
                    GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*
                NOTE: this is anyway 'default' of the device
            */

            /* Disable all TCP Sanity checks */
           rc = cpssDxChNstProtSanityCheckSet(devNum,
                    CPSS_NST_CHECK_TCP_ALL_E,
                    GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* Reset NST( Network Shield ) registers  -
               Bridge Global Configuration Registers */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                         bridgeRegs.bridgeGlobalConfigRegArray[0];

            /* Disable dropping ARP packets with MAC SA not equal to the ARP
               payload data contains a field called <source hardware address>
               + all TCP Sanity checks */
            if(prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x20030000, 0x0) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                         bridgeRegs.bridgeGlobalConfigRegArray[2];
            /* Disable all TCP related bits(0-4) + disable ICMP dropping(bit 5) */
            if(prvCpssDrvHwPpWriteRegBitMask(devNum,regAddr,0x0000003F, 0x0)
                != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    /* Enable tagged packets transmitted from the device have their CFI bit set
     according to the received packet CFI bit if the received packet was tagged,
     or set to 0 if the received packet is untagged.*/
    rc = cpssDxChBrgGenCfiRelayEnableSet(devNum,GT_TRUE);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* RM#2003 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E))
    {
        /* Buffer Management GbE Ports Group Limits Configuration Registers */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.bufMngGigaPortGroupLimit,
                0xBFEFFDFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Buffer Management HyperG.Stack Ports Group Limits Configuration Registers */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.bufMngHyperGStackPortGroupLimit,
                0xBFEFFDFF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2007 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E))
    {
        /* LMS GigE Ports Mode Register1 */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms1GigPortsModeReg1[1],
                0x00000000) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2008 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E))
    {
        /* LMS HyperG.Stack Ports Mode Register */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0GigPortsModeReg1[1], 0x000000FF) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2024 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E))
    {
        /* LED Interface0 Control Register 1 and Class6 Manipulation Register (for ports 0 through 11) */
        /* <LEDClkInvert> */
        if (prvCpssDrvHwPpSetRegField(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ledRegs.ledClass[0][6], 16, 1, 1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* LED Interface1 Control Register1 and class6 manipulation (for ports 12 through 23) */
        /* <LEDClkInvert> */
        if (prvCpssDrvHwPpSetRegField(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ledRegs.ledClass[1][6], 16, 1, 1) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }
    /* RM#2011 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_TCAM_PLL_REG_WA_E))
    {
        /* Stop TCAM PLL */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.mppmPllConfig.mppmPllParams,
                0x00258D24) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Stop MPPM PLL (internal reg.) */
        if (prvCpssDrvHwPpWriteRegister(devNum, 0x000000B8, 0x00258D24) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Configure PLL clocks to use register values */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl,
                0x0000051D) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Keep MPPM PLL stoped & Start configuration to 250MHz */
        if (prvCpssDrvHwPpWriteRegister(devNum, 0x000000B8, 0x60258D24) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Configure TCAM and MPPM PLL to the 250 MHz clock */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.mppmPllConfig.mppmPllCtrl,
                0x18E8743A) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Start TCAM PLL */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.mppmPllConfig.mppmPllParams,
                0x08258D24) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
        /* Start MPPM PLL */
        if (prvCpssDrvHwPpWriteRegister(devNum, 0x000000B8, 0x68258D24) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

    }

    /* RM#2026 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E))
    {
        /* Change the default value of MAC2ME Registers Low register */
        for(i = 0; i < 8; i++)
        {
            if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.macToMe[i].macLow,
                0x0000FFF0) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    /* RM#2061 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_RM_AN_CNF_REG_WA_E))
    {
        /* Change the default value of PHY Auto-Negotiation Configuration Register0 and PHY Auto-
           Negotiation Configuration Register2 */
        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0PhyAutoNeg[0],
                0x00000140) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        if (prvCpssDrvHwPpWriteRegister(devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms1PhyAutoNeg[0],
                0x00000140) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    /* FEr#2191 */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_TCAM_EFUSE_NOT_TRIGGERED_AUTO_WA_E))
    {
        /* WA for Policy TCAM */
        rc = prvCpssDxCh3TcamEfuseWa(devNum,
                                     PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.policyTcamTest.pointerRelReg,
                                     14,
                                     PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.policyTcamTest.configStatusReg,
                                     &replacedRow);

        if ( rc != GT_OK )
        {
            return rc;
        }

        if( replacedRow != NO_TCAM_ROW_TO_REPLACE_CNS )
        {
            /* any "valid bit" value in the key not will be matched */
            xValid = PRV_CPSS_DXCH_PCL_MP_TO_X_MAC(0, 1);
            yValid = PRV_CPSS_DXCH_PCL_MP_TO_Y_MAC(0, 1);

            for( i = 0; i < 4 ; i++)
            {
                /* invalidate standard part of row */
                rc = prvCpssDxChPclTcamStdRuleValidStateXandYSet(
                    devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                    (replacedRow + (i * PRV_DXCH3_PCL_TCAM_RAW_NUMBER_CNS)),
                    xValid, yValid);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        /* WA for Router TCAM */
        rc = prvCpssDxCh3TcamEfuseWa(devNum,
                                     PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerTcamTest.pointerRelReg,
                                     14,
                                     PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerTcamTest.configStatusReg,
                                     &replacedRow);

        if ( rc != GT_OK )
        {
            return rc;
        }

        if( replacedRow != NO_TCAM_ROW_TO_REPLACE_CNS )
        {
            rc = prvCpssDxChRouterTunnelTermTcamInvalidateLine(
                devNum,CPSS_PORT_GROUP_UNAWARE_MODE_CNS, replacedRow);

            if ( rc != GT_OK )
            {
                return rc;
            }
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH3_TCAM_REPAIR_WA_E))
    {
        rc = prvCpssDxCh3TcamWa(devNum);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(ch3XgDevice == GT_TRUE)
    {
        /* RM#2063 */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_BM_TX_FIFO_THRESHOLD_CONF_REG_WA_E))
        {
            /* RM#2063 : Buffer Memory Tx Fifo Threshold and MPPM Access Arbiter Configuration Register */
            /* Update number of lines for NP in the Tx FIFO (bits 0-3, from 0x6 to 0xC) */
            if (prvCpssDrvHwPpWriteRegister(devNum,
                    PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.buffMemTxFifoThreshMPPMAccessArb,
                    0x444E610C) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E))
    {
        /* WA for: Under heavy traffic stress, FDB accesses from the CPU can get stuck */
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_FDB_MAC(devNum).FDBCore.FDBGlobalConfig.FDBGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.macControlReg;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        if (hwPpCheetah3PortsAndSerdesRegsDefault(devNum, ppPhase1ParamsPtr,
                                                  &networkSerdesPowerUpBmp) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }

        if (prvCpssDxCh3HwPpPllUnlockWorkaround(devNum,
                                                networkSerdesPowerUpBmp,
                                                ch3XgDevice) != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH3_TOGGLE_DEV_EN_UNDER_TRAFFIC_WA_E))
    {
        /* Toggling Device Enable under traffic may cause system hang. */
        /* (FEr#2261) */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 8, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E))
    {
        CPSS_DXCH_CFG_GLOBAL_EPORT_STC        ecmpEportCfg;
        CPSS_DXCH_CFG_GLOBAL_EPORT_STC        globalEportCfg;

        /* L2i : Default for the couple <Global Eport Range Value> and <Global
                 ePort Range Mask> should be 'never match' */
        globalEportCfg.enable = GT_FALSE;
        ecmpEportCfg.enable = GT_FALSE;
        rc = cpssDxChCfgGlobalEportSet(devNum,&globalEportCfg,&ecmpEportCfg);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    return GT_OK;
}

/*******************************************************************************
* hwPpXcatA1PortsAndSerdesRegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Xcat ports and SERDES registers
*
* APPLICABLE DEVICES:
*        xCat; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat3; Lion; Lion2.
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpXcatA1PortsAndSerdesRegsDefault
(
    IN GT_U8                                   devNum,
    IN CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr

)
{
    GT_U32 regAddr;     /* register's address   */
    GT_U32 regValue;    /* register value       */
    GT_PHYSICAL_PORT_NUM portNum;     /* port number          */
    GT_U32 devType;     /* device type          */
    GT_BOOL xcatGigDevice;
    GT_U32 serdesNum;   /* SERDES number        */
    GT_U32 networkSerdesBmp;   /* device SERDES bitmap */
    GT_STATUS rc;
    GT_U32 i;
    GT_U32 startSeredesIndx;
    GT_U32 xgMode;
    GT_BOOL xcat2Dev = GT_FALSE;
    PRV_CPSS_DXCH_PORT_SERDES_POWER_UP_ARRAY *lpSerdesConfigArrPtr;
    CPSS_DXCH_PORT_SERDES_SPEED_ENT serdesSpeed;
    CPSS_PORT_INTERFACE_MODE_ENT   ifMode;

    /* define type of xCat device either Gig or Fast */
    devType = PRV_CPSS_PP_MAC(devNum)->devType;
    switch(devType)
    {
        case PRV_CPSS_DXCH_XCAT_FE_DEVICES_CASES_MAC:
        case PRV_CPSS_DXCH_XCAT2_FE_DEVICES_CASES_MAC:
            xcatGigDevice = GT_FALSE;
            startSeredesIndx = PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS;
            break;
        default:
            xcatGigDevice = GT_TRUE;
            startSeredesIndx = 0;
            break;
    }
    /* Set device SERDES bitmap */
    prvCpssDxXcatNetworkSerdesBitmapGet(devNum,
                                       &ppPhase1ParamsPtr->powerDownPortsBmp,
                                       &networkSerdesBmp);

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
        xcat2Dev = GT_TRUE;

    /* set Serdes reference clock */
    switch(ppPhase1ParamsPtr->serdesRefClock)
    {
    case CPSS_DXCH_PP_SERDES_REF_CLOCK_INTERNAL_125_E:
        /* set device_cnfg register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sampledAtResetReg;
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,24,2,2);
        if (rc != GT_OK)
            return rc;
        break;
    case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_125_SINGLE_ENDED_E:

        if(GT_TRUE == xcat2Dev)
        {

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sampledAtResetReg;
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,30,1,0);
            if (rc != GT_OK)
                return rc;

            /* disable PECL receiver */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.analogCfgReg;
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,5,1,0);
            if (rc != GT_OK)
                return rc;
        }
        else
        {
            /* set device_cnfg register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sampledAtResetReg;
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,24,2,1);
            if (rc != GT_OK)
                return rc;
        }

        /* set single ended clock input in analog_cnfg register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.analogCfgReg;
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,9,1,0);
        if (rc != GT_OK)
            return rc;

        break;
    case CPSS_DXCH_PP_SERDES_REF_CLOCK_EXTERNAL_125_DIFF_E:
        /* set device_cnfg register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sampledAtResetReg;
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,24,2,1);
        if (rc != GT_OK)
            return rc;

        /* set differential clock input in analog_cnfg register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.analogCfgReg;
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,9,1,1);
        if (rc != GT_OK)
            return rc;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (systemRecoveryInfo.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
    {
        /* check if cpss makes serdes default initialization */
        if (ppPhase1ParamsPtr->initSerdesDefaults == GT_TRUE)
        {
            /* get flexLink ports mode */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sampledAtResetReg;
            if (prvCpssDrvHwPpGetRegField(devNum,regAddr,26,4,&xgMode) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            if(GT_TRUE == xcat2Dev)
            {
                serdesNum = PRV_CPSS_XCAT2_SERDES_NUM_CNS;
                lpSerdesConfigArrPtr = xcat2SerdesPowerUpSequence;
            }
            else
            {
                serdesNum = PRV_CPSS_XCAT_SERDES_NUM_CNS;
                lpSerdesConfigArrPtr = (PRV_CPSS_PP_MAC(devNum)->revision > 2)
                            ? xcatSerdesPowerUpSequence : xcatA1SerdesPowerUpSequence;
            }

            /* set default values to all serdes */
            for (i=startSeredesIndx;i<serdesNum;i++)
            {
                if(i < PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS)
                {
                    portNum = (i<<2);
                }
                else
                {
                    if(xcat2Dev != GT_TRUE)
                        portNum = 24+((i-PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS)>>2);
                    else
                        portNum = 24+(i-PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS);
                }

                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
                /* check if all serdes in port are initialized and make proper initialization
                   if it is needed */
                rc = prvCpssDxChLpCheckAndInitNeededSerdes(devNum,CPSS_PORT_GROUP_UNAWARE_MODE_CNS,i,1);
                if (rc != GT_OK)
                {
                    return rc;
                }

                if((i >= PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS) && (GT_TRUE == xcat2Dev))
                {
                    serdesSpeed = ((xgMode >> (i - PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS)) & 0x1)
                                    ? CPSS_DXCH_PORT_SERDES_SPEED_3_125_E : CPSS_DXCH_PORT_SERDES_SPEED_1_25_E;
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[i].transmitterReg2;
                    rc = prvCpssDrvHwPpWriteRegister(devNum,regAddr,lpSerdesConfigArrPtr
                                                                    [PRV_CPSS_DXCH_PORT_SERDES_TRANSMIT_REG2_INDEX_E]
                                                                    [serdesSpeed]);
                    if (rc != GT_OK)
                        return rc;
                }
            }

            if(xcatGigDevice == GT_TRUE)
            {
                for( serdesNum = 0 ; serdesNum < PRV_CPSS_XCAT_NETWORK_PORTS_SERDES_NUM_CNS ; serdesNum ++ )
                {
                    PRV_CPSS_DXCH_SKIP_NOT_EXIST_SERDES_MAC(serdesNum, networkSerdesBmp);
                    rc = cpssDxChPortSerdesPowerStatusSet(devNum,(GT_U8)(serdesNum*4),CPSS_PORT_DIRECTION_BOTH_E,0Xff,GT_TRUE);
                    if (rc!= GT_OK)
                    {
                        return rc;
                    }

                    if((GT_TRUE == xcat2Dev) && (xcatGigDevice == GT_TRUE))
                    {
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdesNum].transmitterReg1;
                        rc = prvCpssDrvHwPpWriteRegister(devNum,regAddr, /* 0x750C */
                                lpSerdesConfigArrPtr[PRV_CPSS_DXCH_PORT_SERDES_TRANSMIT_REG1_INDEX_E]
                                                    [CPSS_DXCH_PORT_SERDES_SPEED_5_E]);
                        if (rc != GT_OK)
                            return rc;

                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdesNum].transmitterReg2;
                        rc = prvCpssDrvHwPpWriteRegister(devNum,regAddr, /* 0x0 */
                                lpSerdesConfigArrPtr[PRV_CPSS_DXCH_PORT_SERDES_TRANSMIT_REG2_INDEX_E]
                                                    [CPSS_DXCH_PORT_SERDES_SPEED_5_E]);
                        if (rc != GT_OK)
                            return rc;

                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdesNum].ffeReg;
    /* TBD: here must be lpSerdesConfigArr[PRV_CPSS_DXCH_PORT_SERDES_FFE_REG0_E][CPSS_DXCH_PORT_SERDES_SPEED_5_E]
     * but final value not calibrated yet, so let it for now be hardcoded */
                        rc = prvCpssDrvHwPpWriteRegister(devNum,regAddr, 0x363);
                        if (rc != GT_OK)
                            return rc;
                    }
                }

            } /* if (xcatGigDevice == GT_TRUE) */
        }
        else
        {
            for (portNum = 0 ; (portNum < PRV_CPSS_PP_MAC(devNum)->numOfPorts); portNum++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
                if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_TRUE)
                {
                    rc = cpssDxChPortInterfaceModeGet(devNum, portNum, &ifMode);
                    if(rc != GT_OK)
                    {
                        continue;
                    }
                    if(ifMode != CPSS_PORT_INTERFACE_MODE_NA_E)
                    {
                        /* Set port type */
                        prvCpssDxChPortTypeSet(devNum,portNum,ifMode,CPSS_PORT_SPEED_NA_E);

                        /* update addresses of mac registers accordingly to used MAC 1G/XG/XLG */
                        rc = prvCpssDxChHwRegAddrPortMacUpdate(devNum, portNum, ifMode);

                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                    }

                }

            }
        }
        if (xcatGigDevice == GT_TRUE)
        {
            regValue = (xcat2Dev) ? 0xC009 : 0xC008;
        }
        else
        {
            /* disable GPCS */
            regValue = 0xC000;
        }

        /* NP Port De-Assert MAC reset */
        for (portNum = 0 ; portNum < 24 ; portNum++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
            PRV_CPSS_DXCH_PORT_MAC_CTRL2_REG_MAC(devNum,portNum,PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,portNum),&regAddr);

            /* De-Assert MAC_Reset */
            if (prvCpssDrvHwPpWriteRegister(devNum, regAddr, regValue) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }

        if(GT_TRUE == xcat2Dev)
        {
            for (portNum = 24 ; portNum <= 27 ; portNum++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);
                if((rc = cpssDxChPortInbandAutoNegEnableSet(devNum,portNum,GT_TRUE)) != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    return GT_OK;
}
/*******************************************************************************
* hwPpDxChXcatRegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for xCat registers
*
* APPLICABLE DEVICES:
*        xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3.
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - (pointer to) Packet processor hardware specific
*                            parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpDxChXcatRegsDefault
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC    *ppPhase1ParamsPtr
)
{
    GT_U32      i;          /* iterator */
    GT_STATUS   rc;         /* return code */
    GT_U32      port;       /* iterator over ports */
    GT_U32      regAddr;    /* register address */
    GT_U32      devType;    /* device type          */
    GT_U32      fieldOffset;/* offset of field in register */

    /* start with the same ch3 settings */
    rc =  hwPpCheetah3RegsDefault(devNum, ppPhase1ParamsPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E) ||
       (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
    {
        /* do xcat specific settings */
        rc = hwPpXcatA1PortsAndSerdesRegsDefault(devNum, ppPhase1ParamsPtr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TXQ_EXT_CNTR_REG_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
            {
                regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).shaper.tokenBucketUpdateRate;
                fieldOffset = 29;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.dq.shaper.tokenBucketUpdateRate;
                fieldOffset = 30;
            }
            rc = prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* Wrong default value of bit#28 of Transmit Queue Extended Control
               register. The bit should be set by default. */
            rc = prvCpssDrvHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueConfigExt,
                28, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /*********************/
    /* xcat and above */
    /*********************/

    for (i = 0; i <= CPSS_DXCH_POLICER_STAGE_EGRESS_E; i++)
    {
        /*(part of RM#3012)*/

        if( i != CPSS_DXCH_POLICER_STAGE_EGRESS_E )/* not for egress policer */
        {
            /*
                1. Set Qos model to be Qos Profile in Policer Control0 reg.
                2. Enable QosProfile update for IP packets in Policer Control1 reg.
                   (for Policer Ingress #0 and Policer Ingress #1
            */
            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL0_WA_E))
            {
                if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,i).policerCtrl0;
                }
                else
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                                PLR[i].policerControlReg;
                }

                rc = prvCpssDrvHwPpSetRegField(
                    devNum,
                    regAddr,
                    21, 1, 1);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH_XCAT_RM_INGRESS_POLICER_CONTROL1_WA_E))
            {
                if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
                {
                    regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum,i).policerCtrl1;
                }
                else
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                                PLR[i].policerControl1Reg;
                }

                rc = prvCpssDrvHwPpSetRegField(
                    devNum,
                    regAddr,
                    0, 1, 1);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        /* skip not supported IPLR0 */
        if ((CPSS_DXCH_POLICER_STAGE_INGRESS_0_E == i) &&
            (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.policersNum == 0))
        {
            continue;
        }

        /* skip not supported IPLR1 */
        if ((CPSS_DXCH_POLICER_STAGE_INGRESS_1_E == i) &&
            (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.featureInfo.iplrSecondStageSupported == GT_FALSE))
        {
            continue;
        }

        /* skip not supported EPLR */
        if ((CPSS_DXCH_POLICER_STAGE_EGRESS_E == i) &&
            (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.egressPolicersNum == 0))
        {
            continue;
        }

        /* for all policers configure Flow mode */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                PRV_CPSS_DXCH_XCAT_RM_POLICER_CONTROL2_WA_E))
        {
            rc = cpssDxChPolicerStageMeterModeSet(
                    devNum, i, CPSS_DXCH_POLICER_STAGE_METER_MODE_FLOW_E);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        /* RM#3026 - for all policers*/
        /* The default value of the <Counting Entry Format Select> field, bit[4] */
        /* in Policer Control1 register (EPLR: 0x03800004, IPLR0: 0x0C800004,    */
        /* IPLR1: 0x0D000004) is incorrect.                                      */
        /* Change the value to "Compressed format" (0x1).                        */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                PRV_CPSS_DXCH_XCAT2_RM_POLICER_COUNT_FORMAT_WA_E))
        {
            rc = prvCpssDrvHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.PLR[i].policerControl1Reg,
                4, 1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_XCAT_RM_MIRROR_INTERFACE_PARAMETER_REGISTER_I_WA_E))
    {
        /*(part of RM#3012)*/

        /* Enable Mirror on Drop */
        for(i = 0; i < 7; i++)
        {
            rc = cpssDxChMirrorAnalyzerMirrorOnDropEnableSet(devNum,i,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TOTAL_BUFFER_LIMIT_CONF_IN_TXQ_E))
        {
            /* TxQ Total Buffer Limit */
            rc = prvCpssDrvHwPpWriteRegister(devNum,
                                            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                            egrTxQConf.totalBufferLimitConfig,
                                            0x00001800);
            if (rc != GT_OK)
            {
                return rc;
            }
        }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_CNC_ENABLE_COUNTING_E))
    {
        /*(part of RM#3012)*/
        /* PCL Counting Mode Configuration register,
           field Enable Counting */
        /*enable CNC for IPCL */
        rc = cpssDxChCncCountingEnableSet(devNum,CPSS_DXCH_CNC_COUNTING_ENABLE_UNIT_PCL_E,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TTI_UNIT_GLOBAL_CONFIGURATION_WA_E))
    {
        /*(part of RM#3012)*/
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIUnitGlobalConfigs.TTIUnitGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig;
        }

        /* TTI Unit Global Configuration register,
           field disable CCFC */
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,19, 1, 0);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* TTI Unit Global Configuration register,
           field Enable Counting */
        rc = cpssDxChCncCountingEnableSet(devNum,CPSS_DXCH_CNC_COUNTING_ENABLE_UNIT_TTI_E,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_POLICY_ENGINE_CONFIGURATION_REGISTER_WA_E))
    {
        /*(part of RM#3012)*/
        /* Enable full lookup for Ingress PCL lookup0 sublookup1 */
        rc = cpssDxChPclPortIngressLookup0Sublookup1TypeSet(devNum,
            CPSS_DXCH_PCL_IPCL01_LOOKUP_TYPE_FULL_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_EGRESS_POLICER_GLOBAL_CONFIGURATION_WA_E))
    {
        /*(part of RM#3012)*/

        /* Enable Egress Policer and set ERLR counting mode to be
           Billing/IP FIX */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.eplrGlobalConfig,
            0, 3, 3);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TXQ_DEQUEUE_SWRR_WEIGHT_REGISTER_3_WA_E))
    {
        /* fields of XG and Gig1 weights are swapped */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.dequeueSWRRWeightReg3,
            0, 9, 0x4b);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_WA_E))
    {
        /*(part of RM#3012)*/

        /* BCN Aware Packet Type */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.bcnControlReg,
            1, 1, 0);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* En MC BCN Aware */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.bcnControlReg,
            3, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_PORTS_BCN_AWARENESS_TABLE_WA_E))
    {
        /*(part of RM#3012)*/

        /* BCN Awareness Entry */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.portsBcnAwarenessTbl,
            0, 28, 0x0FFFFFFF);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E))
    {
        if(PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum) ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
        {
            rc = prvCpssDrvHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bcnRegs.bcnControlReg,
                15, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E))
    {
        if((PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum) &&
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)) ||
           (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
        {
            rc = prvCpssDrvHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.metalFix,
                21, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E))
    {/* prevent PCS from losing one of 8 packet preamble bytes */
        for( port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            if(PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum) &&
               (CPSS_PP_FAMILY_DXCH_XCAT_E == PRV_CPSS_PP_MAC(devNum)->devFamily))
            {
                PRV_CPSS_DXCH_PORT_MAC_CTRL3_REG_MAC(devNum, port,
                                                    PRV_CPSS_PORT_GE_E, &regAddr);
                fieldOffset = 15;
            }
            else if(CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)
            {
                PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, port,
                                                    PRV_CPSS_PORT_GE_E, &regAddr);
                fieldOffset = 2;
            }
            else if(CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily)
            {
                PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, port,
                                                    PRV_CPSS_PORT_GE_E, &regAddr);
                fieldOffset = 1;
            }
            else
            {
                break;
            }

            rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, fieldOffset, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E))
    {
        for( port = 0; port <= PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            if(port == PRV_CPSS_PP_MAC(devNum)->numOfPorts)
            {
                port = CPSS_CPU_PORT_NUM_CNS; /* CPU port */
            }
            else
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);
            }

            PRV_CPSS_DXCH_PORT_SERIAL_PARAM_CTRL_REG_MAC(devNum,port,&regAddr);

            rc = prvCpssDrvHwPpSetRegField(
                devNum,regAddr, 1, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_LMS0_LMS1_MISC_CONFIGURATIONS_WA_E))
    {
        GT_U32  lmsAddr[2];

        lmsAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0MiscConfig;
        lmsAddr[1] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms1MiscConfig;

        for(i = 0 ; i < 2 ; i++)
        {
            rc = prvCpssDrvHwPpWriteRegBitMask(
                devNum,
                lmsAddr[i],
                0x118000,
                0x010000);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E))
    {
        rc = prvCpssDrvHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix, 17, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_GIGA_PORT_PRBS_PARAM_INIT_WA_E))
    {
        /* FEr#3054: Gig port PRBS is not functional. */
        /* XCAT A2 and above, initial PRBS parameters */
        for (port = 24 ; port < 28 ; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                        perPortRegs[port].serialParameters;

            /* set PBRS parameters */
            if (prvCpssDrvHwPpSetRegField(
                devNum, regAddr, 14 /*offset*/, 2/*length*/, 3/*value*/)
                != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_HEADER_ALTERATION_GLOBAL_CONFIGURATION_REGISTER_WA_E))
    {
        /* Set the < Enable Passenger Vlan Translation For TS > field, bit[10] in the Header Alteration Global Configuration
            register (offset: 0x0E800100) to 0x0 (disable). */
        rc = cpssDxChTunnelStartPassengerVlanTranslationEnableSet(devNum,GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_ETH_OVER_IPV4_GRE_WA_E)) &&
       (GT_TRUE == PRV_CPSS_DXCH_XCAT_A3_ONLY_CHECK_MAC(devNum)))
    {
        /* Enable HA fix - tunneling support for Eth-over-IPv4 */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig,
            15, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_INT_EXT_REF_CLK_WA_E))
    {
        switch(PRV_CPSS_PP_MAC(devNum)->devType)
        {
            case PRV_CPSS_DXCH_XCAT2_GE_DEVICES_CASES_MAC:
            /* The default value of bit[30] (<int_ext_ref_clk_125> field) in the    */
            /* Device_Cfg register (0x28) is incorrect.                             */
            /* Change the value to 0x0 (input_pin).                                 */
            /* RM#3027 */
                rc = prvCpssDrvHwPpSetRegField(devNum,
                        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sampledAtResetReg,
                        30, 1, 0);
                if(rc != GT_OK)
                {
                    return rc;
                }
                break;
            default: break;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_INCORRECT_XG_SHAPER_TOKEN_BUCKET_WA_E))
    {
        /* Ports 24-27 shaping rate defaults are different than that of the ports */
        /* 0-23.                                                                  */
        /* To enable the ports 24-27 to support shaping rates identical to ports  */
        /* 0-23, set the <XgPortsTbAsGig> field, bit[31] in the Token Bucket      */
        /* Update Rate and MC FIFO Configuration Register (0x0180000C) to         */
        /* "Gig mode" (0x1).                                                      */
        /* (RM#3030)                                                              */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQMcFifoEccConfig,
            31, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_BYPASS_PACKET_REFRESH_FDB_AGE_WA_E))
    {
        /* Packets that bypass the Ingress Pipe perform a refresh of the age bit   */
        /* in the FDB.                                                             */
        /* Set the value of the <Avoid_Age_Refresh> field, bit[22] in the Bridge   */
        /* Global Configuration2, to 0x1 (enable), so that packets that bypass the */
        /* Ingress Pipe will not perform refresh of the age bit in the FDB.        */
        /* (RM#3031)                                                               */
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            /*<Avoid_Age_Refresh>*/
            regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).
                        bridgeEngineConfig.bridgeGlobalConfig1;
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,
                9, 1, 1);
        }
        else
        {
            rc = prvCpssDrvHwPpSetRegField(
                devNum,
                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                bridgeRegs.bridgeGlobalConfigRegArray[2],
                22, 1, 1);
        }
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_PIPE_SELECT_WA_E))
    {
        /* Wrong default in Pipe Select register and some new DFX settings. */
        /* (RM#3032)                                                        */
        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.pipeSelect,
             0x00000001);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                dfxUnits.ingressLower.tcBist.tcamBistConfigStatus,
             0x00020003);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                dfxUnits.ingressUpper.tcBist.tcamBistConfigStatus,
             0x00020003);
        if(GT_OK != rc)
        {
            return rc;
        }
        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.gppPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.ssmiiPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.rgmiiPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpWriteRegister(
             devNum,
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.ledPadControl,
             0x00000048);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    /* When rate limit is enabled on the FlexLink ports causes all packets
    to be dropped. (RM#3038)*/
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_FLEX_LINK_PORTS_RATE_LIMIT_WA_E))
    {
        for( port = 24; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

            /* Configure 1Gbps port speed  */
            rc = cpssDxChBrgGenPortRateLimitSpeedGranularitySet(devNum, port,
                                                        CPSS_PORT_SPEED_1000_E);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }
    /* Wrong non-initial UDP fragments packets trap to CPU.*/
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_PTP_UDP_FRAGMENT_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix;

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 17, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_SSMII_PAD_ZNR_ZPR_WA_E))
    {
        /* get type of xCat device either Gig or Fast */
        devType = PRV_CPSS_PP_MAC(devNum)->devType;
        switch(devType)
        {
            case PRV_CPSS_DXCH_XCAT_FE_DEVICES_CASES_MAC:
                /* Pad_Control_1 */
                rc = prvCpssDrvHwPpSetRegField(devNum,
                                               PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                               globalRegs.padsControl.padControl1,
                                               14, 6, 0x1B);
                if (rc != GT_OK)
                {
                    return rc;
                }
                break;
            default:
                break;
        }
    }

    if((GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_PASSENGER_TPID_REG_WA_E)) &&
       (GT_TRUE == PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC(devNum)))
    {
        /* NOTE: (xcat-C0/Xcat3) we can set regardless to 'vpls enabled'
            because it suppose to be the HW defaults anyway */

        /* The registers HA/Passenger TPID0_TPID1<%n> have default value 0x0 instead of 0x81008100  */
        for(i=0; i<=7; i++)
        {
            rc = cpssDxChBrgVlanTpidEntrySet(devNum,CPSS_DXCH_ETHERTYPE_TABLE_EGRESS_LOGICAL_PORT_E,i,0x8100);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC(devNum) != GT_FALSE)
    {
        /* Bridge Global Configuration2 Register */
        /* Bit17: VPLS Mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.bridgeGlobalConfigRegArray[2];

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 17, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Ingress Policy Global Configuration Register */
        /* Bit15: VPLS Mode */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.control;

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 15, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ttiUnitConfig, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig, 16, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.passengerEgressPortTagTpidSourceSelect, 0, 32, 0xFFFFFFFF);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.eqBlkCfgRegs.preEgrEngineGlobal, 24, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDrvHwPpSetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg, 14, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpDxChXcat3RegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for xCat3 registers
*
* APPLICABLE DEVICES:
*        xCat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - (pointer to) Packet processor hardware specific
*                            parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpDxChXcat3RegsDefault
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC    *ppPhase1ParamsPtr
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address */
    GT_U32      serdes;     /* serdes index */
    GT_U32      i;          /* loop iterator */
    GT_U8  port;            /* iterator */

    /* start with the same xCat settings */
    rc =  hwPpDxChXcatRegsDefault(devNum, ppPhase1ParamsPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE)
    {
        /* set <Tsen Reset> , otherwise can not get temperature from the sensors */
        regAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.temperatureSensor28nmCtrlMSB;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                 devNum, regAddr, 8, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Change reason: Input clock existing AC cap coupling, TERM must be set to 0 */
        /* Connects to port init parameter - clock source that changed to SECONDARY */
        regAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl0;

        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                 devNum, regAddr, 6, 1, 0);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    /* Unicast local switching filtering is not functional with logical ports */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_UC_LOCAL_SWITCH_FILTER_FOR_VIRTUAL_PORTS_WA_E))
    {
        /* Set <EnaAc3FixVPortSupportForPacketDrop> in Bridge Global Configuration2 register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    bridgeRegs.bridgeGlobalConfigRegArray[2];

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 23, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* Ingress traffic is assigned with TrunkID rather than logical port */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_TRUNK_ID_ASSIGN_INSTEAD_OF_VIRTUAL_PORT_WA_E))
    {
        /* Set <EnaAc3FixSrcIsTrunkEq0ForVPort> in Bridge Global Configuration2 register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    bridgeRegs.bridgeGlobalConfigRegArray[2];

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 22, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    /* Traffic on OAM loopback port is not getting highest QoS */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_OAM_LB_PORT_NOT_GETTING_HIGHEST_QOS_WA_E))
    {
        /* Set <Metal Fix Set DP On OAM Loopback Enable> in TTI Metal Fix register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix;

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 19, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* NA and FU message size configuration - should be as in xCat - 2 words*/
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auqConfig_generalControl;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 17, 2, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Set to enable - avoid TTL modification for inner label for MPLS swap.
       Avoid packet corruption whaen MPLS label swap and no further label after the swapped label. */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 20, 1, 1);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E))
    {
        /* set bit <15> */
        for ( serdes = 0; serdes < 12 ; serdes++ )
        {
            rc = prvCpssHwPpSetRegField(
                 devNum,
                 PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                 15,
                 1,
                 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_DXCH_XCAT3_A1_AND_ABOVE_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* Enable fix for the following bug:
                read address to tcam gets corrupted if reqest fifo is full  */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamControl;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclTccRegs.policyTcamControl;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Enable fix for the following bug:
                IP multicast LPM mode: VID or VRF-ID  */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.bridgeInternal.dft;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 26, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Enable fix for the following bug:
                CPU priority over pipe in FDB writes */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.fdbInternal.metalFix;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Enable fix for RX Activity + TX Activity */
        for(i = 0; i < 2; i++)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ledRegs.ledHyperGStackDebugSelect[i];
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT3_GIG_MAC_HALF_DUPLEX_COLLISION_DOMAIN_RM_E))
    {
        for (i = 0; (i < PRV_CPSS_PP_MAC(devNum)->numOfPorts); i++)
        {

            if( !PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, i) )
                continue;

            /* Set <ColDomainLimit> in Port Serial Parameters Configuration register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[i].serialParameters;
            rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* "Internal" MAC28 and MAC29 configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1c * 0x1000;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1d * 0x1000;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* CPU MAC configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.cpuPortRegs.serialParameters;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 6, 0x1d);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    /* DMA Write access weight is increased in port RxFIFO.
       This change ensures that packets are written to memory
       If there is congestion on memory access.
       The Buffer Memory Tx Fifo Threshold and MPPM Aceess Arbiter Configuration
       Register 0x0E00006C is set as 0x4C4E6106
       For XLG ports Port Rx FIFO is set to 4 to accomodate the pressure.
       The Port FIFO Thresholds Configuration Registers 0x120D8010, 0x120D9010,
       0x120DA010, 0x120DB010 are set as 0x7BE4.
       (RM#6565603) */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_XCAT3_XLG_PORT_DROP_EVENT_PROBLEM_RM_E))
    {
        /* TXDMA Buffer Memory Tx Fifo Threshold and MPPM access Arbiter Configuration Register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.txdmaBufMemTxFifoThreshold;
        rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x4c4e6106);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Port FIFO Thresholds Confiruration Registers */
        for (port= 0; (port < PRV_CPSS_PP_MAC(devNum)->numOfPorts); port++)
        {
            if((PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum, port) == PRV_CPSS_PORT_XLG_E) || (PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum, port) == PRV_CPSS_PORT_XG_E))
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                            perPortRegs[port].xlgPortFIFOsThresholdsConfig;
                rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x7BE4);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
        /* "Internal" MAC28 and MAC29 configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[27].xlgPortFIFOsThresholdsConfig + 0x1000;
        rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x7BE4);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[27].xlgPortFIFOsThresholdsConfig + 2 * 0x1000;
        rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x7BE4);
        if(rc != GT_OK)
        {
            return rc;
        }

    }

    /*
        xCat3 behavior:
            forward FC feature does not work due to
            PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E (FE#3102).
            But MAC configuration of this feature should be done in order to
            solve another erratum - FE-8957081 (count received FC packets not functional).
            WA for FE-8957081 (FC counting) propose to enable FC forward + add TTI rule to terminate it.
            Following FE#3102 - it is not needed to add TTI rule - packet is dropped by ASIC.
            Therefore WA for FE-8957081 may be implemented as RM for XCAT3.
    */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_XCAT_FC_FORWARD_NOT_FUNCTIONAL_WA_E))
    {
        for (i = 0; (i < PRV_CPSS_PP_MAC(devNum)->numOfPorts); i++)
        {

            if( !PRV_CPSS_PHY_PORT_IS_EXIST_MAC(devNum, i) )
                continue;

            /* Set <forward_802_3x_fc_en> in Port Serial Parameters Configuration register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[i].serialParameters;
            rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* "Internal" MAC28 and MAC29 configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1c * 0x1000;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[0].serialParameters + 0x1d * 0x1000;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* CPU MAC configuration */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.cpuPortRegs.serialParameters;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 3, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpDxChLionRegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Lion registers
*
* APPLICABLE DEVICES:
*        Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3.
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - (pointer to) Packet processor hardware specific
*                            parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpDxChLionRegsDefault
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC    *ppPhase1ParamsPtr
)
{
    GT_STATUS   rc;             /* return code      */
    GT_U32      regAddr;        /* register address */
    GT_U32      portGroupId;    /* port group id    */
    GT_U32      serdes;         /* SERDES number    */
    GT_U32      data;
    GT_U8       port;/* port number */
    GT_U32      pclUnitBaseAddr;/* pcl unit base address */
    GT_U32      routerUnitBaseAddr;/* router unit base address */
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC shaperConfig; /* shaper configuration */
    GT_U32      ii; /* loop iterator */

    /* start with the same xCat settings */
    rc =  hwPpDxChXcatRegsDefault(devNum, ppPhase1ParamsPtr);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* add here DxCh Lion specifics */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_RM_SYNC_ETHERNET_NONE_SELECT_WA_E))
    {
        switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
        {
            case CPSS_PP_FAMILY_DXCH_LION_E:
                /* set bit <11> */
                for ( serdes = 0; serdes < 24 ; serdes++ )
                {
                    rc = prvCpssDrvHwPpSetRegField(
                         devNum,
                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                         11,
                         1,
                         1);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;
            case CPSS_PP_FAMILY_DXCH_LION2_E:
                for ( serdes = 0; serdes < 24 ; serdes++ )
                {
                    /* set bit <11> and <15> */
                    rc = prvCpssDrvHwPpWriteRegBitMask(
                         devNum,
                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                         0x8800,
                         0x8800);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
                for ( serdes = 0; serdes < 36; serdes++ )
                {
                    /* set bit <11> and <15> */
                    rc = prvCpssHwPpWriteRegBitMask(
                         devNum,
                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->serdesConfig[serdes].serdesExternalReg2,
                         0x8800,
                         0x8800);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            default:
                break;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_RM_TCAM_CONFIG_WA_E))
    {
        pclUnitBaseAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclTcamConfig0 & 0xFFF00000;
        routerUnitBaseAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamConfig0 & 0xFFF00000;


        /*Change bits[9:8] (Read Delay field) in Policy TCAM Configuration 0 Register*/
        regAddr = pclUnitBaseAddr + 0x208;/*0x0D000208*/
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,8,2,0x3);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            /*Change bits[9:8] (Read Delay field) in Router TCAM Configuration 0 Register*/
            regAddr = routerUnitBaseAddr + 0x96C;/*0x0D80096C*/
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,8,2,0x3);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*Change bits[15:8] (RdToRdDelay field) in Policy TCAM Configuration 2 Register Offset*/
        regAddr = pclUnitBaseAddr + 0x220;/*0x0D000220*/
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,8,8,0x17);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            /* fix the compare read delay after read for the TCAM:
                Register CPU 0x0D800978 Bits[15:8] should be set to 0x24.
                This is important for proper TCAM bist & Router activation */
            regAddr = routerUnitBaseAddr + 0x978;/*0x0D800978*/
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,8,8,0x24);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*Change bits[27:24] (ECCCycleReset field) in Policy TCAM Control Register*/
        regAddr = pclUnitBaseAddr + 0x148;/*0x0D000148*/
        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,24,4,0xf);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            /*Change bits[27:24] (ECCCycleReset field) in Router TCAM Control Register*/
            regAddr = routerUnitBaseAddr + 0x978;/*0x0D800978*/
            rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,24,4,0xf);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* WA for "Token Buckets are not supported" */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E))
    {
        /* check that device Lion B0A revision */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.chipId;/*0xD4*/
        portGroupId = 0;
        rc = prvCpssDrvHwPpPortGroupReadRegister(devNum, portGroupId,
                                                 regAddr, &data);
        if(rc != GT_OK)
        {
            return rc;
        }

        if ( (data != 0) || (PRV_CPSS_PP_MAC(devNum)->revision > 2) ||
             (PRV_CPSS_PP_MAC(devNum)->devFamily >= CPSS_PP_FAMILY_DXCH_LION2_E) )
        {
            /* this is Lion B0A revision or B1 and above.
               Set the <TxQStartInit> field to '0x1' */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl4;/*0x00000364*/
            rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr,
                                                    3, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* disable the old WA in order to enable shaper API */
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum,
                                           PRV_CPSS_DXCH_LION_TB_NOT_SUPPORTED_WA_E);
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_FDB_LIMIT_WA_E))
    {
        /* Disable Auto-learning, per port */
        for( port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            rc = cpssDxChBrgFdbPortLearnStatusSet(devNum, port, GT_FALSE, CPSS_LOCK_FRWRD_E);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /*Set the Age mode to Age-without-delete*/
        rc = cpssDxChBrgFdbActionModeSet(devNum,CPSS_FDB_ACTION_AGE_WITHOUT_REMOVAL_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_ORIG_SRC_PORT_FILTERING_WA_E))
    {
        /* set the device to filter the srcPort of own device on DSA tag frames */
        rc = cpssDxChCscdOrigSrcPortFilterEnableSet(devNum,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_CN_GLOBAL_REG_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            /*Set the CnDropEn field, bit[5] in the CN Global Configuration register,
            (offset: 0x0A0B0000) to 0x1 (enable).*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.
                congestNotification.cnGlobalConfigReg;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 5, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_TEMPERATURE_SENSOR_INITIALIZATION_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            /* need to Calibrate sensor on init in every power up
             (all below registers are in PortGroup0) */
            portGroupId = 0;

            /* 1) Change Temperature sensor average num from 2 to 8 and enable On-The-Fly
                  calibration -
                  Register 0x118F0D88 Bits[21:19] = 0x3 & & Bit[23] = 0x1 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.sht.dfx.dfx2;/*0x118F0D88*/
            rc = prvCpssHwPpPortGroupWriteRegBitMask(devNum, portGroupId ,regAddr,
                                                         0xB80000, 0x980000);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* 2) Change Temperature sensor RefCalCount from 0x113 to 0xf1 -
                  Register 0x118F0D8C Bits[17:9] = 0xF1 */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.sht.dfx.dfx3;/*0x118F0D8C*/
            rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId ,regAddr, 9, 9, 0xf1);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* 3) Start init -
                  Register 0x118F0D8C Bit[31] = 0x0*/
            rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId ,regAddr, 31, 1, 0);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* 4) Start init -
                  Register 0x118F0D8C Bit[31] = 0x1 */
            rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId ,regAddr, 31, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_MCFIFO_DISTRIBUTION_REG_WA_E))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
                        mcFifoConfig.distributionMask[0][0];

            /* need to configure all ports in the MCFIFO distribution mask register
               (0x01801010+ 0x4*n) as follow:
               1) configure ports 0-63
                   a) EVEN Ports - FIFO 0
                   b) ODD Ports - FIFO 1
            */

            data = 0xAAAAAAAA;/* all ODD bits are set , all even bits are cleared */

            /* set register for ports 0..31 */
            rc = prvCpssHwPpWriteRegister(devNum, regAddr, data);
            if(rc != GT_OK)
            {
                return rc;
            }

            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
                        mcFifoConfig.distributionMask[0][1];
            /* set register for ports 32..63 */
            rc = prvCpssHwPpWriteRegister(devNum, regAddr, data);
            if(rc != GT_OK)
            {
                return rc;
            }

        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_SD_PLL_REG_WA_E))
    {
        /*
            for XLG port proper work :
            Set the following registers in portGroup 0:
            1) Set register 0x378 = 0xD
            2) Delay 20uSec
            3) Set register 0x374 = 0x36203001
            4) Set register 0x378 = 0xC
            5) Delay 50uSec
            6) Set register 0x378 = 0x9E
        */
        portGroupId = 0;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sdPllCtrl; /* 0x378 */

        /*1) Set register 0x378 = 0xD*/
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0xD);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* 2) Delay 20uSec */
        cpssOsTimerWkAfter(1);/*1 msec --> 1000 usec */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sdPllParams; /* 0x374 */

        /* 3) Set register 0x374 = 0x36203001 */
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0x36203001);
        if(rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.sdPllCtrl; /* 0x378 */

        /* 4) Set register 0x378 = 0xC */
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0xC);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* 5) Delay 50uSec */
        cpssOsTimerWkAfter(1);/*1 msec --> 1000 usec */

        /* 6) Set register 0x378 = 0x9E */
        rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, regAddr,0x9E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_UC_STRICT_OVER_MC_WA_E))
    {
        /*  With default configurations, the UC are not served at WS in presence of */
        /*  MC, therfore give UC Strict Priority over MC.                           */
        /*  Set bit 2 in the MC FIFO Global Configurations Register (0x01801000).   */
        /* (RM#2710)                                                                */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.egr.mcFifoConfig.globalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_SCHEDULER_DEFICIT_MODE_WA_E))
    {
        /* The TxDMA isn't always ready to receive descriptor from the TxQ when      */
        /* instantaneous burstiness of data occurs.                                  */
        /* (RM#2709)                                                                 */
        /* The workaround consists of 2 steps:                                       */
        /* 1. Enabling the Deficit mode (handles higher burstiness of data on the    */
        /*    ports).                                                                */
        rc = cpssDxChPortTxSchedulerDeficitModeEnableSet(devNum, GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* 2. Set <Token Bucket Base Line> value to at least eight times the MTU.     */
        /* Get MTU value */
        rc = cpssDxChPortTxShaperConfigurationGet(devNum,&shaperConfig);
        if(rc != GT_OK)
        {
            return rc;
        }

        if( shaperConfig.portsPacketLength >= _2M )
        {
            /* MTU is too large and multiply by 8 will cause overflow. */
            /* Set max value for Base Line.                            */
            data = BIT_24 - 1;
        }
        else
        {
            /* Get Base Line value */
            rc = cpssDxChPortTxShaperBaselineGet(devNum, &data);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* If <Base Line> >= 8*MTU, do nothing, */
            /* Else <Base Line> = 8*MTU.            */
            if( data >= (8 * shaperConfig.portsPacketLength) )
            {
                data = 0;
            }
            else
            {
                data = (8 * shaperConfig.portsPacketLength);
            }
        }

        if( data > 0 )
        {
            /* Set Base Line value */
            rc = cpssDxChPortTxShaperBaselineSet(devNum, data);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_TX_MC_IN_CHUNKS_WA_E))
    {
        /* WS is not achieved in "one to many" traffic at 316 Bytes and below.        */
        /* Set the number of MC descriptors duplications done per UC descriptor       */
        /* to 4:1.                                                                    */
        /* Clear bits 1:0 in the MC FIFO Global Configurations Register (0x01801000). */
        /* (RM#2711)                                                                  */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.egr.mcFifoConfig.globalConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_BUFF_LIMIT_EGRESS_QUEUE_WA_E))
    {
        /* Wrong total number of buffers limit in egress queues.                     */
        /* Set bits 13:0 in the Global Buffer Limit Register (0x0A0A0310) to 0x1e70. */
        /* (RM#2712)                                                                 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            txqVer1.queue.tailDrop.limits.globalBufferLimit;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 14, 0x1e70);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_QCN_FOR_CN_FORMAT_WA_E))
    {
        /* Since QECN mode is obsolete, CN frame format must be set to QCN. */
        /* Set bit 29 in the Extended Global Control 2 Register (0x8C).     */
        /* (RM#2713)                                                        */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                globalRegs.extendedGlobalControl2;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 29, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E))
    {
          /* Only one priority queue can be specified for pausing at the same */
          /* time in PFC frame.                                               */
          /* (FEr#2787)                                                       */


          for( port = 0;
               (port < PRV_CPSS_PP_MAC(devNum)->numOfPorts) && (port <= 0xb);
               port++)
          {
              PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

              /* XG treatment */
              regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                  macRegs.perPortRegs[port].macRegsPerType[PRV_CPSS_PORT_XG_E].miscConfig;
              rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
              if(rc != GT_OK)
              {
                  return rc;
              }

              /* XLG treatment */
              if ( 10 == port )
              {
                  regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                      macRegs.perPortRegs[port].macRegsPerType[PRV_CPSS_PORT_XLG_E].miscConfig;
                  rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
                  if(rc != GT_OK)
                  {
                      return rc;
                  }
              }
          }
     }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E))
     {
         /* QCN frame format is partially compliant with IEEE 802.1 Qau.   */
         /* Set bit 0 in the HA Misc Configuration Register (0xE800710). */
         /* (FEr#2703)                                                     */
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.miscConfig;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
         if(rc != GT_OK)
         {
             return rc;
         }
     }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E))
     {
         /* CPU Mailbox to Neighbor CPU Device source information is not */
         /* complete.                                                    */
         /* (FEr#2776)                                                   */
         if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
         {
             regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                         txqVer1.dq.global.debug.metalFix;
             rc = prvCpssHwPpSetRegField(devNum, regAddr, 21, 1, 1);
             if(rc != GT_OK)
             {
                 return rc;
             }
         }
         else
         {  /* Lion2, Bobcat2, Caelum, Bobcat3 */
             regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                         txqVer1.queue.tailDrop.config.config;
             rc = prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, 1);
             if(rc != GT_OK)
             {
                 return rc;
             }
         }
     }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E))
     {
         /* The response to the XOFF PFC frame is inaccurate.              */
         /* Set bit 19 in the TTI Misc Confuguration Register (0x1000200). */
         /* (RM#2788)                                                      */
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMiscConfig;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 19, 1, 1);
         if(rc != GT_OK)
         {
             return rc;
         }
     }

     /* FEr#2774: WA for "False parity error indication at
        Ingress PCL Configuration table initialization" */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
       PRV_CPSS_DXCH_LION_IPCL_FALSE_PARITY_ERROR_WA_E))
    {
         /* Upon Ingress PCL Configuration tables initialization,
         clear by read the following registers:
            - PCL config table 0/1 parity error,
              bits[24:23] in the Policy Engine Interrupt Cause register (offset: 0x0B800004)
            - Config Table Parity Error Counter i Register (i=0..1),
              offset: PclConfigTable0: 0x0B80006C, PclConfigTable1: 0x0B800070 */
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.ipclEngineInterruptCause; /*0x0b800004*/

         /* the per port group information taken from ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId] */
         PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
         {
             rc = prvCpssDrvHwPpPortGroupReadRegister(devNum, portGroupId, regAddr, &data);
             if(rc != GT_OK)
             {
                return rc;
             }
             rc = prvCpssDrvHwPpPortGroupReadRegister(devNum, portGroupId,
                        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.configTblParityErrCtr[0], &data);
             if(rc != GT_OK)
             {
                return rc;
             }
             rc = prvCpssDrvHwPpPortGroupReadRegister(devNum, portGroupId,
                        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.configTblParityErrCtr[1], &data);
             if(rc != GT_OK)
             {
                return rc;
             }
         }
         PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
     }

     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_PORT_REQUEST_RATE_RM_WA_E))
     {
         /* Once the port request rate to the Link List exceeds its configurable */
         /* limit, descriptors may be corrupted and cause the device to hang.    */
         /* Set PortReqMask<n> (n=0..3) to 0x4 in Port Request Mask register     */
         /* (0x11001004).                                                        */
         /* (RM#2716)                                                            */
         for( ii = 0 ; ii <= 3 ; ii++ )
         {
             rc = cpssDxChPortTxRequestMaskSet(devNum, ii, 0x4);
             if(rc != GT_OK)
             {
                 return rc;
             }
         }
     }
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                    PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E))
    {
        PRV_CPSS_PORT_TYPE_ENT portMacType;

        for(port = 0; (port < PRV_CPSS_PP_MAC(devNum)->numOfPorts)
                                                    && (port < 12); port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            for(portMacType = PRV_CPSS_PORT_GE_E; portMacType <
                                            PRV_CPSS_PORT_NOT_APPLICABLE_E;
                portMacType++)
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[port].macRegsPerType[portMacType].fcDsaTag2;
                if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x0101);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                    perPortRegs[port].macRegsPerType[portMacType].fcDsaTag3;
                if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
                {
                    rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x8808);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                /* extended ports of Lion2 will be configured when reach XLG MAC */

            }/* end of for(portMacType = PRV_CPSS_PORT_GE_E*/

        }/* end of for(port = 0; */

     }/* end of PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E */

     /*  RM number not set yet - Enable the PFC trigger*/
     if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_RM_ENABLE_PFC_TRIGGER_WA_E))
     {
         regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.pfcRegs.pfcGlobalConfigReg;
         rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
         if (rc != GT_OK)
         {
             return rc;
         }
     }
     return GT_OK;
}


/*******************************************************************************
* prvCpssLion2FalseInterruptRegReset
*
* DESCRIPTION:
*       Reset false interrupt after reset in cause register.
*
* APPLICABLE DEVICES:
*       Lion2.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2.
*
* INPUTS:
*       devNum  - device number
*       memType - memory type
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssLion2FalseInterruptRegReset
(
    IN GT_U8 devNum,
    IN CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_ENT  memType
)
{
    GT_STATUS rc = GT_OK; /* return code */
    GT_U32 i;             /* iterator */
    GT_U32 regValue;      /* register's value */
    GT_U32 arraySize;     /* memory locations array size */
    CPSS_DIAG_DATA_INTEGRITY_MEMORY_LOCATION_STC memLocationArr[LION2_DATA_INTEGRITY_MAX_LOCATION_NUM_PER_MEMORY_CNS]; /* memory locations array */
    CPSS_DIAG_DATA_INTEGRITY_MEM_ERROR_PROTECTION_TYPE_ENT  protType; /* memory protection type */

    arraySize = LION2_DATA_INTEGRITY_MAX_LOCATION_NUM_PER_MEMORY_CNS;

    rc = prvCpssDxChDiagDataIntegrityMemoryIndexesGet(devNum,
                                                      memType,
                                                      GT_FALSE, 0,
                                                      &arraySize,
                                                      memLocationArr,
                                                      &protType);
    if (rc != GT_OK)
    {
        return rc;
    }

    if (protType != CPSS_DIAG_DATA_INTEGRITY_MEM_ERROR_PROTECTION_TYPE_NONE_E)
    {
        for (i = 0; i < arraySize; i++)
        {
            rc = prvCpssDfxMemoryRegRead(devNum,
                                         memLocationArr[i].dfxPipeId,
                                         memLocationArr[i].dfxClientId,
                                         memLocationArr[i].dfxMemoryId,
                                         0x1c/* Interrupt Cause Register */,
                                         &regValue);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpDxChLion2RegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for Lion2 registers
*
* APPLICABLE DEVICES:
*        Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3.
*
* INPUTS:
*       ppPhase1ParamsPtr  - (pointer to) Packet processor hardware specific
*                            parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
extern PRV_CPSS_LION2_INT_CAUSE_ENT lion2PortUnitHglSumIndex
(
    IN GT_PHYSICAL_PORT_NUM localPort
);

static GT_STATUS prvCpssCpllConfiguration
(
    IN GT_U8    devNum,
    IN GT_U32   serdesNum
)
{
    GT_STATUS rc = GT_OK;            /* return code */
    MV_HWS_INPUT_SRC_CLOCK srcClock; /* source clock*/

    rc = mvHwsSerdesClockGlobalControlGet(devNum, serdesNum, &srcClock);
    if ((rc != GT_OK) && (rc != GT_BAD_STATE))
    {
        return rc;
    }
    if((rc == GT_BAD_STATE) || (srcClock != MV_HWS_CPLL))
    {
        rc = mvHwsSerdesClockGlobalControl(devNum, 0, serdesNum, MV_HWS_CPLL, MV_HWS_156MHz_IN, MV_HWS_156MHz_OUT);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChDfxWtcRtcMemoryWrite
*
* DESCRIPTION:
*       Function configures the minimal WTC/RTC values to the memories.
*
* APPLICABLE DEVICES:
*       Bobcat2.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2;
*
* INPUTS:
*       devNum        - PP device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on wrong device
*       GT_TIMEOUT               - on BIST timeout
*       GT_BAD_STATE             - on BIST failure
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       RM-9308357 -
*           DFX Register Misconfiguration
*           Need to write the minimal values to the memories during device init.
*
******************************************************************************/
static GT_STATUS prvCpssDxChDfxWtcRtcMemoryWrite
(
    IN  GT_U8   devNum
)
{
    GT_STATUS rc;               /* return code */
    GT_U32 index = 0;
    struct{
        GT_U32  address;
        GT_U32  data;
    }dfxDataRegs[] =
    {
      {0x000f8000, 0x00000007},  /* enable all pipes                                    */
      {0x000e2000, 0x0807E100},  /* ram select = 126  , BC Addr.                        */
      {0x000e2008, 0x00040000},  /* RAM MC Group = RF2, BC Addr.                        */
      {0x000e1f80, 0x00000000},  /* RTC=0x0, WTC=0, BC Addr , MC RAM                    */
      {0x000e2008, 0x00038000},  /* RAM MC Group = RF1, BC Addr.                        */
      {0x000e1f80, 0x00000000},  /* RTC=0x0, WTC=0, BC Addr , MC RAM                    */
      {0x000e2008, 0x00028000},  /* RAM MC Group = SR1, BC Addr.                        */
      {0x000e1f80, 0x00000048},  /* RTC=0x1, WTC=0, BC Addr , MC RAM                    */
      {0x000e2008, 0x00030000},  /* RAM MC Group = SR2, BC Addr.                        */
      {0x000e1f80, 0x00000048},  /* RTC=0x1, WTC=0, BC Addr , MC RAM                    */
      {0x000e2000, 0x00000040},  /* Restore Client Control register default value       */
      {0x000e2008, 0x0000001f},  /* Restore Client Data Control register default value  */
      {0xFFFFFFFF, 0xFFFFFFFF}
    };

    while(dfxDataRegs[index].address != 0xFFFFFFFF)
    {
        /* Timing Adjustment Configurations */
        rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, dfxDataRegs[index].address, dfxDataRegs[index].data);
        if (rc != GT_OK)
        {
            return rc;
        }
        index++;
    }

    return GT_OK;
}

static GT_STATUS hwPpDxChLion2RegsDefault
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr
)
{
    GT_STATUS rc = GT_OK; /* return code */
    GT_U32 regAddr;       /* register's address */
    GT_U32 xData[8];      /* memory data */
    GT_U32 yData[8];      /* memory data */
    GT_U32 regValue = 0;  /* register's value */
    GT_U32 i;             /* iterator */
    GT_U32 ii;            /* iterator */
    GT_U32 portGroupId;   /* number of local core */
    GT_32  intKey;        /* interrupt key */
    GT_PHYSICAL_PORT_NUM localPort; /* number of port in local core */
    CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_ENT  memType; /* memory type for register reset */
    GT_U32 xParity;       /* X parity */
    GT_U32 yParity;       /* Y parity */
    GT_U32 ruleIndex;     /* TCAM rule index */
    GT_U32 index;         /* TCAM rule index */
    GT_BOOL ucSPEnable;   /* use SP or DSWRR sceduling */
    GT_U32 ucWeight;      /* unicast weight */
    GT_U32 mcWeight;      /* multicast weight */
    CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT schedMtu;  /* Scheduler MTU */
    CPSS_DXCH_PTP_TAI_ID_STC         taiId;     /* TAI Units identification */
    CPSS_PORT_TX_SCHEDULER_PROFILE_SET_ENT profile;       /* scheduler profile */

    /* the WA resets memories of egress units. It should be executed
       before other WAs to avoid data rewrite */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E))
    {
        /* Fix default value of BIST register */
        rc = prvCpssDxChDiagBistCaelumFixBist(devNum);
        if(rc != GT_OK)
            return rc;

        /* Fix default value of EPLR memories */
        rc = hwPpDxChBobkEplrMemoriesDefaultSet(devNum);
        if(rc != GT_OK)
            return rc;
    }

    rc = hwPpDxChLionRegsDefault(devNum, ppPhase1ParamsPtr);
    if(rc != GT_OK)
        return rc;

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION2_RM_TTI_DUAL_DEV_ENABLE_WA_E))
    {
        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            /* <Dual Device Id> */
            rc = prvCpssHwPpSetRegField(devNum,0x01000204,5, 1, 1);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
    }

        /* RM 9987707   - CPfcEn should be enabled by default */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_ENABLE_PFC_TRIGGER_WA_E))
        {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_PFC_MAC(devNum).PFCTriggerGlobalConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.pfcRegs.pfcGlobalConfigReg;
        }
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }


    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* <FdbMultiCoreEn> :
        Enables using Mask UnKnown DA Enable Port Group4/5/6/7.
        When this feature is enabled, the Mask UnKnown DA Enable Port Group
        is chosen by this selector: {OwnDev[0], PipeId[1:0]}
        */
        rc = prvCpssDrvHwPpSetRegField(devNum,
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bridgeRegs.bridgeGlobalConfigRegArray[2],
            28, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* RM-9082194 - Drop and xoff thresholds should be initialized to the maximal value*/
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_CPFC_THRESHOLDS_WA_E))
        {
            for(i = 0; i < CPSS_TC_RANGE_CNS; i++)
            {
                rc = cpssDxChPortPfcGlobalQueueConfigSet(devNum,(GT_U8)i,0x7FF,0x7FF,0x7FF/*don't care*/);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

            /* RM-9082194 - Set default Xoff thresholds for profiles*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.pfcRegs.pfcProfileXoffThresholds;

            /* Per profile*/
            for (i=0;i<PROFILE_NUM_CNS;i++)
            {
                /* Per TC*/
                for (ii=0;ii<CPSS_TC_RANGE_CNS;ii++)
                {
                    rc = prvCpssHwPpSetRegField(devNum, regAddr+(i*0x20) + (ii*0x4), 0, 11, 0x7FF);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }

        for( i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
        {
             PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
             portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, i);

             if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum))
             {
                 /* 523 (DIP) / 1332 (LionB0) - PFC status updates are ignored
                    when the port FC TX is disabled */
                 PRV_CPSS_DXCH_PORT_MAC_CTRL4_REG_MAC(devNum, i,
                                                      PRV_CPSS_PORT_XLG_E,
                                                      &regAddr);
                 rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,9,1,1);
                 if (rc != GT_OK)
                 {
                     return rc;
                 }

                 /* FE-31330 - Periodic PFC messages may be lost */
                 U32_SET_FIELD_MAC(regValue, 8, 2, 0x3);
             }
             else
             {
                 /* RM-2466587 - Enable Global Xoff activation on port */
                 if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_LION2_RM_GLOBAL_XOFF_ACTIVATION_ON_PORT_WA_E))
                 {
                     U32_SET_FIELD_MAC(regValue, 0, 8, 0xFF);
                 }
             }
             regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                 perPortRegs[i].macRegsPerType[PRV_CPSS_PORT_GE_E].ppfcControl;
             if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
             {
                 rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId,
                                                      regAddr, 0, 10, regValue);
                 if (rc != GT_OK)
                 {
                    return rc;
                 }
             }
             regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                 perPortRegs[i].macRegsPerType[PRV_CPSS_PORT_XLG_E].ppfcControl;
             if(regAddr != PRV_CPSS_SW_PTR_ENTRY_UNUSED)
             {
                 rc = prvCpssHwPpPortGroupSetRegField(devNum, portGroupId,
                                                      regAddr, 0, 10, regValue);
                 if (rc != GT_OK)
                 {
                    return rc;
                 }
             }
        }

        /*         RM-8439088   - PfcEn (LLFC in Lion 2) should be enabled by default */
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_LLFC_TRIGGER_GLOBAL_CONFIGURATION_WA_E))
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.llfcRegs.pfcGlobalConfigReg;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_LION2_RM_WRONG_DEFAULT_PFC_THRESHOLDS_WA_E))
        {
            /* RM-8035267 - Set default Xoff thresholds for profiles*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.llfcRegs.pfcProfileXoffThresholds;

            /* Per profile*/
            for (i=0;i<PROFILE_NUM_CNS;i++)
            {
                /* Per TC*/
                for (ii=0;ii<CPSS_TC_RANGE_CNS;ii++)
                {
                    rc = prvCpssHwPpSetRegField(devNum, regAddr+(ii*0x4)+(i*0x20), 0, 11, 0x7FF);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }

            /* RM-8035267 - Drop and xoff thresholds should be initialized to the maximal value*/
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.queue.llfcRegs.pfcGlobalGroupOfPortsThresholds;

            /* set the value for all port groups*/
            for (i=0; i < PRV_CPSS_LION2_PORT_GROUPS_NUM_CNS; i++)
            {
                /* For each traffic class*/
                for(ii = 0; ii < CPSS_TC_RANGE_CNS; ii++)
                {
                    /* Write 0x7FF to both drop and xoff thresholds, 11 bits each*/
                    rc = prvCpssHwPpSetRegField(devNum, regAddr + (ii*0x4)+ (i*0x20), 0, 22, 0x3FFFFF);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION2_HGL_MAC_INT_WA_E))
        {/* mask the HGL MAC interrupts */
            for( i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
                localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,i);

                (GT_VOID)cpssExtDrvSetIntLockUnlock(CPSS_OS_INTR_MODE_LOCK_E, &intKey);
                /* mask - i.e. event disable.                 */
                /* prvCpssDrvEventsMask may return not GT_OK  */
                /* if interrupt was not binded by application */
                /* or interrupts are not used.                */
                /* Need to ignore this fail.                  */
                (GT_VOID)prvCpssDrvEventsMask(devNum,
                                            lion2PortUnitHglSumIndex(localPort),
                                            GT_TRUE);
                if((9 == localPort) || (11 == localPort))
                {
                    localPort += 3;
                    (GT_VOID)prvCpssDrvEventsMask(devNum,
                        lion2PortUnitHglSumIndex(localPort),
                        GT_TRUE);
                }

                (GT_VOID)cpssExtDrvSetIntLockUnlock(CPSS_OS_INTR_MODE_UNLOCK_E, &intKey);
            }
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* no relay port */
    }
    else
    {
        /* Set relayed IF (internal port 12) to be served by MC FIFO 3 */
        rc = prvCpssHwPpWriteRegister(devNum,0x12001028,0x1000 );
        if (rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
                            mcFifoConfig.distributionMask[0][0];

        /* relayed IF (internal port 12) should not be served by MC FIFO 0/1 */
        rc = prvCpssHwPpWriteRegBitMask(devNum,regAddr,0x1000,0);
        if (rc != GT_OK)
        {
            return rc;
        }
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->txqVer1.egr.
                            mcFifoConfig.distributionMask[1][0];
        rc = prvCpssHwPpWriteRegBitMask(devNum,regAddr,0x1000,0);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if( (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)) &&
        (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE) )
    {
        /* set <Tsen Reset> , otherwise can not get temperature from the sensors */
        regAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                      DFXServerUnits.DFXServerRegs.temperatureSensor28nmCtrlMSB;
        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                 devNum, regAddr, 8, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    if( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
        (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE) )
    {
        /* Set OTF bit in all 5 temp sensors */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            dfxUnits.server.temperatureSensorControlMsb;

        for(i = 0; i < 5; i++)
        {
            regValue = 0x0000010 + (i * 0x02000000);
            rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr, 0xE000010, regValue);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* For Lion2 - 4 ports groups - init the localTrgPortMapOwnDevEn and localSrcPortMapOwnDevEn
       in order to enable odd device id */
    if ( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
         (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum) == 0 ) )
    {
        /* make sure that all the local traffic in the device uses the distributed TXQ mapper to
           direct all traffic to hemisphare 0.
           so set all 128 ports of src and trg to use the 'device map table' of the distributed TXQ.
           this without change the device map table in the hemisphere.
           */
        for(ii = 0 ; ii < 4; ii++)
        {
            /* configure localSrcPortMapOwnDevEn */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)-> txqVer1.dist.deviceMapTable.
                                localSrcPortMapOwnDevEn[ii];
            rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0xFFFFFFFF);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* configure localTrgPortMapOwnDevEn */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)-> txqVer1.dist.deviceMapTable.
                                localTrgPortMapOwnDevEn[ii];
            rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0xFFFFFFFF);
            if (rc != GT_OK)
            {
                return rc;
            }

        } /* ii */
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_BRIDGE_COMMANDS_DEFAULTS_WA_E))
    {
        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            /* JIRA : L2I-546 : wrong default values : "Non-IP Multicast Command" and
                "IP Multicast Command" should be forward not soft drop */
            /* the default in B0 is 'soft drop' */
            rc = cpssDxChBrgGenDropIpMcEnable(devNum,GT_FALSE);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* the default in B0 is 'soft drop' */
            rc = cpssDxChBrgGenDropNonIpMcEnable(devNum,GT_FALSE);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else /* JIRA : L2I-503 : Wrong registers defaults*/
        {
            /* set bridge command config registers 0 - default values
               to be backward compatible with lion2
               since all default values (in bobcat2) are set to 0 */

            /*************/
            /* set bits 0..2 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* soft drop of 'Invalid SA' */
            /* right now cpssDxChBrgGenDropInvalidSaEnable supports only 2 commands.
               It should be extended to 5 commands - need to set to soft drop */
            CPSS_TBD_BOOKMARK_EARCH
            rc = cpssDxChBrgGenDropInvalidSaEnable(devNum,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* set the drop of 'Invalid SA' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_INVALID_MAC_SA_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*************/
            /* set bits 3..5 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the drop of 'Invalid Vlan' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_INVALID_VLAN_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*************/
            /* set bits 6..8 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the drop of 'Port Not in VLAN Ingress' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_PORT_NOT_IN_VLAN_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }

            /*************/
            /* set bits 9..11 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the drop of 'VLAN Range' to be 'soft' */
            rc = cpssDxChBrgSecurBreachEventDropModeSet(devNum,
                CPSS_BRG_SECUR_BREACH_EVENTS_VLAN_RANGE_DROP_E,
                CPSS_DROP_MODE_SOFT_E);
            if(rc != GT_OK)
            {
                return rc;
            }


            /*************/
            /* set bits 15..17 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0 */
            /*************/
            /* set the command of 'SA static moved' to be 'forward' because this command
               applied also on non security breach event !
                rc = cpssDxChBrgSecurBreachEventPacketCommandSet(devNum,
                    CPSS_BRG_SECUR_BREACH_EVENTS_MOVED_STATIC_E,
                    CPSS_PACKET_CMD_FORWARD_E);
                if(rc != GT_OK)
                {
                    return rc;
                }
            */

            /****************************
               bits 21..23 in PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0
               not needed to set like Lion2 default because Lion2 had 'RM' on this one !
               see PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E
               So DON'T set the 'Arp mac sa mismatch' to be 'hard drop'
            ****************************/

            /* set bits 12..14 <VLAN MRU Command> to be 'hard drop' */
            regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig0;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 12, 3 , 3/*hard drop*/);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* set bits 24..26 <Secure Auto Learning Unknown Source Command> to be 'trap' */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 24, 3 , 2/*trap*/);
            if(rc != GT_OK)
            {
                return rc;
            }
            /* set bits 27..29 <Accept Frame Type Command> to be 'soft drop' */
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 27, 3 , 4/*soft drop*/);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* needed for ALL sip5 devices */
        /* legacy devices got implicit 'trap' command for 'ARP BC '*/
        /* in sip5 devices the command is from next register */

        /* set bits 24..26 <ePort ARP Broadcast Command> to be 'Trap To CPU' */
        regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeCommandConfig1;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 24, 3 , 2/*TrapToCPU*/);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E))
    {
        /* allow to the CPU to get the original vlan tag as payload after
           the DSA tag , so the info is not changed. */
        rc = cpssDxChBrgVlanForceNewDsaToCpuEnableSet(devNum,GT_TRUE);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E))
    {
        /* Reduce the threshold of the TxDMA read request FIFO for the
           header and payload */

        /* Set the Header Reorder FIFO Thresholds register to 0x9d */
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TXDMA_MAC(devNum).txDMAThresholdsConfigs.headerReorderFifoThreshold,
             0, 10, 0x9D);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Set the Payload Reorder FIFO Thresholds register to 0x9d */
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TXDMA_MAC(devNum).txDMAThresholdsConfigs.payloadReorderFifoThreshold,
             0 ,10, 0x9D);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E))
    {
        if(!PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            /* RateLimitDefecitCountEn default value should be set */
            rc = prvCpssHwPpSetRegField(devNum,
                 PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).ingrPortsRateLimitConfig.ingrRateLimitConfig1,
                 16 ,1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* RateLimitDefecitCountEn default value should be set */
            rc = prvCpssHwPpSetRegField(devNum,
                 PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).ingrPortsRateLimitConfig.ingrRateLimitConfig1,
                 28 ,1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E))
    {
        /* default value of <UC Strict Mode Enable> is wrong */
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).duplicationConfigs.duplicationConfigs0,
             8 ,1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Enable strict priority for unicast packets */
        rc = cpssDxChIpMultiTargetUcSchedModeGet(devNum, &ucSPEnable,
                                                 &ucWeight, &mcWeight,
                                                 &schedMtu);
        if (rc != GT_OK)
        {
            return rc;
        }

        ucSPEnable = GT_TRUE;    /* strict priority */
        rc = cpssDxChIpMultiTargetUcSchedModeSet(devNum, ucSPEnable,
                                                 ucWeight, mcWeight,
                                                 schedMtu);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E))
    {
        rc = prvCpssHwPpSetRegField(devNum,
             PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).TTIMetalFix,
             0 ,1, 0);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E))
    {
        /* <Control_from_CPU_Egress_Filter_En> -
           set value to Enable VLAN filtering for control traffic from CPU */
        rc = prvCpssHwPpSetRegField(devNum,
            PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.SHTGlobalConfigs,
            14,1,1);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.portShaper.portRequestMask;
        regValue =   0x00000004
              | 0x00000400
              | 0x00040000
              | 0x04000000;

        rc = prvCpssHwPpWriteRegister(devNum, regAddr, regValue);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_ILKN_PACKET_SIZE_LIMITATION_NOT_ENFORCED_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->GOP.ILKN_WRP.rxdmaConverterPacketSizeRestriction;
        regValue = 0x3FFF;

        rc = prvCpssHwPpSetRegField(devNum, regAddr, 14, 14, regValue);
        if( GT_OK != rc )
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TAI_CAPTURE_STATUS_SET_WA_E))
    {
        taiId.taiInstance = CPSS_DXCH_PTP_TAI_INSTANCE_ALL_E;
        taiId.taiNumber = CPSS_DXCH_PTP_TAI_NUMBER_ALL_E;

        /* Clearing Capture status */
        rc = cpssDxChPtpTaiTodCaptureStatusSet(devNum, &taiId, 0, GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = cpssDxChPtpTaiTodCaptureStatusSet(devNum, &taiId, 1, GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum, PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_AVS_INIT_WA_E))
    {
        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                    DFXServerUnits.DFXServerRegs.AVSDisabledCtrl1[0];
            /* AVS <%a> Select Vsense0  - avs_vdd_sense0 is selected */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr,
                                                                        23, 1, 1);
            if( GT_OK != rc )
            {
                return rc;
            }

            regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                    DFXServerUnits.DFXServerRegs.AVSEnabledCtrl[0];
            /* AVS <%a> Low VDD Limit and AVS <%a> High VDD Limit */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr,
                                                                4, 16,
                                                                ((0x26<<8)|0x26));
            if( GT_OK != rc )
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* check relevancy for device by using PRV_CPSS_DXCH_ERRATA_GET_MAC
           instead of using PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC */
        CPSS_TBD_BOOKMARK_EARCH

        /* set <IP MLL MC Source ID Mask> for BWC with previous device */
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLMCSourceID;
        rc = prvCpssHwPpSetRegField(devNum,regAddr,0, 12, 0xFFF);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_GIGE_MAC_LINK_STATUS_WA_E))
    {
        for( i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, i);

            rc = prvCpssDxChPortLion2GeLinkStatusWaEnableSet(devNum,i,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* in order to fix false interrupt, read BMA MC cause register */
    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_BMA_MC_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E))
    {
        memType = CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_BMA_MC_CLEAR_SHIFTER_E;

        rc = prvCpssLion2FalseInterruptRegReset(devNum, memType);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    /* in order to fix false interrupt, read MLL FIFO cause register */
    if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_WRONG_DEFAULT_MLL_DATA_INTEGRITY_PARITY_INTERRUPT_WA_E))
    {
        memType = CPSS_DXCH_DIAG_DATA_INTEGRITY_MEM_TYPE_MLL_PCL2MLL_UNUSED_FIFO_E;

        rc = prvCpssLion2FalseInterruptRegReset(devNum, memType);
        if(GT_OK != rc)
        {
            return rc;
        }
    }


    /* DFX ECC Interrupts Summary Mask Register init */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalInterrupt.dfxInterruptMask;

        rc = prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0xFFFFFFFF, 0xFFFFFFFC);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if ((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) && (ppPhase1ParamsPtr->tcamParityCalcEnable))
    {
        /* PCL TCAM Parity Daemon duty cycle config */

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.pclTccRegs.policyTcamControl;
        /* set maximal period */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 24, 4, 0xF);
        if(rc != GT_OK)
        {
            return rc;
        }

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTccRegs.ipTcamControl;
        /* set maximal period */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 24, 4, 0xF);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Default PCL X/Y Parity Calculation */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            for(ruleIndex = 0; ruleIndex < (PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning.tableSize.policyTcamRaws * 4); ruleIndex++)
            {
                for(i = 0; i < 8; i++)
                {
                    /* X */
                    rc = prvCpssDxChPclTcamReadStdRuleAddrGet(
                        devNum, ruleIndex, i, GT_TRUE, &regAddr);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    rc = prvCpssDrvHwPpPortGroupReadRegister(
                        devNum, portGroupId, regAddr, &(xData[i]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    /* Y */
                    rc = prvCpssDxChPclTcamReadStdRuleAddrGet(
                        devNum, ruleIndex, i, GT_FALSE, &regAddr);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    rc = prvCpssDrvHwPpPortGroupReadRegister(
                        devNum, portGroupId, regAddr, &(yData[i]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }

                prvCpssDxChLion2PclTcamParityCalc(xData, yData, &xParity, &yParity);

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.tcamReadPatternParityBase;

                /* Write Parity_X table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (ruleIndex * 4)), xParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->pclRegs.tcamReadMaskParityBase;

                /* Write Parity_Y table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (ruleIndex * 4)), yParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)


        /* Default Router X/Y Parity Calculation */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            for(index = 0; index < PRV_CPSS_DXCH_ROUTER_TUNNEL_TERM_GET_MAX_SIZE_MAC(devNum); index++)
            {
                for(i = 0; i < 4; i++)
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerTtTcamBankAddr[0] + (index*4 + i) * 0x10;

                    rc = prvCpssDrvHwPpPortGroupReadRam(devNum, portGroupId, regAddr, 2, &(xData[i*2]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                    rc = prvCpssDrvHwPpPortGroupReadRam(devNum, portGroupId, (regAddr + 8), 2, &(yData[i*2]));
                    if (rc != GT_OK)
                    {
                        return rc;
                    }

                }

                prvCpssDxChLion2RouterTcamParityCalc(xData, &xParity);

                prvCpssDxChLion2RouterTcamParityCalc(yData, &yParity);

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTccRegs.ipTcamReadPatternParityBase;

                /* Write Parity_X table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (index * 4)), xParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTccRegs.ipTcamReadMaskParityBase;

                /* Write Parity_Y table */
                rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum, portGroupId, (regAddr + (index * 4)), yParity);
                if (rc != GT_OK)
                {
                    return rc;
                }

            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    }

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_LION2_RM_WRONG_GIG_DESC_FIFO_THRESHOLD_WA_E))
    {
        if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum))
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->bufferMng.
                txdmaBufMemFifosThreshold[CPSS_DXCH_PORT_BUF_MEM_FIFO_TYPE_GIGA_E];
            /* GigDescFifoThreshold bits 0:5 */
            rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 0, 6, 0x4);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

        rc = prvCpssDxChSMIDrvInit(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

        for(i = 0 ; pDev->hwInfo.smi_support.activeSMIList[i] != (GT_U32)CPSS_PHY_SMI_INTERFACE_INVALID_E; i++)
        {
            rc = prvCpssDxChSMIInvertMDCSet(devNum,0,pDev->hwInfo.smi_support.activeSMIList[i],GT_FALSE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }


        /* TAIs UNRESET*/
        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.gop_tai.supportSingleInstance)
        {
            regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, 0, 0).TAICtrlReg0;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* loop on GOPs */
            for ( i = 0 ; i < 10 ; i++ )
            {
                /* loop on TAIs */
                for ( ii = 0 ; ii < 2 ; ii++ )
                {
                    regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, ii).
                                                                        TAICtrlReg0;
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 1);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }

            /* configure TOD interface rate for Global TAIs */
            i = 9;
            /* loop on TAIs */
            for ( ii = 0 ; ii < 2 ; ii++ )
            {
                regAddr = PRV_DXCH_REG1_UNIT_GOP_TAI_MAC(devNum, i, ii).
                                                                    TAICtrlReg1;
                rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 12, 0x6db);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }


        /* Enables shaper token bucket update (periodic addition of tokens).
           Must be enabled to support shaping or PFC response.*/
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 31, 1, 1);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Disable global legacy exact shaping and scheduling */
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).scheduler.schedulerConfig.schedulerConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 22, 1, 0);
        if(rc != GT_OK)
        {
            return rc;
        }

        for(profile = CPSS_PORT_TX_SCHEDULER_PROFILE_1_E; profile <= PRV_CPSS_DXCH_PORT_TX_SCHEDULER_PROFILE_MAX_MAC(devNum); profile++)
        {
            /* Configure Shaper byte count mode to transmitted packet size */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }

            /* Configure Scheduler byte count mode to transmitted packet size */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.profileByteCountModification[profile];
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 9, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE)
        {
            /* set comon mode voltage range of the clock input. bit 4 of
               Reset and Init Controller/DFX Server Units - BC2 specific registers/Device Control 0
               should be '0' */
            regAddr =
                PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl0;
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                                     devNum, regAddr, 4, 1, 0);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                         PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E))
        {
            regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl14;
            /* PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_DEFAULT_DEVICE_CONTROL_14_WA_E
                           set bits#[31..29]  = rf_debug_clock_sel to 4 */
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 29, 3, 0x4);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                         PRV_CPSS_DXCH_BOBCAT2_RM_DFX_REGISTERS_MISSCONFIGURATION_WA_E))
        {
            /* Configure the minimal values to the WTC/RTC memories */
            rc = prvCpssDxChDfxWtcRtcMemoryWrite(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

    } /* if (PRV_CPSS_SIP_5_CHECK_MAC(devNum)) */

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).ePort.ePortGlobalConfig;
        /* PRV_CPSS_DXCH_BOBCAT2_RM_PROT_SWITCH_STAGE_EN_DEFAULT_VALUE_WA_E
           set bit#3  = Protection_Switching_Stage_Enable
                      = to be always 1 - cannot be configured under traffic - internal bit */
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 2, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXDMA_MAC(devNum).txDMADescCriticalFieldsECCConfigs.dataECCConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, 0x3);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).global.ECCConf;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 2, 0x3);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).tailDrop.tailDropConfig.globalTailDropConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 2, 0x3);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TXQ_QCN_MAC(devNum).txqECCConf;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).duplicationConfigs.duplicationConfigs0;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 11, 1, 0x1);
        if(GT_OK != rc)
        {
            return rc;
        }

        regAddr = PRV_DXCH_REG1_UNIT_EQ_MAC(devNum).criticalECCCntrs.criticalECCConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 5, 0x1F);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum) == GT_TRUE)
    {
        /* Enable SERDES delay write for BC2 B0 */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.genxsRateConfig;
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 23, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* Enable the Flow Control indication pause toward the port to allow
            FCA functionality. In A0 this bit by default was 1. */
        for (i = 0; i < 73; i++)
        {
            if(i < 72)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
            }

            regAddr = PRV_DXCH_REG1_UNIT_RXDMA_MAC(devNum).
                                    singleChannelDMAConfigs.SCDMAConfig0[i];
            rc = prvCpssHwPpPortGroupSetRegField(devNum,
                                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                    regAddr,
                                                    28, /* Flow Control En<<%n>> filed offset */
                                                    1,  /* field length */
                                                    1); /* Enable Flow Control */
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                     PRV_CPSS_DXCH_BOBCAT2_EPLR_TO_CPU_OAM_WA_E))
    {
        regAddr = PRV_DXCH_REG1_UNIT_PLR_MAC(devNum, CPSS_DXCH_POLICER_STAGE_EGRESS_E).policerCtrl1;
        /* set bit#10 En To Cpu Meter And Count to be enable metering and
           counting for TO CPU packets in EPLR*/
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 0x1);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                        PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E))
        {
            for (i = 0; i < 72; i++)
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,i);
                regAddr = PRV_DXCH_REG1_UNIT_GOP_FCA_MAC(devNum, i).DSATag32To47;
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x0101);
                if(rc != GT_OK)
                {
                    return rc;
                }

                regAddr = PRV_DXCH_REG1_UNIT_GOP_FCA_MAC(devNum, i).DSATag48To63;
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0x8808);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
         }/* end of PRV_CPSS_DXCH_LION_RM_PFC_DSA_TAG_E */
    }

    if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
    {
        /* disable local source device packets filtering         */
        /* BobK implements this feature to from CPU packets also */
        /* not as legacy devices                                 */
        rc = cpssDxChCscdDsaSrcDevFilterSet(devNum, GT_FALSE);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Allign rate limit configuration with 128 physical ports for BobK devices.
           Default value of register is for 256 ports devices.
           Need to multiply fields of register by 2. */
        if(PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort == 7)
        {
            rc = prvCpssHwPpWriteRegister(devNum,
                  PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).ingrPortsRateLimitConfig.ingrRateLimitConfig2,
                  0x4004032);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        /* CPLL configuration */
        /* for serdeses 0 - 11          -  CPLL0 */
        switch(PRV_CPSS_PP_MAC(devNum)->devType)
        {
            case CPSS_BOBK_CAELUM_DEVICES_CASES_MAC:
                rc = prvCpssCpllConfiguration(devNum, 0);
                if (rc != GT_OK)
                {
                    return rc;
                }
            default:
                break;
        }
        /* CPLL configuration */
        /* for serdeses 20, 24 - 35     -  CPLL2 */
        rc = prvCpssCpllConfiguration(devNum, 24);
        if (rc != GT_OK)
        {
            return rc;
        }

    }

    /* PIP feature initialization */
    if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
    {
        /* default value for the <generic etherType <n>> '0' is wrong and should
           be '0x0800' , to avoid entering this case by 'accident' (as 0x0800 is
           previous case of ipv4) */
        for(ii = 0 ; ii < 4 ; ii++)
        {
            rc = cpssDxChPortPipGlobalEtherTypeProtocolSet(devNum,
                CPSS_DXCH_PORT_PIP_PROTOCOL_UDE_E,
                ii,
                0x0800);/* Ipv4 etherType */
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* index 1   - should be 0x88a8 (and not 0x8a88)
           index 2,3 - default value for the <VLAN EtherType Conf <n>> '0' is wrong and should
           be '0x8100' , to avoid entering this case by 'accident' (as 0x8100 is
           in index 0) */
        for(ii = 1 ; ii < 4 ; ii++)
        {
            rc = cpssDxChPortPipGlobalEtherTypeProtocolSet(devNum,
                CPSS_DXCH_PORT_PIP_PROTOCOL_VLAN_TAG_E,
                ii,
                (ii == 1)  ? 0x88A8 :
                /*index 2,3*/0x8100);/* index 2,3 --> 'vlan tag' - the same value as index 0 */
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        /* ipv6 etherType - should be 0x86dd (and not 0x8600) */
        rc = cpssDxChPortPipGlobalEtherTypeProtocolSet(devNum,
            CPSS_DXCH_PORT_PIP_PROTOCOL_IPV6_E,
            0,/*don't care*/
            0x86dd);/* Ipv6 etherType */
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_CAELUM_INGRESS_VLAN_RANGE_CONFIG_WA_E))
    {
        /* Set default VLAN range to 4.5K - 1 */
        rc = cpssDxChBrgVlanRangeSet(devNum, _4K + (_1K/2) - 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpDxChXcat2RegsDefault
*
* DESCRIPTION:
*       Set mandatory default values for xCat2 registers
*
* APPLICABLE DEVICES:
*        xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion.
*
*
* INPUTS:
*       devNum  - device number
*       ppPhase1ParamsPtr  - (pointer to) Packet processor hardware specific
*                            parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK            - on success
*       GT_FAIL          - on other error.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpDxChXcat2RegsDefault
(
    IN GT_U8                                    devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC    *ppPhase1ParamsPtr
)
{
    GT_STATUS   rc;         /* return code */
    GT_U8       port;       /* port number */
    GT_U32      regAddr;    /* register address */

    rc = hwPpDxChLionRegsDefault(devNum, ppPhase1ParamsPtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_RM_STACK_PORT_MIB_CNTR_CONTROL_WA_E))
    {
        /* Enable MAC MIB Counters Clear on read for stack ports 24..27 */
        for( port = 24; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);

            rc = cpssDxChPortMacCountersClearOnReadSet(devNum, port, GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* setting bit 9 to be 0 - disable SRR init */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.serverSkipInitMatrix;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 9, 1, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* setting bit 9 to be 0 - CPU skipInit */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.genSkipInitMatrix0;
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 9, 1, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* We want PTP packets to be "forward" rather then "dropped/trapped" */
    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT2_PTP_FRAGMENT_PACKET_TRAP_WA_E))
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ttiRegs.ttiMetalFix;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 18, 3, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if( PRV_CPSS_PP_MAC(devNum)->revision >= 4 )
    {
        for(port = 0; port < PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum,port);
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.
                                                perPortRegs[port].serdesCnfg;
            if(PRV_CPSS_SW_PTR_ENTRY_UNUSED == regAddr)
                continue;

          /* ACK (bit[14] of the Auto-Negotiation code word) is set to 0 in
             SGMII mode during ABILITY_DETECT state, according to the MAC
             Auto-Negotiation state machine according to IEEE standard.
           */
            rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 8, 1, 1);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1NeededWaSettings
*
* DESCRIPTION:
*       Part 1 of "phase 1"
*       initialize all the WA that needed for the device
*
*       function called from the "phase 1" sequence.
*
* INPUTS:
*       devNum          - The Pp's device number to set the errata Wa needed.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK             - on success
*       GT_OUT_OF_CPU_MEM - on failing memory allocation
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS hwPpPhase1NeededWaSettings
(
    IN GT_U8    devNum
)
{
    GT_U32  ii;/*iterator*/
    PRV_CPSS_DXCH_ERRATA_STC *errataPtr =
        &PRV_CPSS_DXCH_PP_MAC(devNum)->errata;/*pointer to errata info of the device */
    PRV_CPSS_DXCH_ERRATA_STACK_MAC_COUNT_SHADOW_STC *macCountShadowPtr; /*mac Count Shadow Ptr*/

    /* set that the device need the fix of the :
       Errata FEr# */

      /* Disabling the Egress Rate Shaper under traffic may hang its
     relevant transmit queue. (FEr#47) */
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                 PRV_CPSS_DXCH_TOKEN_BUCKET_RATE_SHAPING_DISABLE_WA_E);

    /* When a packet is received from a remote device, the CPU should calculate
       the correct byte count by decrementing the DSA tagsize from the PktOrigBC.
       (FEr#89) */
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH_PACKET_ORIG_BYTE_COUNT_WA_E);

    /* needed WA for deadlock in the PP , between 'learning' and 'scanning' in
        FDB .
        see detailed info in description of:
        PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E */
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E);

    /* Wrong default in FDB Global Configuration register - RM# 2704*/
    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_RM_FDB_GLOBAL_CONF_REG_WA_E);

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
    {
        /* fill additional errata/RM for the Lion */
        for(ii = 0 ; lionErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, lionErrAndRmArray[ii]);
        }

        /* XLG port may not support wire speed in all cases. */
        /* (FEr#2709)                                        */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH_LION_XLG_WS_SUPPORT_WA_E);

        if( PRV_CPSS_PP_MAC(devNum)->revision > 2 )
        {
            /* Only one priority queue can be specified for pausing at the same */
            /* time in PFC frame.                                               */
            /* (FEr#2787)                                                       */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_LION_PFC_FOR_MANY_PRIORITY_WA_E);

            /* QCN frame format is partially compliant with IEEE 802.1 Qau.     */
            /* Set bit 0 in the HA Misc Configuration Register (0xE800710).   */
            /* (FEr#2703)                                                       */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_LION_QCN_FORMAT_COMPLIANT_WA_E);

            /* The response to the XOFF PFC frame is inaccurate.                */
            /* Set bit 19 in the TTI Misc Confuguration Register (0x1000200).   */
            /* (RM#2788)                                                        */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_LION_INACCURATE_PFC_XOFF_WA_E);

            /* CPU Mailbox to Neighbor CPU device source information is not     */
            /* complete - wrong source port assigment.                          */
            /* (FEr#2776)                                                       */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_LION_INCOMPLETE_CPU_MAILBOX_INFO_WA_E);
        }

        /* must fill info for PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E */
        /* PCL */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
            0x0D0001A4; /* TCC (lower) for PCL register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
            PRV_CPSS_LION_B_TCC_LOWER_GEN_TCAM_ERROR_DETECTED_E;/* value for lion (non lion A) */

        /* Router */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
            0x0D800060; /* TCC (upper) for router register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
            PRV_CPSS_LION_B_TCC_UPPER_GEN_TCAM_ERROR_DETECTED_E;/* value for lion (non lion A) */

    }
    else if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
                PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            /* fill additional errata/RM for the Lion2 */
            for(ii = 0 ; lion2ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, lion2ErrAndRmArray[ii]);
            }
        }
        else /* Bobcat2; Caelum; Bobcat3 */
        {
            /* bobcat2 fill errata/RM for the device */
            for(ii = 0 ; bobcat2ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, bobcat2ErrAndRmArray[ii]);
            }

            if (0 == PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
            {
                /* set BC2 A0 specific WAs */

                /* RM: TAI-5 */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_BOBCAT2_RM_TAI_CAPTURE_STATUS_SET_WA_E);
                /* FE-5613945 */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_BOBCAT2_SGMII_TO_CPU_NOT_SUPPORTED_WA_E);

                /* clean WAs not relevant for BC2 A0 devices */
                for(ii = 0 ; notExistsInBobcat2A0ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, notExistsInBobcat2A0ErrAndRmArray[ii]);
                }
            }

            if (1 == PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
            {
                /* clean WAs not relevant for BC2 B0 devices */
                for(ii = 0 ; notExistsInBobcat2B0ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, notExistsInBobcat2B0ErrAndRmArray[ii]);
                }
            }

            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))/*bobk*/
            {
                /* remove fixed errata/RM */
                for(ii = 0 ; fixedInBobkErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInBobkErrAndRmArray[ii]);
                }

                if (!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
                {
                    /* Caelum and Cetus specific errata/RM */
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_CAELUM_EGRESS_MEMORIES_NOT_RESET_WA_E);
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,PRV_CPSS_DXCH_CAELUM_INGRESS_VLAN_RANGE_CONFIG_WA_E);
                }
            }

            if (PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                /* remove fixed errata/RM */
                for(ii = 0 ; fixedInBobcat3ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, fixedInBobcat3ErrAndRmArray[ii]);
                }
            }
        }

        if (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum) <= 1)
        {
            /* This errata relevant only to devices with more then one hemisphere */
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                devNum, PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E);
        }

        if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                     PRV_CPSS_DXCH_LION2_SHARE_EN_CHANGE_WA_E);
#ifndef ASIC_SIMULATION
/* simulation doesn't support status bits needed for this WA */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                     PRV_CPSS_DXCH_LION2_DISMATCH_PORTS_LINK_WA_E);
#endif
        }

        if(PRV_CPSS_DXCH_LION2_B0_AND_ABOVE_CHECK_MAC(devNum)
           || (PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            CPSS_PORTS_BMP_STC *portForceLinkDownBmpPtr;

            portForceLinkDownBmpPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_LION2_DISMATCH_PORT_LINK_WA_E.
                        portForceLinkDownBmpPtr =
                    (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
            if (portForceLinkDownBmpPtr == NULL)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
            }
            CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(portForceLinkDownBmpPtr);
        }

        if(PRV_CPSS_DXCH_LION2_B1_AND_ABOVE_CHECK_MAC(devNum))
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(
                devNum, PRV_CPSS_DXCH_LION2_GIGE_MAC_LINK_STATUS_WA_E);
            PRV_CPSS_DXCH_ERRATA_SET_MAC(
                devNum, PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E);
        }

        /* must fill info for PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E */
        /* PCL */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
            0x0D0001A4; /* TCC (lower) for PCL register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
            PRV_CPSS_LION2_TCC_LOWER_GEN_TCAM_ERROR_DETECTED_E;

        /* Router */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
            0x0D800060; /* TCC (upper) for router register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
            PRV_CPSS_LION2_TCC_UPPER_GEN_TCAM_ERROR_DETECTED_E;

        if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
           (PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.tcamParityCalcEnable))

        {
            /* IP and Policy parity TCAM daemon is supported, no interrupt during direct read */
            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum,
                        PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E);
        }

        if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
        {
            convertRegAddrToNewUnitsBaseAddr(devNum,
                &errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr);
            convertRegAddrToNewUnitsBaseAddr(devNum,
                &errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr);

            if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
            {
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_NON_ORIG_VID_ON_TRAP_TO_CPU_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_WRONG_TXDMA_FIFO_THRESHOLD_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_RATE_LIMIT_DEFICIT_COUNT_EN_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_STRICT_PRIORITY_FOR_UC_PACKETS_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TTI_BAD_DEFAULT_VALUE_FIX_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_CONTROL_FROM_CPU_EGRESS_FILTER_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_MPLS_TRANSIT_TUNNEL_PARSING_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_TXQ_PORT_REQUEST_MASK_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_NOT_ALLOW_TTI_ACTION_TO_SET_MODIFY_UP_DSCP_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_RM_GLOBAL_EPORT_RANGE_VALUE_AND_MASK_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_PFC_NOT_SUPPORTED_PORTS_48_71_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_FC_802_3X_NOT_SUPPORTED_TM_MAPPED_PORTS_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(
                    devNum, PRV_CPSS_DXCH_BOBCAT2_DESCRIPTOR_ECC_PROTECTION_CORRUPTION_WITH_REMOTE_PORTS_WA_E);
            }
        }
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* fill additional errata/RM for the xCat2 */
        for(ii = 0 ; xcat2ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, xcat2ErrAndRmArray[ii]);
        }

        if( PRV_CPSS_PP_MAC(devNum)->revision >= 2 )
        {
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_BCN_CONTROL_CCFC_SRC_PORT_WA_E);
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E);

            PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT2_STACK_MAC_COUNT_NO_CLEAR_ON_READ_WA_E);
            if( PRV_CPSS_PP_MAC(devNum)->revision >= 3 )
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT2_PTP_UDP_FRAGMENT_WA_E);
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT2_100FX_WA_E);
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT2_PTP_FRAGMENT_PACKET_TRAP_WA_E);
            }
        }

        /* PCL */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
            0x0E0001A4; /* TCC (lower) for PCL register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
            PRV_CPSS_XCAT2_TCC_LOWER_UNIT_TCAM_ERROR_DETECTED_E;

        /* Router */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
            0x0E800060; /* TCC (upper) for router register */
        errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
            PRV_CPSS_XCAT2_TCC_UPPER_UNIT_TCAM_ERROR_DETECTED_E;

        /* Stack Ports Mac counters shadow */

        macCountShadowPtr = (PRV_CPSS_DXCH_ERRATA_STACK_MAC_COUNT_SHADOW_STC*)
            cpssOsMalloc(sizeof(PRV_CPSS_DXCH_ERRATA_STACK_MAC_COUNT_SHADOW_STC));

        if (macCountShadowPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        /* assume initional state of counters - zeros */
        cpssOsMemSet(
            macCountShadowPtr, 0,
            sizeof(PRV_CPSS_DXCH_ERRATA_STACK_MAC_COUNT_SHADOW_STC));

        /* assume clear-on-read option is off */
        for (ii = 0; (ii < PRV_CPSS_DXCH_ERRATA_STACK_PORT_AMOUNT_CNS); ii++)
        {
            macCountShadowPtr->stackPortArr[ii].clearOnRead = GT_FALSE;
        }

        errataPtr->
            info_PRV_CPSS_DXCH_XCAT2_STACK_MAC_COUNT_NO_CLEAR_ON_READ_WA_E.
            stackMacCntPtr = macCountShadowPtr;
    }
    else if((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E) ||
            (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E))
    {

        /*  VLT direct access write problem with VLAN and STP tables (entry > 1 word) */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                     PRV_CPSS_DXCH3_VLT_TABLES_WRITE_DIRECT_ACCESS_WA_E);

        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_CPU_ACCESS_TO_FDB_UNDER_TRAFFIC_WA_E);

        /* layer 4 sanity checks are enabled by default - RM#3018*/
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E);

        /* FEr#2018 - Policy base routing LTT index can be written only to array0 of the LTT line */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_LIMITED_NUMBER_OF_POLICY_BASED_ROUTES_WA_E);

        if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
        {
            if(PRV_CPSS_PP_MAC(devNum)->revision == 0)
            {
                /* RM#2011:  TCAM PLL Register has wrong default value
                   FEr#2012: TCAM/CORE/MPPM clock frequencies above 250 MHz
                             are not operational */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                            PRV_CPSS_DXCH3_RM_TCAM_PLL_REG_WA_E);
            }

            /* Change the default value of Network Port SERDES Misc Conf Register:
               0x0000000D at addresses 0x09800014 + n*0x400: where n (0-23) represents Port
               (RM#2062) */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH3_RM_GE_SERDES_MISC_CONF_REG_WA_E);

            /* FEr#2014: Sampled at Reset Network reference clock select is not functional */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH3_SAMPLE_AT_RESET_NET_REF_CLOCK_SELECT_WA_E);

            /* FEr#2191 - TCAM eFUSE mechanism is not triggered automatically */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_TCAM_EFUSE_NOT_TRIGGERED_AUTO_WA_E);

            /* TB#233 PCL and Router TCAM Software Repair Update */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_TCAM_REPAIR_WA_E);

            /* Change the default value of Buffer Memory Tx Fifo Threshold
               and MPPM Access Arbiter Configuration Register:
               0x444e610c at address 0x0780006C
               (RM#2063) */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH3_RM_BM_TX_FIFO_THRESHOLD_CONF_REG_WA_E);

            /* Fixes for device revision B2 */
            if( 1 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.mg.metalFix )
            {
                /* SERDES yield improvement due to PLL unlocking issue. */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                         PRV_CPSS_DXCH3_SERDES_YIELD_IMPROVEMENT_WA_E);

                /* Toggling Device Enable under traffic may cause system hang.
                   (FEr#2261) */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                         PRV_CPSS_DXCH3_TOGGLE_DEV_EN_UNDER_TRAFFIC_WA_E);
            }
        }

        if (0 == PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
        {
            /* those NOT relevant to the xcat and above */

            /* FEr#2006: VLT Tables Indirect Access is not functional */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_VLT_INDIRECT_ACCESS_WA_E);

            /* RM#2007: LMS GigE Ports Mode Register1 */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E);

            /* RM#2008: LMS HyperG.Stack Ports Mode Register */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E);

            /* FEr#2009 - SDMA resource errors may cause PCI Express packets reception
             malfunction */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH3_SDMA_WA_E);

            /* RM#2026: MAC2ME Low Registers */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_RM_MAC2ME_LOW_REG_WA_E);

            /* RM#2061: PHY Auto-Negotiation Configuration Register0 and Register2 */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_RM_AN_CNF_REG_WA_E);

            /* FE#2046 policer - QoS attributes incorrect modification for out-of-profile traffic */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_OUT_OF_PROFILE_QOS_ATTR_E);

            /* FEr#1098 - A write to the Transmit Queue Full Interrupt Mask register
              (offset: 0x018001EC) does not function */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_TXQ_FULL_INTERRUPT_NOT_FUNCTION_WA_E);

            /* FEr#204 - TxQ Parity calculation is wrong for Descriptors & FLL memories */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                PRV_CPSS_DXCH3_TXQ_PARITY_CALCULATION_E);
        }

        /* RM#2003: Buffer Management GbE and HyperG.Stack Ports Group Limits Configuration Registers */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_BM_GE_XG_PORT_GROUP_LIMIT_CFG_REG_WA_E);

        /* FEr#2004 - Policy and Router TCAM Tables indirect read is not functional*/
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_POLICY_AND_ROUTER_TCAM_TABLES_INDIRECT_READ_WA_E);

        /* RM#2024: LMS0/1 Group1LED Interface0 Control Register 1 and Class6 Manipulation Register */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_RM_LMS0_1_GROUP1_LED_INTERFACE_WA_E);

        /* FEr#2028 - Direct access to EQ (Pre-Egress) engine address space is
           not functional under traffic */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E);

        /* FEr#2033,FEr#2050: When the CPU reads the POLICY TCAM or ROUTER TCAM
           via direct address space the ECC error exception signaled */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E);

        /* must fill info for PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E */
        if (0 == PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
        {
            /* ch3 */

            /* PCL */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
                0x0B800010; /* PCL interrupt register */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
                PRV_CPSS_CH3_PCL_TCC_ECC_ERR_E;/* value for ch3 but also used for xcat A0 */

            /* Router */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
                0x02040130; /* L2 Bridge interrupt register */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
                PRV_CPSS_CH3_EB_TCC_E;/* value for ch3 but also used for xcat A0 */
        }
        else if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
        {
            /* xcat3 */

            /* PCL */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
                0x1A0001A4; /* TCC (lower) for PCL register */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
                PRV_CPSS_XCAT3_TCC_LOWER_TCAM_ERROR_DETECTED_E;/* value for xcat3 */

            /* Router */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
                0x1B000060; /* TCC (upper) for router register */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
                PRV_CPSS_XCAT3_TCC_UPPER_TCAM_ERROR_DETECTED_E;/* value for xcat3 */
        }
        else
        {
            /* xcat and above */

            /* PCL */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptCauseRegAddr =
                0x0E0001A4; /* TCC (lower) for PCL register */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.pclInterruptIndex =
                PRV_CPSS_XCAT_TCC_LOWER_SUM_TCAM_ERROR_DETECTED_E;/* value for xcat (non A0) */

            /* Router */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptCauseRegAddr =
                0x0E800060; /* TCC (upper) for router register */
            errataPtr->info_PRV_CPSS_DXCH3_CPU_READ_TCAM_ECC_INTERRUPT_WA_E.routerInterruptIndex =
                PRV_CPSS_XCAT_TCC_UPPER_SUM_TCAM_ERROR_DETECTED_E;/* value for xcat (non A0) */
        }


        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E ||
           PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
        {
            /* fill additional errata/RM for the xcat */
            for(ii = 0 ; xcatA1ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
            {
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,xcatA1ErrAndRmArray[ii]);
            }

            /* check revision ID */
            if ((PRV_CPSS_PP_MAC(devNum)->revision >= 3) &&
                (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E))
            {
               /* XCAT A2 and above, do not Trunk To CPU WA but enable HW fix */
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E);
               /* FEr#3054: Gig port PRBS is not functional. */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT_GIGA_PORT_PRBS_PARAM_INIT_WA_E);
            }

            /* check revision ID */
            if (((PRV_CPSS_PP_MAC(devNum)->revision >= 3) &&
                 (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)) ||
                (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E))
            {
               /* XCAT A2 and above, do not set 256*n+[1..4] padding WA */
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E);

               /* RM#3017 - Enable CPU lacks source port information on traffic received from trunk workaround */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E);
            }

            if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
            {
                CPSS_PORTS_BMP_STC *portForceLinkDownBmpPtr;

                for(ii = 0 ; xcat3ErrAndRmArray[ii] != LAST_DEV_IN_LIST_CNS ; ii++)
                {
                    PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,xcat3ErrAndRmArray[ii]);
                }

                /* xCat3 tables access info is already initialized with the indirect access when required */
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH3_DIRECT_ACCESS_TO_EQ_ADDRESS_SPACE_WA_E);

                /* The following ERRATAs are cleared from xCat3 for initial bringup */
                /* Port related ones might be no longer valid due to new GOP.       */

                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_MAC_CTRL_REG3_PCS_PREAMBLE_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_RM_PORT_SERIAL_PARAMETERS_CONFIGURATION_WA_E);

                portForceLinkDownBmpPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                            info_PRV_CPSS_DXCH_LION2_DISMATCH_PORT_LINK_WA_E.
                            portForceLinkDownBmpPtr =
                        (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
                if (portForceLinkDownBmpPtr == NULL)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
                }
                CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(portForceLinkDownBmpPtr);

                /* remove cause PCL tests to fail :
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E);
                */
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH3_RM_GE_PORTS_MODE1_REG_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH3_RM_XG_PORTS_MODE_REG_WA_E);
                PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(devNum, PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E);
            }
        }
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily <= CPSS_PP_FAMILY_CHEETAH2_E)
    {
        /* Rm#83 - XG PHY path failure.Wrong value of PHY register 0xFF34. */
        PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                    PRV_CPSS_DXCH_RM_XG_PHY_PATH_FAILURE_WA_E);

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH2_E)
        {
            /* layer 4 sanity checks are enabled by default - RM#3018*/
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                            PRV_CPSS_DXCH2_RM_BRG_LAYER_4_SANITY_CHECKS_WA_E);

            /* FEr#1084 - Wrong data when reading Source-ID Assignment Mode Conf. reg.
               Shadow of the register should be used by SW. */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_READ_SRC_ID_ASSIGMENT_MODE_CONF_REG_WA_E);

            /* FEr#1006 -  Bridge Access Matrix Line <7> register is write only.
               Shadow of the register should be used by SW. */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_BRIDGE_ACCESS_MATRIX_LINE7_WRITE_WA_E);

            /* FEr#1001 - Direct access to policer engine address space is not functional */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_DIRECT_ACCESS_TO_POLICER_ADDRESS_SPACE_WA_E);

            /* FEr#1003 - Router ARP and Tunnel Start table do not support burst access via PCI */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_ROUTER_ARP_AND_TS_TABLE_NOT_SUPPORT_BURST_ACCESS_VIA_PCI_WA_E);

            /* FEr#1007 - RdWrTrig, bit[15] in the VLT Tables Access Control register is ignored */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_RDWRTRIG_BIT_IN_VLT_TABLES_ACCESS_CONTROL_REGISTER_IGNORED_E);

            /* FEr#1062 - Indirect access for Router and Tunnel Termination (TT)
                          TCAM does not function correctly */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_INDIRECT_ACCESS_ROUTER_AND_TT_TCAM_NOT_FUNCTION_CORRECTLY_WA_E);

            /* RM#1081 - Reserved registers 0x0B820108 */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_RM_RESERVED_REGISTERS_0x0B820108_WA_E);

            /* FEr#1087 - Mismatch in Policy Action entry table for Egress PCL */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_PCL_EGRESS_ACTION_CNTR_VLAN_WRONG_BITS_POS_WA_E);

           /* Direct access to Policy Action entry table non-burst */
            /* is not functional (FEr#1090)                         */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH2_POLICY_ACTION_DIRECT_BURST_ONLY_READ_WA_E);

            return GT_OK;

        }

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH_E)
        {
            /* In Jumbo frames mode the maximal SDWRR weight that may be
               configured is 254. (FEr#29) */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_JUMBO_FRAMES_MODE_SDWRR_WEIGHT_LIMITATION_WA_E);

            /* Trunk configuration for Trunk Next Hop (FEr#137) */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_TRUNK_CONFIG_FOR_TRUNK_NEXT_HOP_WA_E);

            /*In FDB Aging with removal mode, AA messages are sent for entries
              removed due to an invalid device (FEr#22)*/
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_FDB_AGING_WITH_REMOVAL_MODE_WA_E);

            /* The maximum value of the 1000MWindow field, in the Ingress Rate
                limit Configuration Register0 is 31. (FEr#140) */
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_RATE_LIMIT_GIG_COUNTER_BITS_NUM_WA_E);

            /* Wrong read value for oversize and jabber counters in XG MIBs (FEr#85)*/
            PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_XG_MIB_READ_OVERSIZE_AND_JABBER_COUNTERS_WA_E);

            if((PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX163_CNS) ||
               (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX243_CNS) ||
               (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX262_CNS))
            {
                /* Some FDB table entries must be invalidated (RM#28) */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DXCH_RM_FDB_TABLE_ENTRIES_WA_E);
            }
        }
    }

    if (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                    PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E))
    {
        /* ports state shadow */
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.
            portTxQueuesBmpPtr = (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC)*CPSS_TC_RANGE_CNS);
        if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.
                portTxQueuesBmpPtr == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }

        for (ii = 0; ii < CPSS_TC_RANGE_CNS; ii++)
        {
            /* assume initial state of ports TX queues - enabled */
            CPSS_PORTS_BMP_PORT_SET_ALL_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                 info_PRV_CPSS_DXCH_XCAT_GE_PORT_DISABLE_WA_E.portTxQueuesBmpPtr + ii);
        }

    }

    return GT_OK;
}

#ifdef ASIC_SIMULATION
extern void scibCoreClockRegisterUpdate
(
    IN GT_U32                  deviceId,
    IN GT_U32                  coreClockInMHz,
    IN GT_U32                  hwFieldValue
);

/* flag only for Golden model that may not have the DFX register that hold the
   core clock */
static GT_U32 gm_simUserDefinedCoreClockMHz = 0;

GT_VOID simCoreClockOverwrite
(
    GT_U32 simUserDefinedCoreClockMHz
)
{
    /* assume that deviceId = 0 is needed */
    GT_U32  deviceId = 0;

    /* simulation will fatal error if the core clock is not found ! */
    scibCoreClockRegisterUpdate(deviceId/*simulation devId*/,simUserDefinedCoreClockMHz,0/*ignored*/);

    gm_simUserDefinedCoreClockMHz = simUserDefinedCoreClockMHz;

}

#endif

/*
 * Typedef: struct PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC
 *
 * Description: A structure to Core Clock PLL config tables pointers
 *
 * Fields:
 *      devFamily    - CPSS's device family that current device belongs to.
 *      devSubFamily - CPSS's device sub-family that current device belongs to.
 *      revision     - The device's revision number.
 *      tablePtr     - pointer to PLL config to core clock table
 *      tableSize    - size of table
 */
typedef struct
{
    CPSS_PP_FAMILY_TYPE_ENT      family;
    CPSS_PP_SUB_FAMILY_TYPE_ENT  subFamily;
    GT_U32                       revision;
    GT_U16                      *tablePtr;
    GT_U16                       tableSize;
}PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC;

/*******************************************************************************
* hwPpAutoDetectCoreClock
*
* DESCRIPTION:
*       Retrieves Core Clock value
*
* INPUTS:
*       devNum         - The Pp's device numer.
*
* OUTPUTS:
*       coreClkPtr     - Pp's core clock in MHz
*
* RETURNS:
*       GT_OK        - on success,
*       GT_BAD_STATE - can't map HW value to core clock value.
*       GT_FAIL      - otherwise.
*
* COMMENTS:
*       Function is using hard coded registers address since registers DB is not
*       yet initialized.
*
*******************************************************************************/
static GT_STATUS hwPpAutoDetectCoreClock
(
    IN  GT_U8   devNum,
    OUT GT_U32  *coreClkPtr
)
{

    GT_U32 data = 0;
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr;/* pointer to common device info */
    GT_BOOL valueReadFromHw = GT_TRUE;

    devPtr = PRV_CPSS_PP_MAC(devNum);

    switch(devPtr->devFamily)
    {
        case CPSS_PP_FAMILY_CHEETAH_E:
           /* retrieve PP Core Clock from Sampled at Reset reg 0x00000004 field PLL_CONFIG */
            if (prvCpssDrvHwPpGetRegField(devNum,0x000004,16,4,&data) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

            if (devPtr->devType == CPSS_98DX106_CNS)
            {
                switch (data)
                {
                    case 0 : *coreClkPtr = 144; break;
                    case 1 : *coreClkPtr = 141; break;
                    case 2 : *coreClkPtr = 156; break;
                    default:  CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                switch (data)
                {
                    case 0 : *coreClkPtr = 141; break;
                    case 1 : *coreClkPtr = 150; break;
                    case 2 : *coreClkPtr = 166; break;
                    case 3 : *coreClkPtr = 175; break;
                    case 4 : *coreClkPtr = 187; break;
                    case 5 : *coreClkPtr = 200; break;
                    case 6 : *coreClkPtr = 220; break;
                    case 8 : *coreClkPtr = 195; break;
                    case 9 :
                        if (devPtr->devType == CPSS_98DX249_CNS ||
                            devPtr->devType == CPSS_98DX269_CNS )
                            *coreClkPtr = 191;
                        else
                            *coreClkPtr = 197;
                        break;
                    case 10 : *coreClkPtr = 198; break;
                    case 11 : *coreClkPtr = 206; break;
                    case 12 : *coreClkPtr = 200; break;
                    case 13 : *coreClkPtr = 222; break;
                    case 14 : *coreClkPtr = 225; break;
                    case 15 : *coreClkPtr = 250; break;

                    default:  CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
            }
            break;

        case CPSS_PP_FAMILY_CHEETAH2_E:
           /* retrieve PP Core Clock from Sampled at Reset reg 0x00000004 field PLL_CONFIG */
            if (prvCpssDrvHwPpGetRegField(devNum,0x000004,16,4,&data) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

            switch (data)
            {
                case 0 :    *coreClkPtr = 141; break;
                case 1 :    *coreClkPtr = 154; break;
                case 2 :    *coreClkPtr = 167; break;
                case 3 :    *coreClkPtr = 180; break;
                case 4 :    *coreClkPtr = 187; break;
                case 5 :    *coreClkPtr = 194; break;
                case 6 :    *coreClkPtr = 207; break;
                case 8 :    *coreClkPtr = 221; break;
                case 9 :    *coreClkPtr = 210; break;
                case 10 :   *coreClkPtr = 214; break;
                case 11 :   *coreClkPtr = 217; break;
                case 12 :   *coreClkPtr = 200; break;
                case 13 :   *coreClkPtr = 224; break;
                case 14 :   *coreClkPtr = 228; break;
                case 15 :   *coreClkPtr = 233; break;

                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_PP_FAMILY_CHEETAH3_E:
           /* retrieve PP Core Clock from Sampled at Reset - CorePllConfig */
            if (prvCpssDrvHwPpGetRegField(devNum,0x00000028,22,4,&data) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            switch (data)
            {
                case 0 :    *coreClkPtr = 271; break;
                case 1 :    *coreClkPtr = 275; break;
                case 2 :    *coreClkPtr = 267; break;
                case 3 :    *coreClkPtr = 250; break;
                case 4 :    *coreClkPtr = 221; break;
                case 5 :    *coreClkPtr = 204; break;
                case 6 :    *coreClkPtr = 200; break;
                case 7 :    *coreClkPtr = 196; break;
                case 8 :    *coreClkPtr = 187; break;
                case 9 :    *coreClkPtr = 179; break;
                case 10 :   *coreClkPtr = 175; break;
                case 11 :   *coreClkPtr = 321; break;
                case 12 :   *coreClkPtr = 317; break;
                case 13 :   *coreClkPtr = 308; break;
                case 14 :   *coreClkPtr = 300; break;

                    case 15:  /*Bypass; PLL0 is bypassed.*/
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_PP_FAMILY_DXCH_XCAT_E:
            /* retrieve PP Core Clock from Sampled at Reset - CorePllConfig */
            if (prvCpssDrvHwPpGetRegField(devNum,0x0000002C,2,3,&data) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            switch(data)
            {
                case 0x0:  *coreClkPtr = 250; break;
                case 0x1:  *coreClkPtr = 222; break;
                case 0x2:  *coreClkPtr = 200; break;
                case 0x3:  *coreClkPtr = 182; break;
                case 0x4:  *coreClkPtr = 167; break;
                case 0x5:  *coreClkPtr = 154; break;
                case 0x6:  *coreClkPtr = 143; break;
                case 0x7:  *coreClkPtr = 288; break;
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE)
            {
                /* retrieve PP Core Clock from "Device SAR2" */
                if (prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                    devNum, 0x000F8204, 21, 3, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                valueReadFromHw = GT_FALSE;
            }

            switch(data)
            {
                case 0x0:  *coreClkPtr = 290; break;
                case 0x1:  *coreClkPtr = 250; break;
                case 0x2:  *coreClkPtr = 220; break;
                case 0x3:  *coreClkPtr = 167; break;
                case 0x4:  *coreClkPtr = 200; break;
                case 0x5:  *coreClkPtr = 133; break;
                case 0x6:  *coreClkPtr = 360; break;
                case 0x7:  /*Bypass; PLL0 is bypassed.*/
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_PP_FAMILY_DXCH_LION_E:
                /* retrieve PP Core Clock from Sampled at Reset - CorePllConfig */
                if (prvCpssDrvHwPpGetRegField(
                    devNum, 0x00000028 /*globalRegs.sampledAtResetReg*/,
                    2, 2, &data) != GT_OK)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                switch(data)
                {
                    case 0x0:  *coreClkPtr = 360; break; /* 0x0 - REF_CLK_25 x 14.4; Frequency = 360 MHz */
                    case 0x1:  *coreClkPtr = 320; break; /* 0x1 - REF_CLK_25 x 12.8; Frequency = 320 MHz */
                    case 0x2:  *coreClkPtr = 300; break; /* 0x2 - REF_CLK_25 x 12; Frequency = 300 MHz   */
                    case 0x3:  /*Bypass; PLL0 is bypassed.*/
                    default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
            break;

        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            /* retrieve PP Core Clock from Sampled at Reset - CorePllConfig */
            if (prvCpssDrvHwPpGetRegField(devNum,0x0000002C,2,3,&data) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            switch(data)
            {
                case 0x0:  *coreClkPtr = 250; break;
                case 0x1:  *coreClkPtr = 222; break;
                case 0x2:  *coreClkPtr = 200; break;
                case 0x3:  *coreClkPtr = 182; break;
                case 0x4:  *coreClkPtr = 167; break;
                case 0x5:  *coreClkPtr = 154; break;
                case 0x6:  *coreClkPtr = 143; break;
                case 0x7:  *coreClkPtr = 133; break;
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE)
            {
                /* retrieve PP Core Clock from "Functional SAR Status LSB" */
                if (prvCpssHwPpGetRegField(devNum, 0x018F8200, 0, 3, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                valueReadFromHw = GT_FALSE;
            }

            switch(data)
            {
                case 0x0:  *coreClkPtr = 480; break;
                case 0x1:  *coreClkPtr = 360; break;
                case 0x2:  *coreClkPtr = 270; break;
                case 0x3:  *coreClkPtr = 450; break;
                case 0x4:  *coreClkPtr = 312; break; /* 312.5Mhz */
                case 0x5:  *coreClkPtr = 240; break;
                case 0x6:  *coreClkPtr = 210; break;
                case 0x7:  /*Bypass; PLL0 is bypassed.*/
                default:    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
        {
            const PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC *clockTbl = NULL;

            static const GT_U16 clockMHzByPLL0_bc2_Status_x_revision_0[] =
            {                    /*   0,    1,   2,   3,   4,   5.   6   */
                    /* 0 */         362, /* 362.500000 Mhz */
                    /* 1 */         221, /* 220.833333 Mhz */
                    /* 2 */         250, /* 250.000000 Mhz */
                    /* 3 */         400, /* 400.000000 Mhz */
                    /* 4 */         500, /* 500.000000 Mhz */
                    /* 5 */         521, /* 520.833333 Mhz */
                    /* 6 */         450  /* 450.000000 Mhz */
            };
            static const GT_U16 clockMHzByPLL0_bc2_Status_x_revision_1[] =
            {
                    /* 0 */         362, /* 362.500000 Mhz */
                    /* 1 */         221, /* 220.833333 Mhz */
                    /* 2 */         250, /* 250.000000 Mhz */
                    /* 3 */         400, /* 400.000000 Mhz */
                    /* 4 */         175, /* ???            */
                    /* 5 */         521, /* 520.833333 Mhz */
                    /* 6 */         450  /* 450.000000 Mhz */
            };

            static const GT_U16 clockMHzByPLL0_bobk_Status_x_revision_0[] =
            {
                    /* 0 */         365,      /* 0 = 365.625 MHz    */
                    /* 1 */         220,      /* 1 = 220.833 MHz    */
                    /* 2 */         250,      /* 2 = 250.000 MHz    */
                    /* 3 */         200,      /* 3 = 200.000 MHz    */
                    /* 4 */         167,      /* 4 = 167.188 MHz    */
                    /* 5 */         133,      /* 5 = 133.333 Mhz Reserved  */
                    /* 6 */         225,      /* 6 = 225.000 Mhz Reserved  */
                    /* 7 */          25       /* 7 = Bypass mode (PLL in power down), output is 25Mhz */
            };
            static const GT_U16 clockMHzByPLL0_aldrin_Status_x_all_revisions[] =
            {
                    /* 0 */         365,      /* 0 = 365.625 MHz    */
                    /* 1 */         220,      /* 1 = 220.833 MHz Reserved   */
                    /* 2 */         250,      /* 2 = 250.000 MHz    */
                    /* 3 */         200,      /* 3 = 200.000 MHz    */
                    /* 4 */         480,      /* 4 = 480.000 MHz    */
                    /* 5 */         510,      /* 5 = 510.333 Mhz Reserved  */
                    /* 6 */         540,      /* 6 = 540.000 Mhz Reserved  */
                    /* 7 */          25       /* 7 = Bypass mode (PLL in power down), output is 25Mhz */
            };

#define CLK_TBL(T) (GT_U16*)&T[0], (GT_U16)(sizeof(T)/sizeof(T[0]))
            static const PRV_CPSS_DXCH_FAMILY_SUBFAM_REV_x_CORECLOCK_LIST_CONV_STC fam_subFam_rev_x_coreClockList[] =
            {
                  { CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, CLK_TBL(clockMHzByPLL0_bc2_Status_x_revision_0)  }
                 ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,         1, CLK_TBL(clockMHzByPLL0_bc2_Status_x_revision_1)  }
                 ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E, 0, CLK_TBL(clockMHzByPLL0_bobk_Status_x_revision_0) }
                 ,{ CPSS_PP_FAMILY_DXCH_BOBCAT3_E, CPSS_PP_SUB_FAMILY_NONE_E,         0, CLK_TBL(clockMHzByPLL0_bc2_Status_x_revision_0)  }
                 ,{ CPSS_PP_FAMILY_DXCH_ALDRIN_E,  CPSS_PP_SUB_FAMILY_NONE_E,         0, CLK_TBL(clockMHzByPLL0_aldrin_Status_x_all_revisions)  }
            };

            GT_U32 i;

            if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE)
            {
                /* retrieve PP Core Clock from "Device SAR2 PLL0 " */
                /* /Cider/EBU/Bobcat2B/Bobcat2 {Current}/Reset and Init Controller/DFX Server Units - BC2 specific registers/Device SAR2                */
                /* /Cider/EBU/BobK/BobK {Current}/Reset And Init Controller/DFX Units/Units/DFX Server Registers/Device Sample at Reset (SAR) Status<1> */
                if (prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                    devNum, 0x000F8204, 21, 3, &data) != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                valueReadFromHw = GT_FALSE;
            }

            /*-------------------------------------------------*/
            /* find greatest revision smaller or equal to given */
            /*-------------------------------------------------*/

            /* find first suitable revision */
            for (i = 0 ; i < sizeof(fam_subFam_rev_x_coreClockList)/sizeof(fam_subFam_rev_x_coreClockList[0]); i++)
            {
                if (fam_subFam_rev_x_coreClockList[i].family    == PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily &&
                    fam_subFam_rev_x_coreClockList[i].subFamily == PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devSubFamily)
                {
                    if (fam_subFam_rev_x_coreClockList[i].revision <= PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.revision)
                    {
                        if (clockTbl != NULL)
                        {
                            if (fam_subFam_rev_x_coreClockList[i].revision <= clockTbl->revision)
                            {
                                continue;
                            }
                        }
                        clockTbl = fam_subFam_rev_x_coreClockList+i;
                    }
                }
            }
            if (clockTbl == NULL)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }

            if (data >= clockTbl->tableSize)  /*Bypass; PLL0 is bypassed.*/
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            }

            *coreClkPtr = (GT_U32)clockTbl->tablePtr[data];
        }
        break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if( valueReadFromHw == GT_FALSE)
    {
        #ifdef ASIC_SIMULATION
        if(gm_simUserDefinedCoreClockMHz != 0)
        {
            *coreClkPtr = gm_simUserDefinedCoreClockMHz;
        }
        #endif
    }

    return GT_OK;
}

/*******************************************************************************
* devDbBusBaseAddrAttachKeyGet
*
* DESCRIPTION:
*       Calculate unique BusBaseAddr key for prvCpssPpConfigDevDbBusBaseAddrAttach call.
*
* INPUTS:
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*       multiPortGroupDevice    - indication that the device supposed to be 'multi port groups' device.
*       firstActivePortGroupId  - first Active Port GroupId, pelevant for multi Port Group Device only
*
* OUTPUTS:
*       busBaseAddrKeyPtr      - (pointer to) Key used as busBaseAddr
*                                in prvCpssPpConfigDevDbBusBaseAddrAttach.
*
* RETURNS:
*       bus Base Addr Key value
*
* COMMENTS:
*
*******************************************************************************/
static GT_UINTPTR devDbBusBaseAddrAttachKeyGet
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    IN      GT_BOOL                             multiPortGroupDevice,
    IN      GT_U32                              firstActivePortGroupId
)
{
    GT_UINTPTR       busBase;       /* busBaseAddr in ppPhase1ParamsPtr            */
    CPSS_HW_ADDR_STC *hwAddrPtr;    /* pointer to hwAddr in ppPhase1ParamsPtr      */

    if (multiPortGroupDevice == GT_FALSE)
    {
        busBase    = ppPhase1ParamsPtr->busBaseAddr;
        hwAddrPtr  = &(ppPhase1ParamsPtr->hwAddr);
    }
    else
    {
        busBase    = ppPhase1ParamsPtr->multiPortGroupsInfoPtr[firstActivePortGroupId].busBaseAddr;
        hwAddrPtr  = &(ppPhase1ParamsPtr->multiPortGroupsInfoPtr[firstActivePortGroupId].hwAddr);
    }

    if (ppPhase1ParamsPtr->mngInterfaceType == CPSS_CHANNEL_PEX_KERNEL_E)
    {
        return (3 |
            (hwAddrPtr->busNo << 2) |
            (hwAddrPtr->devSel << 12) |
            (hwAddrPtr->funcNo << 22));
    }
    else
    {
        return busBase;
    }
}
/*******************************************************************************
* setSipVersion
*
* DESCRIPTION:
*       set the sip version (legacy / 5 / 5_10 / 5_15 /...).
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS setSipVersion
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);

    if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
        {
            /* supports sip 5_15 */
            PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_15_E);
        }
        else if (devPtr->revision > 0)
        {
            /* supports sip 5_10 */
            PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_10_E);
        }
        else
        {
            /* supports sip 5 */
            PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_E);
        }
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
    {
        /* supports sip 5_15 */
        PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_15_E);
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
        /* supports sip 5_20 */
        PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_20_E);
    }
    else
    {
        /* we do not hold differentiation between legacy devices */
        PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_LEGACY_E);
        return GT_OK;
    }

    /* set additional flags needed by 'higher' sip version */
    if(PRV_CPSS_SIP_CHECK_MAC(devNum,PRV_CPSS_SIP_5_20_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_15_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,PRV_CPSS_SIP_5_15_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_10_E);
    }

    if(PRV_CPSS_SIP_CHECK_MAC(devNum,PRV_CPSS_SIP_5_10_E))
    {
        PRV_CPSS_SIP_SET_MAC(devNum,PRV_CPSS_SIP_5_E);
    }

    return GT_OK;
}

static GT_U32   debug_force_numOfDp = 0;
void debug_force_numOfDp_set(GT_U32 num)
{
    debug_force_numOfDp = num;
}
static GT_U32   debug_force_numOfPipes = 0;
void debug_force_numOfPipes_set(GT_U32 num)
{
    debug_force_numOfPipes = num;
}

/* local DMAs existing in aldrin DP 0 and 1  */
static const GT_U32 aldrinLocalDma_dp_0_1_Arr[12] = {56, 57, 58, 59, 64, 65, 66, 67, 68, 69, 70, 71};

/* local DMAs existing in aldrin DP 2 */
static const GT_U32 aldrinLocalDma_dp_2_Arr[10] = {56, 57, 58, 59, 64, 65, 66, 67, 62, 72};

/*******************************************************************************
* setSip5FlexInfo
*
* DESCRIPTION:
*       set sip5 flex parameters.
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS setSip5FlexInfo
(
    IN GT_U8    devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;
    GT_U32  isBobkCetus=0;/* indication that this is bobk-cetus */
    GT_U32  ii;/*iterator*/

    /* don't use macro PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC before this line */
    /* in Bobcat2; Caelum; Bobcat3 eArch is supported */
    dxDevPtr->hwInfo.eArch.supported = GT_TRUE;

    dxDevPtr->hwInfo.dfxServer.supported = GT_TRUE;
#ifdef  GM_USED
    /* the GM device not supports the DFX server unit */
    dxDevPtr->hwInfo.dfxServer.supported = GT_FALSE;
#endif  /*GM_USED*/

    dxDevPtr->hwInfo.dedicatedCpuMac.isNotSupported = GT_TRUE;
    dxDevPtr->hwInfo.portMapping.isUsedPortMappingCheck = GT_TRUE;

    dxDevPtr->hwInfo.tti.numDefaultEports = 512;

    dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity = 2;
    dxDevPtr->hwInfo.tcam.maxFloors = 12;

    dxDevPtr->hwInfo.lpm.numOfBlocks = 20;
    dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _16K;
    dxDevPtr->hwInfo.lpm.totalNumOfLinesInBlockIncludingGap = _16K;

    rc = prvCpssDxChSMIInfoByPPSet(devNum);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* single core device */
    dxDevPtr->hwInfo.cpuPortInfo.dmaNumber = 72;

    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).portGroupId = 3;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).trunkId  = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum = 10;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vidx     = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fid      = 13;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fdbUserDefined = 8;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vid      = 13;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).eVidx    = 14;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).stgId    = 12;


    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL3Ecmp  = _12K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _24K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllLtt  = _32K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMll     = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _8K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesOam     = _2K;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTxqQueue = 72*8/*576*/;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesProtectionLoc = _2K;


    if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /*indication about single instance of TAI */
        dxDevPtr->hwInfo.gop_tai.supportSingleInstance = GT_TRUE;
        /*indication that no support for ILKN */
        dxDevPtr->hwInfo.gop_ilkn.supported = GT_FALSE;
        /*indication that LMS unit is not supported.(need to use SMI unit,LED unit)*/
        dxDevPtr->hwInfo.gop_lms.notSupported = GT_TRUE;

        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 9;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).tunnelStartPtr = 16;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    = 14;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).sstId    = 12 ;

        dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity =  2;

        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL3Ecmp  = _4K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _24K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMll     = _32K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _16K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesOam     = _8K;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesTxqQueue = 576*8/*4608*/;
        PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesProtectionLoc = _8K;

        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE)
        {
            /* The GM not support the DFX */
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cnc.cncUploadUseDfxUnit = GT_TRUE;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 8;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).tunnelStartPtr = 15;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    = 13;
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).sstId    = 12;

        dxDevPtr->hwInfo.trafficManager.supported = GT_TRUE;

        if(PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
        {
            /*indication that LMS unit is not supported.(need to use SMI unit,LED unit)*/
            dxDevPtr->hwInfo.gop_lms.notSupported = GT_TRUE;
        }

        if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
        {
            /*indication about single instance of TAI */
            dxDevPtr->hwInfo.gop_tai.supportSingleInstance = GT_TRUE;
            /*indication that no support for ILKN */
            dxDevPtr->hwInfo.gop_ilkn.supported = GT_FALSE;

            /* support 128 physical ports */
            PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort = 7;
            PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).stgId   = 10;

            /* resources that are lower then the 'flex bits' */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = _6K;/*6144*/
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _4K + 512;/*_4.5K = 4608 */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).l2LttMll = _8K;

            /* the HA in table HA Egress Target ePort Attribute Table 1 supports only 14 bits
                although the other places in the pipe supports 15 bits */
            PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).tunnelStartPtr = 14;

            dxDevPtr->hwInfo.tcam.numBanksForHitNumGranularity = 6;

            dxDevPtr->hwInfo.tcam.maxFloors = 6;

            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL2Ecmp  = _4K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesL3Ecmp  = _4K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIpNh    = _8K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMllLtt  = _8K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesMll     = _4K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesIplrMetering = _6K;
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.parametericTables.numEntriesEplrMetering = _4K;
        }
        else
        {
            dxDevPtr->hwInfo.gop_ilkn.supported = GT_TRUE;
        }

    }

    if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        /* the bobcat2 hold sub families */
        if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
        {
            switch(devPtr->devType)
            {
                case CPSS_BOBK_CETUS_DEVICES_CASES_MAC:
                    isBobkCetus = 1;
                    break;
                default:
                    isBobkCetus = 0;
                    break;
            }

            if (isBobkCetus)
            {
                dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _2K;
            }
            else
            {
                dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _6K;
            }


#ifndef GM_USED
/* the GM supports single Data path : single RxDma , TxDma (TxFifo is not emulated anyway) */
            dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
            dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 73;
            dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 74;
            dxDevPtr->hwInfo.multiDataPath.maxDp = 2;
            dxDevPtr->hwInfo.multiDataPath.numTxqDq = 1;
#endif /* ! GM_USED*/
            dxDevPtr->hwInfo.multiDataPath.info[0].dataPathFirstPort  = 0;/*first port*/
            dxDevPtr->hwInfo.multiDataPath.info[0].dataPathNumOfPorts = 48;/* 48 GE ports */
            dxDevPtr->hwInfo.multiDataPath.info[1].dataPathFirstPort  = 56;/*first port*/
            dxDevPtr->hwInfo.multiDataPath.info[1].dataPathNumOfPorts = 16 + 2;/* the CPU,TM */
            dxDevPtr->hwInfo.multiDataPath.info[1].cpuPortDmaNum = 72;
            dxDevPtr->hwInfo.multiDataPath.info[1].tmDmaNum      = 73;
            if (isBobkCetus) /* also for GM distinguish */
            {
                dxDevPtr->hwInfo.multiDataPath.info[0].dataPathNumOfPorts = 0;/* no lower 48 ports */
            }
        }
        else
        if (dxDevPtr->genInfo.devType == CPSS_98DX4253_CNS)
        {
            /* CPSS_98DX4253_CNS Bobcat2 Carrier Small Scale*/
            /* resources that are lower then the 'flex bits' */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).ePort = _6K;/*6144*/
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid   = _4K + 512;/*_4.5K = 4608 */
            PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).l2LttMll = _8K;
            dxDevPtr->hwInfo.gop_ilkn.supported = GT_FALSE;
        }
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
    {
        dxDevPtr->hwInfo.lpm.numOfLinesInBlock = _2K;
        dxDevPtr->hwInfo.trafficManager.supported = GT_FALSE;

#ifndef GM_USED
/* the GM supports single Data path : single RxDma , TxDma (TxFifo is not emulated anyway) */
        dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
        dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 12;
        dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 12;
        dxDevPtr->hwInfo.multiDataPath.maxDp = 3;
        dxDevPtr->hwInfo.multiDataPath.numTxqDq = 1;
        dxDevPtr->hwInfo.multiDataPath.supportRelativePortNum = 1;
#endif /* ! GM_USED*/
        dxDevPtr->hwInfo.multiDataPath.info[0].dataPathFirstPort  = 0; 
        dxDevPtr->hwInfo.multiDataPath.info[0].dataPathNumOfPorts = 12;
        dxDevPtr->hwInfo.multiDataPath.info[0].localDmaMapArr = aldrinLocalDma_dp_0_1_Arr;
        dxDevPtr->hwInfo.multiDataPath.info[1].dataPathFirstPort  = 12;
        dxDevPtr->hwInfo.multiDataPath.info[1].dataPathNumOfPorts = 12;
        dxDevPtr->hwInfo.multiDataPath.info[1].localDmaMapArr = aldrinLocalDma_dp_0_1_Arr;
        dxDevPtr->hwInfo.multiDataPath.info[2].dataPathFirstPort  = 24;
        dxDevPtr->hwInfo.multiDataPath.info[2].dataPathNumOfPorts = 10;
        dxDevPtr->hwInfo.multiDataPath.info[2].localDmaMapArr = aldrinLocalDma_dp_2_Arr;
        dxDevPtr->hwInfo.multiDataPath.info[2].cpuPortDmaNum = 72;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
    {
#ifdef GM_USED
        /* the GM NOT supports multi data path */
        debug_force_numOfDp_set(1);
        /* the GM supports single pipe */
        debug_force_numOfPipes_set(1);
#endif /*GM_USED*/

        dxDevPtr->hwInfo.multiPipe.numOfPipes = 2;
        if(debug_force_numOfPipes)
        {
            dxDevPtr->hwInfo.multiPipe.numOfPipes = debug_force_numOfPipes;
        }

        for(ii = 0 ; ii < dxDevPtr->hwInfo.multiPipe.numOfPipes ; ii++)
        {
            dxDevPtr->hwInfo.multiPipe.pipeInfo[ii].gop_info.gopFirstPort  = ii*36;
            dxDevPtr->hwInfo.multiPipe.pipeInfo[ii].gop_info.gopNumOfPorts = 37; /* one is extra */
        }

        dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 1;
        dxDevPtr->hwInfo.multiDataPath.rxNumPortsPerDp = 13;
        dxDevPtr->hwInfo.multiDataPath.txNumPortsPerDp = 13;
        dxDevPtr->hwInfo.multiDataPath.maxDp = 6;
        dxDevPtr->hwInfo.multiDataPath.numTxqDq = 6;/* there is TXQ,dq per 'data path' */
        dxDevPtr->hwInfo.multiDataPath.txqDqNumPortsPerDp = 96;
        dxDevPtr->hwInfo.multiDataPath.supportRelativePortNum = 1;

        if(debug_force_numOfDp)
        {
            dxDevPtr->hwInfo.multiDataPath.supportMultiDataPath = 0;
            dxDevPtr->hwInfo.multiDataPath.maxDp = debug_force_numOfDp;
            dxDevPtr->hwInfo.multiDataPath.numTxqDq = debug_force_numOfDp;
        }

        for(ii = 0 ; ii < dxDevPtr->hwInfo.multiDataPath.maxDp ; ii++)
        {
            dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathFirstPort  = ii*12;
            dxDevPtr->hwInfo.multiDataPath.info[ii].dataPathNumOfPorts = 12 + 1;/* support CPU port*/
            dxDevPtr->hwInfo.multiDataPath.info[ii].cpuPortDmaNum = 12;
        }

    }

    return GT_OK;
}

/*******************************************************************************
* baseCoreClockSet
*
* DESCRIPTION:
*       set 'baseCoreClock' : base core clock parameter.
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS baseCoreClockSet
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);

    if(devPtr->devFamily == CPSS_PP_FAMILY_CHEETAH_E)
    {
        devPtr->baseCoreClock   = 200;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_CHEETAH2_E)
    {
        devPtr->baseCoreClock   = 220;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        devPtr->baseCoreClock   = 270;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)
    {
        if(devPtr->revision != 0)
        {
            devPtr->baseCoreClock   = 222;
        }
        else
        {
            devPtr->baseCoreClock   = 200;
        }
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        devPtr->baseCoreClock   = 360;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
    {
        devPtr->baseCoreClock   = 360;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        devPtr->baseCoreClock   = 222;
    }
    else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
            devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E ||
            devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E ||
            devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E
            )
    {
        devPtr->baseCoreClock   = 480;
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* initPortTypeArray
*
* DESCRIPTION:
*       initialize phyPortInfoArray[]
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS initPortTypeArray
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);
    GT_U32  port;
    GT_BOOL             devMatched;/* did we matched the device --> use for loop on port types*/
    GT_U32              stackPortsMode = 0;

    /* allocation of physical ports information - phyPortInfoArray */
    devPtr->phyPortInfoArray = (PRV_CPSS_PORT_INFO_ARRAY_STC*)
        cpssOsMalloc(sizeof(PRV_CPSS_PORT_INFO_ARRAY_STC) * devPtr->numOfPorts);

    if (devPtr->phyPortInfoArray == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
    }
    cpssOsMemSet(devPtr->phyPortInfoArray, 0,
                 (sizeof(PRV_CPSS_PORT_INFO_ARRAY_STC) * devPtr->numOfPorts));

    if (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)
    {
        /* get the stacking ports mode*/
        if (prvCpssDrvHwPpGetRegField(devNum,0x00000028,26,4,&stackPortsMode) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* init The port info struct to all ports */
    for (port = 0; port < devPtr->numOfPorts; port++)
    {
        if(!CPSS_PORTS_BMP_IS_PORT_SET_MAC(&devPtr->existingPorts , port))
        {
            /* set the non-exists ports*/
            devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_NOT_EXISTS_E;
                continue;
        }
        devPtr->phyPortInfoArray[port].portType = PRV_CPSS_PORT_GE_E;
        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
        devPtr->phyPortInfoArray[port].vctLengthOffset = 0;
        devPtr->phyPortInfoArray[port].portIfMode = CPSS_PORT_INTERFACE_MODE_NA_E;
        devPtr->phyPortInfoArray[port].portSpeed = CPSS_PORT_SPEED_NA_E;
        devPtr->phyPortInfoArray[port].portSerdesTuningType =
                                                CPSS_PORT_SERDES_TUNING_NONE_E;

        devPtr->phyPortInfoArray[port].portRefClock.enableOverride = GT_FALSE;
        devPtr->phyPortInfoArray[port].portRefClock.portRefClockSource = CPSS_PORT_REF_CLOCK_SOURCE_LAST_E;

        /* initializing port SMI and PHY address DB to indicate that these parameters have */
        /* not been set yet. */
        PRV_CPSS_PHY_SMI_PORT_ADDR_MAC(devNum,port)     = PRV_CPSS_PHY_SMI_NO_PORT_ADDR_CNS;
        PRV_CPSS_PHY_SMI_CTRL_REG_ADDR_MAC(devNum,port) = PRV_CPSS_PHY_SMI_NO_CTRL_ADDR_CNS;
        PRV_CPSS_PHY_SMI_INSTANCE_MAC(devNum,port)      = PRV_CPSS_PHY_INVALIDE_SMI_INSTANCE_CNS;

        /* initializing the SMI interfaces to relevant port group */
        /* Each port's PHY is access by its associated port group's SMI*/
        PRV_CPSS_PHY_SMI_GROUP_PORT_MAC(devNum,port)=
            PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, port);

        devMatched = GT_FALSE;

        switch(devPtr->devType)
        {
            case PRV_CPSS_CHEETAH3_XG_PORTS_DEVICES_CASES_MAC:
                /* Cheetah 3 XG device have only XG ports */
                devPtr->phyPortInfoArray[port].portType =         PRV_CPSS_PORT_XG_E;
                devPtr->phyPortInfoArray[port].portTypeOptions =  PRV_CPSS_XG_PORT_XG_ONLY_E;
                devMatched = GT_TRUE;
            break;
        }

        if(devMatched == GT_TRUE)
        {
            /* port type is already set */
            continue;
        }

        if (port < 24 &&
            devPtr->devFamily != CPSS_PP_FAMILY_DXCH_LION_E &&
            devPtr->devFamily != CPSS_PP_FAMILY_DXCH_LION2_E &&
            (0 == PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
        {
            switch(devPtr->devType)
            {
                case PRV_CPSS_DXCH_XCAT_FE_DEVICES_CASES_MAC:
                case PRV_CPSS_DXCH_XCAT2_FE_DEVICES_CASES_MAC:
                    devPtr->phyPortInfoArray[port].portType =
                        PRV_CPSS_PORT_FE_E;
                    break;
                default:
                    devPtr->phyPortInfoArray[port].portType =
                        PRV_CPSS_PORT_GE_E;
                    break;
            }
        }
        else
        {
           devPtr->phyPortInfoArray[port].portType =        PRV_CPSS_PORT_XG_E;
           devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XG_ONLY_E;

           /* special cases for DX249/269/169 */
           if (devPtr->devType == CPSS_98DX249_CNS ||
               devPtr->devType == CPSS_98DX169_CNS)
           {
               if (port >= 25)
               {
                   devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_HX_QX_ONLY_E;
               }
           }
           else if (devPtr->devType == CPSS_98DX269_CNS)
           {
               if (port == 25)
               {
                   devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_XG_HX_QX_E;
               }
               else if (port == 26)
               {
                   devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_HX_QX_ONLY_E;
               }
           }
           else if((devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E) ||
                   (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E))
           {
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;

                if ((stackPortsMode & (1 << (port - 24))) == 0 )
                {
                    devPtr->phyPortInfoArray[port].portType =
                        PRV_CPSS_PORT_GE_E;
                }

                /* set the device with all ports with XG/DQX/DHX/XAUI  */
                /* in XCAT all flex links XG capable and we can't
                 * restrict application to hard coded order, e.g.: 24,25 - QX
                 * and 26,27 - XG etc. application may want to define 24,25 - XG
                 * and 26,27 - QX */
                /* in XCAT2 stack ports are GE only */
                devPtr->phyPortInfoArray[port].portTypeOptions =
                    (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E) ?
                                                    PRV_CPSS_GE_PORT_GE_ONLY_E :
                                                        PRV_CPSS_XG_PORT_XG_HX_QX_E;

            }/*end of PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E*/
            else if((devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)||
                    (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)||
                    (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E))
            {
                devPtr->phyPortInfoArray[port].portTypeOptions =
                    (devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION_E ||
                     devPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E) ?
                        PRV_CPSS_XG_PORT_XLG_SGMII_E : PRV_CPSS_XG_PORT_CG_SGMII_E;
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
            {
                if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_NONE_E)
                {
                    if(port < 48)
                    {
                        devPtr->phyPortInfoArray[port].portType        = PRV_CPSS_PORT_GE_E;
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_FALSE;
                    }
                    else
                    {
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
                    }
                }
                else if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
                {
                    if((port < 48) || (port == 62))
                    {
                        devPtr->phyPortInfoArray[port].portType        = PRV_CPSS_PORT_GE_E;
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_GE_PORT_GE_ONLY_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_FALSE;
                    }
                    else
                    {
                        devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                        devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
                    }
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
            {
                devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
            }
            else if(devPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
            {
                devPtr->phyPortInfoArray[port].portTypeOptions = PRV_CPSS_XG_PORT_CG_SGMII_E;
                devPtr->phyPortInfoArray[port].isFlexLink = GT_TRUE;
            }
        }/*end of port >= 24 || lion ports */
    }

    return GT_OK;
}
/*******************************************************************************
* initPortMibShadow
*
* DESCRIPTION:
*       initialize portsMibShadowArr[]
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS initPortMibShadow
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;
    GT_U32  port;

    if (devPtr->devFamily != CPSS_PP_FAMILY_DXCH_LION_E &&
        devPtr->devFamily != CPSS_PP_FAMILY_DXCH_LION2_E &&
        devPtr->devFamily != CPSS_PP_FAMILY_DXCH_XCAT3_E &&
        (0 == PRV_CPSS_SIP_5_CHECK_MAC(devNum)))
    {
        /* not needed */
        return GT_OK;
    }

    for (port = 0; port < devPtr->numOfPorts; port++)
    {
        if(!CPSS_PORTS_BMP_IS_PORT_SET_MAC(&devPtr->existingPorts , port))
        {
            /* skip the non-exists ports*/
            continue;
        }

        if((devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION_E) &&
            (PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,port) != 10))
        {
            /* just local port 10 of Lion supports 40G */
            continue;
        }
        /* allocate the memory for the MIB shadow */
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port] =
            cpssOsMalloc(sizeof(PRV_CPSS_DXCH_PORT_XLG_MIB_SHADOW_STC));

        if(PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port] == NULL)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        cpssOsMemSet(PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port],
                     0,sizeof(PRV_CPSS_DXCH_PORT_XLG_MIB_SHADOW_STC));

        /* set "clear on read" for XGL MAC counters default to true */
        PRV_CPSS_DXCH_PP_MAC(devNum)->port.portsMibShadowArr[port]->clearOnReadEnable = GT_TRUE;
    }

    return GT_OK;
}

/*******************************************************************************
* setCncParameters
*
* DESCRIPTION:
*       initialize cnc parameters
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS setCncParameters
(
    IN GT_U8    devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;

        /* CNC parameter initialization */
    switch (devPtr->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 8;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = 512;
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 2;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 16;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _1K;
        break;

        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 8;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = 256;
        break;

        case CPSS_PP_FAMILY_DXCH_LION_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 8;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = 512;
        break;

        case CPSS_PP_FAMILY_DXCH_XCAT_E:
        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 2;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _2K;
        break;

        case CPSS_PP_FAMILY_CHEETAH3_E:
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 1;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 10;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = _2K;
        break;

        default:
            /* the device not supports CNC */
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits = 0;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks = 0;
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries = 0;
            break;
    }

    return GT_OK;
}

/*******************************************************************************
* initRegAddrDb
*
* DESCRIPTION:
*       initialize the DB of 'register address'
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS initRegAddrDb
(
    IN GT_U8    devNum
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxDevPtr = PRV_CPSS_DXCH_PP_MAC(devNum);
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = &dxDevPtr->genInfo;

    /* allocate and fill the values of the registers addresses of the device */
        /* init the registers addresses inside
            PRV_CPSS_EXMX_DEV_REGS_MAC(devNum) and get the number of
           virtual ports */
    switch (devPtr->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            /* this code call to xCat2 specific function */
             rc = prvCpssDxChXcat2HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }

        break;/* end xcat */

        case CPSS_PP_FAMILY_DXCH_LION_E:
            /* this code call to Lion specific function */
             rc = prvCpssDxChLionHwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }

        break;/* end Lion */

        case CPSS_PP_FAMILY_DXCH_LION2_E:
            /* this code call to Lion2 specific function */
             rc = prvCpssDxChLion2HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }
             break;/* end Lion2 */

        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
             rc = prvCpssDxChBobcat2HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }
             break;/* end Bobcat2 */

        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
             /* this code call to xCat3 specific function */
             rc = prvCpssDxChXcat3HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }
             break;/* end xcat3 */

        case CPSS_PP_FAMILY_DXCH_XCAT_E:
             /* this code call to xCat specific function */
             rc = prvCpssDxChXcatHwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }

        break;/* end xcat */

        case CPSS_PP_FAMILY_CHEETAH3_E:
        /* this code call to cheetah3 specific function */
             rc = prvCpssDxCh3HwRegAddrInit(devNum);
             if(rc != GT_OK)
             {
                 return rc;
             }

        break;/* end cheetah3 */

        case CPSS_PP_FAMILY_CHEETAH2_E:
        /* this code call to cheetah2 specific function */
            rc = prvCpssDxCh2HwRegAddrInit(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }

        break;/* end cheetah2 */

        case CPSS_PP_FAMILY_CHEETAH_E:
            /* call to Cheetah specific function */
            rc = prvCpssDxChHwRegAddrInit(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        break;

        default:
            /* we may get here due to improper compilation flag used ! */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_DEVICE_FAMILY_NOT_SUPPORTED_CNS, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* checkMultiPortGroupIndication
*
* DESCRIPTION:
*   For Multi-Group devices check that correct base address per port group as configured.
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       relevant to multi-core device
*
*******************************************************************************/
static GT_STATUS checkMultiPortGroupIndication
(
    IN GT_U8    devNum,
    IN GT_BOOL  pciCompatible,
    IN PRV_CPSS_DRV_PP_PHASE_1_INPUT_INFO_STC  *drvPpPhase1InInfoPtr
)
{
    GT_STATUS           rc;
    GT_U32              portGroupId;/*iterator for port group Id*/
    GT_U32 startBit = PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) ? 21 : 9;
    GT_U32              pgNumOfBits; /* number of bits for Port Group Id */
    GT_U32              port;

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        pgNumOfBits = pciCompatible ? 3 : 5;
    }
    else
    {
        pgNumOfBits = 2;
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        /* The 2 LSbs - bits [10:9] - of field <DevicePhy Addr> - bits [13:9] */
        /* are the port group number.                                         */
        rc = prvCpssDrvHwPpPortGroupGetRegField(devNum, portGroupId,
                                                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                                    globalRegs.globalControl,
                                                startBit, pgNumOfBits, &port);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(pciCompatible)
        {
            if( port != portGroupId )
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
        else
        {/* for SMI devices value of PHY address field must be equal to address,
            where SMI scan found current port group */
            if(port != drvPpPhase1InInfoPtr->busBaseAddr[portGroupId])
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwRegAddrDb
*
* DESCRIPTION:
*       remove the DB of 'register address'
*
* INPUTS:
*       devNum -  the device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwRegAddrDbRemove
(
    IN GT_U8    devNum
)
{
    /* free the registers addresses memory */
    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_CHEETAH_E:
            prvCpssDxChHwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_CHEETAH2_E:
            prvCpssDxCh2HwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_CHEETAH3_E:
            prvCpssDxCh3HwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT_E:
            prvCpssDxChXcatHwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            prvCpssDxChXcat3HwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            prvCpssDxChXcat2HwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_DXCH_LION_E:
            prvCpssDxChLionHwRegAddrRemove(devNum);
            break;
        case CPSS_PP_FAMILY_DXCH_LION2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
            prvCpssDxChLion2HwRegAddrRemove(devNum);
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_DEVICE_FAMILY_NOT_SUPPORTED_CNS, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part1
*
* DESCRIPTION:
*       Part 1 of "phase 1"
*       Performs configures that should be done at the start of "Phase 1" :
*       initialize the cpssDriver
*       build the DB needed for the device
*
*       function called from the "phase 1" sequence.
*
* INPUTS:
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*       multiPortGroupDevice    - indication that the device supposed to be 'multi port groups' device.
*
* OUTPUTS:
*       deviceTypePtr      - (pointer to) The Pp's device type.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_OUT_OF_CPU_MEM - failed to allocate CPU memory,
*       GT_NOT_SUPPORTED - the device not supported by CPSS
*       GT_BAD_VALUE - the driver found unknown device type
*       GT_NOT_IMPLEMENTED - the CPSS was not compiled properly
*       GT_OUT_OF_RANGE - the value is out of range
*
*
* COMMENTS:
*       was called "pre start init"
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part1
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    IN      GT_BOOL                             multiPortGroupDevice,
    OUT     CPSS_PP_DEVICE_TYPE                 *deviceTypePtr
)
{
    GT_STATUS           rc;
    GT_U8               devNum; /* device number of the device */
    GT_U32              port;   /* iterator */
    GT_U32              portGroupId;/*iterator for port group Id*/
    GT_U32              firstActivePortGroupId;/* port group Id for the first active port group */
    GT_U32              metalFixData;
    GT_U32              ttiMetalFixData; /* tunnel termination metal fix register */
    GT_BOOL             legacyVplsModeSupported; /* if legcay VPLS mode is supported in the device */
    GT_U32 fidBitsCount = 0;  /* bits count used to store FID value */
    GT_U32 bmpBytesCount = 0; /* bytes count to store bitmap pointed by bridge.keyModePerFidBmpPtr */
    GT_U32 *bmpPtr = NULL;    /* pointer to a bitmap */
    GT_UINTPTR busBaseAddrAttachKey; /* key for prvCpssPpConfigDevDbBusBaseAddrAttach call */

    /* info needed by the cpssDriver */
    PRV_CPSS_DRV_PP_PHASE_1_INPUT_INFO_STC drvPpPhase1InInfo;
    /* info returned from the cpssDriver */
    PRV_CPSS_DRV_PP_PHASE_1_OUTPUT_INFO_STC drvPpPhase1OutInfo;
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr;/* pointer to common device info */
    PRV_CPSS_DXCH_MODULE_CONFIG_STC *moduleCfgPtr;/* module config of the device */
    GT_BOOL         pciCompatible;
    GT_U32          i = 0;
#ifndef ASIC_SIMULATION
    GT_U32          pllCoreParamsRegData;
#if !defined(CPU_MSYS) && !defined(CPU_MSYS_2_6_32)
    GT_U32          pllCoreConfigRegData;
#endif
    GT_U32          regAddr;
#endif
    devNum = ppPhase1ParamsPtr->devNum;

    /* prepare INPUT info for the cpssDriver */
    drvPpPhase1InInfo.mngInterfaceType = ppPhase1ParamsPtr->mngInterfaceType;

    if(CPSS_CHANNEL_IS_PCI_COMPATIBLE_MAC(ppPhase1ParamsPtr->mngInterfaceType))
    {
        pciCompatible = GT_TRUE;
    }
    else
    {
        pciCompatible = GT_FALSE;
    }

    if(multiPortGroupDevice == GT_FALSE)
    {
        firstActivePortGroupId = 0;
        drvPpPhase1InInfo.busBaseAddr[0] = ppPhase1ParamsPtr->busBaseAddr;
        if(pciCompatible == GT_TRUE)
        {
            drvPpPhase1InInfo.internalPciBase[0] = ppPhase1ParamsPtr->internalPciBase;
        }
        else
        {
            drvPpPhase1InInfo.internalPciBase[0] = 0;/* not relevant - for non PCI */
        }
        drvPpPhase1InInfo.numOfPortGroups = 1; /* non multi-port-group device */
        drvPpPhase1InInfo.hwAddr[0] = ppPhase1ParamsPtr->hwAddr;
    }
    else
    {
        firstActivePortGroupId = 0xFF;
        /* the per port group information taken from ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId] */
        /* NOTE: can't use macro PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
                at this stage because the macro uses DB that was not created yet */
        for(portGroupId = 0 ; portGroupId < ppPhase1ParamsPtr->numOfPortGroups ; portGroupId++)
        {
            drvPpPhase1InInfo.busBaseAddr[portGroupId] = ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].busBaseAddr;
            drvPpPhase1InInfo.hwAddr[portGroupId] = ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].hwAddr;

            if(firstActivePortGroupId == 0xFF &&/*not initialized yet*/
               drvPpPhase1InInfo.busBaseAddr[portGroupId] != CPSS_PARAM_NOT_USED_CNS)/*active port group*/
            {
                firstActivePortGroupId = portGroupId;
            }


            if(pciCompatible == GT_TRUE)
            {
                drvPpPhase1InInfo.internalPciBase[portGroupId] = ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].internalPciBase;
            }
            else
            {
                drvPpPhase1InInfo.internalPciBase[portGroupId] = 0;/* not relevant - for non PCI */
            }
        }

        drvPpPhase1InInfo.numOfPortGroups = ppPhase1ParamsPtr->numOfPortGroups;
    }

    drvPpPhase1InInfo.resetAndInitControllerBase =
                                ppPhase1ParamsPtr->resetAndInitControllerBase;

    drvPpPhase1InInfo.ppHAState = ppPhase1ParamsPtr->ppHAState;

    drvPpPhase1InInfo.devIdLocationType = PRV_CPSS_DRV_DEV_ID_LOCATION_DEVICE_ADDR_0x0000004C_E;

    drvPpPhase1InInfo.isrAddrCompletionRegionsBmp = ppPhase1ParamsPtr->isrAddrCompletionRegionsBmp;
    drvPpPhase1InInfo.appAddrCompletionRegionsBmp = ppPhase1ParamsPtr->appAddrCompletionRegionsBmp;

    /* call cpssDriver to initialize itself - phase 1 */
    rc = prvCpssDrvHwPpPhase1Init(devNum,
                                  &drvPpPhase1InInfo,
                                  &drvPpPhase1OutInfo);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpPhase1Init(..) : return code is %d", rc);
        return rc;
    }
    /* set the out put parameter */
    *deviceTypePtr = drvPpPhase1OutInfo.devType;


    if(! CPSS_IS_DXCH_FAMILY_MAC(drvPpPhase1OutInfo.devFamily))
    {
            /* we got bad value from the cpssDriver !
                that means that there is problem in the cpssDriver or that the
                PP , is not Dx supported device.
            */
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : problem in prvCpssDrvHwPpPhase1Init(..) or PP is not Dx supported device");
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
    }

    /* allocate the memory for the device DB */
    prvCpssPpConfig[devNum] = cpssOsMalloc(sizeof(PRV_CPSS_DXCH_PP_CONFIG_STC));

    if (PRV_CPSS_PP_MAC(devNum) == NULL)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : PRV_CPSS_PP_MAC(devNum) == NULL : GT_OUT_OF_CPU_MEM");
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
    }

    dxCh_prvCpssPpConfig[devNum] = prvCpssPpConfig[devNum];

    /* reset the device DB */
    cpssOsMemSet(PRV_CPSS_PP_MAC(devNum) , 0 ,
                                sizeof(PRV_CPSS_DXCH_PP_CONFIG_STC));

    devPtr = PRV_CPSS_PP_MAC(devNum);
    moduleCfgPtr = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(devNum);
    /*******************************************/
    /* start filling the info to the device DB */
    /*******************************************/
    /* set the device number */
    devPtr->devNum = devNum;

    /* fill info retrieved from the cpssDriver */
    devPtr->devType = drvPpPhase1OutInfo.devType;

    /* Lion2 Hooper support - update hooper revision as descendant of Lion2 B1  */
    switch(devPtr->devType)
    {
        case CPSS_LION2_HOOPER_PORT_GROUPS_0123_DEVICES_CASES_MAC:
            devPtr->revision = (GT_U8)(drvPpPhase1OutInfo.revision + 2);
            break;
        default:
            devPtr->revision = drvPpPhase1OutInfo.revision;
            break;
    }
    devPtr->devFamily = drvPpPhase1OutInfo.devFamily;
    devPtr->numOfPorts = drvPpPhase1OutInfo.numOfPorts;
    devPtr->existingPorts = drvPpPhase1OutInfo.existingPorts;
    devPtr->numOfVirtPorts = devPtr->numOfPorts;

    /* set default CPU port mode to none */
    devPtr->cpuPortMode = CPSS_NET_CPU_PORT_MODE_NONE_E;

    devPtr->devSubFamily = drvPpPhase1OutInfo.devSubFamily;
    /*set the sip version (legacy / 5 / 5_10 / 5_15 /...)*/
    rc = setSipVersion(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : setSipVersion(..) : return code is %d", rc);
        return rc;
    }

    /* Events config */
    if(multiPortGroupDevice == GT_FALSE)
    {
        /* set the device as 'non multi-port-groups' device '*/
        rc = prvCpssNonMultiPortGroupsDeviceSet(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssNonMultiPortGroupsDeviceSet(..) : return code is %d", rc);
            return rc;
        }
        /* from this point on we can start use the macros of:
           PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC,
           PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC
        */

        moduleCfgPtr->ppEventsCfg[CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS].intVecNum = ppPhase1ParamsPtr->intVecNum;
        moduleCfgPtr->ppEventsCfg[CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS].intMask   = ppPhase1ParamsPtr->intMask;

        devPtr->useIsr = (ppPhase1ParamsPtr->intVecNum == CPSS_PP_INTERRUPT_VECTOR_NOT_USED_CNS) ?
                        GT_FALSE : GT_TRUE;

        /* attach the device with it base address , needed to support re-init after
           'shutdown' */
        busBaseAddrAttachKey = devDbBusBaseAddrAttachKeyGet(
                ppPhase1ParamsPtr,
                GT_FALSE /*multiPortGroupDevice*/,
                0 /*firstActivePortGroupId*/);
        rc = prvCpssPpConfigDevDbBusBaseAddrAttach(devNum, busBaseAddrAttachKey);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssPpConfigDevDbBusBaseAddrAttach(..) : return code is %d", rc);
            return rc;
        }
    }
    else
    {
        devPtr->portGroupsInfo.isMultiPortGroupDevice = GT_TRUE;

        devPtr->portGroupsInfo.numOfPortGroups = ppPhase1ParamsPtr->numOfPortGroups;
        for(portGroupId = 0 ; portGroupId < ppPhase1ParamsPtr->numOfPortGroups ; portGroupId++)
        {
            if(ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].busBaseAddr !=
               CPSS_PARAM_NOT_USED_CNS)
            {
                devPtr->portGroupsInfo.activePortGroupsBmp |= (1 << portGroupId);

                if(devPtr->portGroupsInfo.firstActivePortGroup > portGroupId)
                {
                    devPtr->portGroupsInfo.firstActivePortGroup = portGroupId;
                }

                if(devPtr->portGroupsInfo.lastActivePortGroup < portGroupId)
                {
                    devPtr->portGroupsInfo.lastActivePortGroup = portGroupId;
                }
            }
        }

        firstActivePortGroupId = devPtr->portGroupsInfo.firstActivePortGroup;

        /* set the devPtr->portGroupsInfoPtr->cpuPortPortGroupId

           NOTE: 1. Lion: For RGMII should be 3
                 2. For SDMA should be CPSS_PORT_GROUP_UNAWARE_MODE_CNS
                 3. This portGroupId used only for 'cpu port' and not for all networkIf
                    configurations that may use firstActivePortGroup!!!
        */
        if(pciCompatible == GT_TRUE)
        {
            devPtr->portGroupsInfo.cpuPortPortGroupId       = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
        }
        else/* non PCI/PEX */
        {
            if(CPSS_PP_FAMILY_DXCH_LION_E == drvPpPhase1OutInfo.devFamily)
            {
            devPtr->portGroupsInfo.cpuPortPortGroupId       = LION_RGMII_PORT_GROUP_ID_CNS;

            /* check that this port group is active ... */
            if (0==(devPtr->portGroupsInfo.activePortGroupsBmp
                   & (1 <<devPtr->portGroupsInfo.cpuPortPortGroupId)))
            {
                /* the needed port group is not active , so can't be used for RGMII */
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : the needed port group is not active , so can't be used for RGMII");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
        }

        devPtr->portGroupsInfo.auqPortGroupIdLastServed = firstActivePortGroupId;
        devPtr->portGroupsInfo.fuqPortGroupIdLastServed = firstActivePortGroupId;
        devPtr->portGroupsInfo.secureBreachNextPortGroupToServe = firstActivePortGroupId;
        devPtr->portGroupsInfo.ptpNextPortGroupToServe = firstActivePortGroupId;


        /* from this point on we can start use the macros of:
           PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC,
           PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC
        */

        devPtr->useIsr = GT_FALSE;

        /* the per port group information taken from ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId] */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            moduleCfgPtr->ppEventsCfg[portGroupId].intVecNum  = ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].intVecNum;
            moduleCfgPtr->ppEventsCfg[portGroupId].intMask    = ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].intMask;
            if(ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].intVecNum != CPSS_PP_INTERRUPT_VECTOR_NOT_USED_CNS)
            {
                /* at least one active port group , needs the ISR */
                devPtr->useIsr = GT_TRUE;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

        /* attach the device with it base address , needed to support re-init after
           'shutdown' */
        /* NOTE: we use a 'designated' for a 'multi-port-groups' device base address , to identify the device .
                 so we not need to change implementation */
        busBaseAddrAttachKey = devDbBusBaseAddrAttachKeyGet(
                ppPhase1ParamsPtr,
                GT_TRUE /*multiPortGroupDevice*/,
                firstActivePortGroupId);
        rc = prvCpssPpConfigDevDbBusBaseAddrAttach(devNum, busBaseAddrAttachKey);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssPpConfigDevDbBusBaseAddrAttach(..) : return code is %d", rc);
            return rc;
        }
    }

    /* set this device to support the "DxCh" functions */
    devPtr->functionsSupportedBmp = PRV_CPSS_DXCH_FUNCTIONS_SUPPORT_CNS;
    devPtr->appDevFamily = CPSS_CH1_E;
    if (drvPpPhase1OutInfo.devType == CPSS_98DX106_CNS)
    {
        devPtr->appDevFamily = CPSS_CH1_DIAMOND_E;
    }

    PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) = 31;
    PRV_CPSS_DXCH_PP_HW_INFO_L2I_MAC(devNum).supportIngressRateLimiter = GT_TRUE;

    /* flexFieldNumBitsSupport default values */
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort  = 6;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).trunkId  = 7;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).ePort    =
        PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort;/*for checking purposes ePort=phyPort*/
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vid      = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vidx     = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).eVidx    = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum = 5;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).sstId    = 5;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).stgId    = 8;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).tunnelStartPtr = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fid      = 12;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fdbUserDefined = 4;
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).portGroupId = 2;

    /* eArch is not supported by default */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.eArch.supported = GT_FALSE;

    /* VPLS mode is not supported by default */
    PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_MAC(devNum).supported = GT_FALSE;
    PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_MAC(devNum).enabled = GT_FALSE;

    metalFixData = 0;
    ttiMetalFixData = 0;
    if (PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily
        == CPSS_PP_FAMILY_DXCH_XCAT_E)
    {
        /* save power on metal fix register           */
        /* needed for xCat A3 revision identification */
        rc = prvCpssDrvHwPpReadRegister(
            devNum, 0x54, /* must use here number, because reg's DB init is latter */
            &metalFixData);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpReadRegister(..) : return code is %d", rc);
            return rc;
        }

        /* If xCat C0 device set value of to ttiMetalFixData 1 */
         /* needed for xCat C0 revision identification */
        rc =  prvCpssDrvHwPpReadRegister(devNum,
                                         0x0C0002B0, /* TTI Metal Fix Register */
                                         &ttiMetalFixData);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpReadRegister(..) : return code is %d", rc);
            return rc;
        }

    }
    else if (PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily
             == CPSS_PP_FAMILY_CHEETAH3_E)
    {
        /* If dxCh3 B2 device set value to 1 */
        rc =  prvCpssDrvHwPpGetRegField(devNum,
                                        0x780000C, /* BM MPPM configuration register */
                                        16, 1, &metalFixData);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpGetRegField(..) : return code is %d", rc);
            return rc;
        }
    }

    /* default value for devices other then XCAT or dxCh3 B2 is 0 */
    PRV_CPSS_DXCH_PP_HW_INFO_MG_MAC(devNum).metalFix = metalFixData;

    /* default value for devices other then xCat C0 is 0 */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.tti.metalFix = ttiMetalFixData;

    /* dedicated MAC for CPU port */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dedicatedCpuMac.isNotSupported = GT_FALSE;

    /* port mapping related configurations */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.portMapping.isUsedPortMappingCheck = GT_FALSE;

    /* the device not supports DFX server unit */
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported = GT_FALSE;
    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.dmaNumber = CPSS_CPU_PORT_NUM_CNS;


    if ((drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
        (devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E))
    {
        /* define which units exist in MG (Caelum units that does not exists in Cetus) */

        switch (PRV_CPSS_PP_MAC(devNum)->devType)
        {
            case CPSS_BOBK_CETUS_DEVICES_CASES_MAC:

                rc =  prvCpssDrvHwPpWriteRegister(devNum, 0xe4, 0xfb7fffff);
                if(rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpWriteRegister(..) : return code is %d", rc);
                    return rc;
                }

                rc =  prvCpssDrvHwPpWriteRegister(devNum, 0xe8, 0xffffff31);
                if(rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpWriteRegister(..) : return code is %d", rc);
                    return rc;
                }

                rc =  prvCpssDrvHwPpWriteRegister(devNum, 0xec, 0xff3fffff);
                if(rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpWriteRegister(..) : return code is %d", rc);
                    return rc;
                }

                break;
            default:
                break;
        }
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_CHEETAH2_E)
    {
        /* set this device ALSO support the "Cheetah 2" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH2_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_CH2_E;
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
    {
        /* set this device ALSO support the "Cheetah 3" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH3_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_CH3_E;
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_XCAT_E)
    {
        /* set this device ALSO support the "DxCh xCat" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_XCAT_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_XCAT_E;

        legacyVplsModeSupported = GT_FALSE;

        switch(drvPpPhase1OutInfo.devFamily)
        {
        case CPSS_PP_FAMILY_DXCH_XCAT_E:
            if(PRV_CPSS_DXCH_XCAT_C0_ONLY_CHECK_MAC(devNum))
            {
                legacyVplsModeSupported = GT_TRUE;
            }
            break;

        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            legacyVplsModeSupported = GT_TRUE;
            break;

        default:
            break;
        }

        if(legacyVplsModeSupported == GT_TRUE)
        {
            /* don't use macro PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_SUPPORTED_MAC before this line */
            /* in xCat C0 and xCat3 Legacy VPLS mode is supported */
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.legacyVplsMode.supported = GT_TRUE;

            /* if the device support Legacy VPLS mode and application wants to enable Legacy VPLS mode on the device
               then Legacy VPLS mode will be globaly enabled */
            if (ppPhase1ParamsPtr->enableLegacyVplsModeSupport == GT_TRUE)
            {
                /* don't use macro PRV_CPSS_DXCH_PP_HW_INFO_VPLS_MODE_ENABLED_MAC before this line */
                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.legacyVplsMode.enabled = GT_TRUE;
            }
        }
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        /* set this device ALSO support the "DxCh xCat3" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_XCAT3_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_XCAT3_E;

        if(drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
        {
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported = GT_TRUE;
        }
    }

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_LION_E)
    {
        /* set this device ALSO support the "DxCh Lion" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_LION_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_LION_E;

        /* L2I not support rate limiter */
        PRV_CPSS_DXCH_PP_HW_INFO_L2I_MAC(devNum).supportIngressRateLimiter = GT_FALSE;

        /* TXQ upgraded */
        PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).revision = 1;

        /* bit index 63 for cpu port */
        PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) = 63;

        switch(drvPpPhase1OutInfo.devFamily)
        {
            case CPSS_PP_FAMILY_DXCH_XCAT2_E:

                /* TXQ revision */
                PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).revision = 0;

                /* L2I support rate limiter */
                PRV_CPSS_DXCH_PP_HW_INFO_L2I_MAC(devNum).supportIngressRateLimiter = GT_TRUE;

                PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).vidx     = 10;

                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported = GT_TRUE;

                break;
            case CPSS_PP_FAMILY_DXCH_LION2_E:
                /* for Lion2 - 4 port groups - allow supportDualDeviceId as FALSE */
                if( (sysGenGlobalInfo.supportDualDeviceId == GT_FALSE) &&
                    (PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp > 0x0F) )
                {
                    /* this device can only work in 'dual device system' as it is 'dual deviceId device' */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).portGroupId = 3;

                PRV_CPSS_DXCH_PP_MAC(devNum)->diagInfo.tcamParityCalcEnable = ppPhase1ParamsPtr->tcamParityCalcEnable;

                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported = GT_TRUE;
#ifdef  GM_USED
                CPSS_TBD_BOOKMARK
                /* the Lion2 GM device currently not supports the DFX server unit */
                PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported = GT_FALSE;
#endif  /*GM_USED*/

                break;

            case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
                rc = setSip5FlexInfo(devNum);
                if(rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : setSip5FlexInfo(..) : return code is %d", rc);
                    return rc;
                }

                break;
                /* ADD HERE new devices that need to override parameters (like we have for Lion) */
            default:
                break;
        }

    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts =
        PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PHY_PORT_MAC(devNum) + 1;

    /* the arp is always muxed with tunnel start but with extra 2 bits */
    PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).arpPtr =
        2 + PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).tunnelStartPtr;

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* set this device ALSO support the "DxCh xCat2" functions */
        devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_XCAT2_FUNCTIONS_SUPPORT_CNS;
        devPtr->appDevFamily = CPSS_XCAT2_E;
    }

    /* default is one TXQ unit */
    PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).txqUnitsNum = 1;

    if(drvPpPhase1OutInfo.devFamily >= CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* init the Lion2 device depending on number of activePortGroupsBmp - 8/4 port groups
           - txqUnitsNum - number of TXQ units
           - numOfPorts -  for Lion2 4 port groups is 60 and for Lion2 8 port groups it is initialized from the CPSS DB(124)*/

        if(multiPortGroupDevice == GT_TRUE)
        {
            if ( PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp > 0x0F )
            { /* Lion2 and Lion3 - 5 and more active port groups */
                  PRV_CPSS_DXCH_PP_HW_INFO_TXQ_MAC(devNum).txqUnitsNum = 2;
            }
            else
            { /* Lion2 and Lion3 - 4 and less active port groups */
                devPtr->numOfVirtPorts = devPtr->numOfPorts = 60;
            }
        }

        if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
        {
            /* set this device ALSO support the "DxCh Lion2" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_LION2_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_LION2_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            if(devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                 /* set this device ALSO support the "DxCh Caelum" functions */
                devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_CAELUM_FUNCTIONS_SUPPORT_CNS;
                devPtr->appDevFamily = CPSS_CAELUM_E;
            }
            else
            {
                 /* set this device ALSO support the "DxCh Bobcat2" functions */
                devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_BOBCAT2_FUNCTIONS_SUPPORT_CNS;
                devPtr->appDevFamily = CPSS_BOBCAT2_E;
            }
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
        {
            /* use Caelum APIs so far */
            CPSS_TBD_BOOKMARK_ALDRIN

            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_CAELUM_FUNCTIONS_SUPPORT_CNS;
            devPtr->appDevFamily = CPSS_CAELUM_E;
        }
        else if (drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
        {
             /* set this device ALSO support the "DxCh Bobcat3" functions */
            devPtr->functionsSupportedBmp |= PRV_CPSS_DXCH_BOBCAT3_FUNCTIONS_SUPPORT_CNS;
            /* TBD - CPSS_BOBCAT3_E ...
               but for now allow bobcat3 use all bobcat2 APIs ! */
            devPtr->appDevFamily = CPSS_BOBCAT3_E;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* multi port group device BUT with single FDB instance (not per port group) */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_TRUE;
    }
    else if(PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* multi port group device with FDB per port group */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_FALSE;
    }
    else
    {
        /* device without port groups --> single FDB instance */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.supportSingleFdbInstance = GT_TRUE;
    }

    /* sets HW interface parameters , only after this point you can use the
        PRV_CPSS_HW_IF_PCI_COMPATIBLE_MAC , to know that the device is PCICompatible*/
    rc = prvCpssHwIfSet(devNum,ppPhase1ParamsPtr->mngInterfaceType);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssHwIfSet(..) : return code is %d", rc);
        return rc;
    }

    /* save HW devNum to the DB */
    PRV_CPSS_HW_DEV_NUM_MAC(devNum) = devNum;

    /* must be done before doing any busy wait on a device  */
    if (CPSS_CHANNEL_IS_PCI_COMPATIBLE_MAC(ppPhase1ParamsPtr->mngInterfaceType))
    {
        devPtr->maxIterationsOfBusyWait =
            66000000;/* 66 million for PCI bus with rate of 66MHz ,
                        and every read operation is about 2 clocks
                        give us about 2 second.
                        For PEX x1 it give us about 1 second */
    }
    else
    {
        switch(ppPhase1ParamsPtr->mngInterfaceType)
        {
            case CPSS_CHANNEL_SMI_E:
            case CPSS_CHANNEL_TWSI_E:
                devPtr->maxIterationsOfBusyWait =
                    78125; /* For SMI MDC 20Mhz the read/write register longs
                             then near 12.8 micro seconds.
                             78125 read registers give us about 1 second */
                break;
            default:
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : ppPhase1ParamsPtr->mngInterfaceType == %d : GT_BAD_PARAM", ppPhase1ParamsPtr->mngInterfaceType);
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }
#ifdef GM_USED
    /* the GM is heavy and query into the GM takes it's own time.
       no need more the 30 iterations , to understand 'not done' */
    devPtr->maxIterationsOfBusyWait = 30;
#elif defined ASIC_SIMULATION
    /* the simulation devices also need to do wait with sleep between iterations
        so the other task that should finish the triggered action can finish */
    devPtr->maxIterationsOfBusyWait = 500; /* with the 10 mili sleep between iterations --> 5 seconds */
#endif /*ASIC_SIMULATION*/

    /* set 'baseCoreClock' : base core clock parameter. */
    rc = baseCoreClockSet(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : baseCoreClockSet(..) : return code is %d", rc);
        return rc;
    }

    /* check if core clock needed to be read from hardware */
    rc = hwPpAutoDetectCoreClock(devNum,&(devPtr->coreClock));
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : hwPpAutoDetectCoreClock(..) : return code is %d", rc);
        return rc;
    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->port.serdesRefClock = ppPhase1ParamsPtr->serdesRefClock;

    /* initialize all the WA that needed for the device */
    rc = hwPpPhase1NeededWaSettings(devNum);
    if (rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : hwPpPhase1NeededWaSettings(..) : return code is %d", rc);
        return rc;
    }


    /* initialize phyPortInfoArray[] */
    rc = initPortTypeArray(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initPortTypeArray(..) : return code is %d", rc);
        return rc;
    }

    /* initialize portsMibShadowArr[] */
    rc = initPortMibShadow(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initPortMibShadow(..) : return code is %d", rc);
        return rc;
    }

    /* initialize info about those PP's family */
    if(prvCpssFamilyInfoArray[devPtr->devFamily] == NULL)
    {
        /* this family was not initialized yet */
        prvCpssFamilyInfoArray[devPtr->devFamily] =
            cpssOsMalloc(sizeof(PRV_CPSS_FAMILY_INFO_STC));

        if(prvCpssFamilyInfoArray[devPtr->devFamily] == NULL)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssFamilyInfoArray[devPtr->devFamily] == NULL : GT_OUT_OF_CPU_MEM");
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }

        cpssOsMemSet(prvCpssFamilyInfoArray[devPtr->devFamily],
                        0,sizeof(PRV_CPSS_FAMILY_INFO_STC));

        prvCpssFamilyInfoArray[devPtr->devFamily]->numReferences = 1;

        /* initialize specific family trunk info */
        prvCpssDxChTrunkFamilyInit(devPtr->devFamily);
    }
    else
    {
        prvCpssFamilyInfoArray[devPtr->devFamily]->numReferences++;
    }

    rc = setCncParameters(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : setCncParameters(..) : return code is %d", rc);
        return rc;
    }


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* There are two non-trunk members tables in devices. First small
           one is used for cascade trunks only and second one for regular trunks. */
        PRV_CPSS_DXCH_PP_HW_INFO_TRUNK_MAC(devNum).useNonTrunkMembers2Table = GT_TRUE;
        PRV_CPSS_DXCH_PP_HW_INFO_TRUNK_MAC(devNum).useNonTrunkMembers1TableAsCascade = GT_TRUE;
        PRV_CPSS_DXCH_PP_HW_INFO_TRUNK_MAC(devNum).nonTrunkTable1NumEntries = 256;
    }

    /*initialize the DB of 'register address'*/
    rc = initRegAddrDb(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : initRegAddrDb(..) : return code is %d", rc);
        return rc;
    }

    if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /*NOTE: this parameter is relevant only to SIP_5_20 devices ,
          because we have HW configuration for it */
        rc = internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet(devNum,ppPhase1ParamsPtr->maxNumOfPhyPortsToUse);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
        }
    }

#ifndef ASIC_SIMULATION
    if ((drvPpPhase1OutInfo.devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E) &&
        (devPtr->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E))
    {
#if !defined(CPU_MSYS) && !defined(CPU_MSYS_2_6_32)

        /* WA is needed only for external CPU.
           For internal CPU it will be implemented in binary header (UBOOT) */
        {
            if (devPtr->coreClock == 25) /* PLL in BYPASS mode */
            {
                /* if application does not configured PLL core clock, WA can not be executed */
                if(ppPhase1ParamsPtr->coreClock == CPSS_DXCH_AUTO_DETECT_CORE_CLOCK_CNS)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : ppPhase1ParamsPtr->coreClock == CPSS_DXCH_AUTO_DETECT_CORE_CLOCK_CNS : GT_BAD_STATE");
                    cpssOsPrintf("\n\nCore_PLL_WA: Please configure desired PLL core clock for configuration \n\n");
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                devPtr->coreClock = ppPhase1ParamsPtr->coreClock;
                cpssOsPrintf("\n\nCore_PLL_WA:Manual Core CLock = %d\n\n", devPtr->coreClock);

                /********************/
                /* Bobk Core PLL WA */
                /********************/
                if( (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)) &&
                    (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE) )
                {
                    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreParameters;
                    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &pllCoreParamsRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerReadReg(..) : return code is %d", rc);
                        return rc;
                    }

                    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreConfig;
                    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &pllCoreConfigRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerReadReg(..) : return code is %d", rc);
                        return rc;
                    }

                    switch(devPtr->coreClock)
                    {
                        case 365:
                            /*
                                Core PLL (730 MHz)
                                i.   bit[2:0] K div = 0x3 ( k = 4)
                                ii.  bit [11:3]  M div = 2 ( m = 3)
                                iii. bit [20:12] N_div = 350 ( N = 351)
                                iv.  bit[24:21] VCO band = 0xB
                                v.   bit [28:25]  LPF  = 1
                                vi.  bit[31:29] Iadj = 1
                            */
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 3);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 2);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 350);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 11);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 1);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                            break;

                        case 250:

                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 3);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 0);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 79);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 6);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 4);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                            break;

                        case 200:

                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 3);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 0);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 63);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 5);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 4);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                            break;

                        case 167:

                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 0,  3, 2);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 3,  9, 1);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 12, 9, 106);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 21, 4, 3);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 25, 4, 4);
                            U32_SET_FIELD_MAC(pllCoreParamsRegData, 29, 3, 1);

                            break;

                        default:
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : devPtr->coreClock == %d : GT_BAD_STATE", devPtr->coreClock);
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                    }

                    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreParameters;
                    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, pllCoreParamsRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerWriteReg(..) : return code is %d", rc);
                        return rc;
                    }

                    /*
                        i.  bit 0 core bypass   = 0
                        ii. bit 9 core Use RF Configuration  = 1
                        iii.    bit [30:11]  = 0
                    */
                    U32_SET_FIELD_MAC(pllCoreConfigRegData, 9,  1,  1);
                    U32_SET_FIELD_MAC(pllCoreConfigRegData, 11, 20, 0);

                    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreConfig;
                    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, pllCoreConfigRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerWriteReg(..) : return code is %d", rc);
                        return rc;
                    }

                    U32_SET_FIELD_MAC(pllCoreConfigRegData, 0,  1,  0);
                    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, pllCoreConfigRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerWriteReg(..) : return code is %d", rc);
                        return rc;
                    }

                    /* Wait 1 ms for core PLL stabilization */
                    cpssOsTimerWkAfter(1);

                    /* Generate Soft reset */
                    rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E, GT_TRUE);
                    if(GT_OK != rc)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : cpssDxChHwPpSoftResetSkipParamSet(..) : return code is %d", rc);
                        return rc;
                    }

                    isResetDbEnabled = GT_FALSE;
                    rc = cpssDxChHwPpSoftResetTrigger(devNum);
                    if(GT_OK != rc)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : cpssDxChHwPpSoftResetTrigger(..) : return code is %d", rc);
                        return rc;
                    }
                    isResetDbEnabled = GT_TRUE;
                }
            }
        }
#else
        {
            if (devPtr->coreClock == 25) /* PLL in BYPASS mode */
            {

                if( (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum)) &&
                    (PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_TRUE) )
                {
                    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnits.DFXServerRegs.PLLCoreParameters;
                    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &pllCoreParamsRegData);
                    if (rc != GT_OK)
                    {
                        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDrvHwPpResetAndInitControllerReadReg(..) : return code is %d", rc);
                        return rc;
                    }

                    switch(U32_GET_FIELD_MAC(pllCoreParamsRegData, 12, 9))
                    {
                        case 106:
                            devPtr->coreClock = 167;
                            break;

                        case 63:
                            devPtr->coreClock = 200;
                            break;

                        case 79:
                            devPtr->coreClock = 250;
                            break;

                        case 350:
                            devPtr->coreClock = 365;
                            break;

                        default:
                            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : U32_GET_FIELD_MAC(..) : GT_BAD_STATE");
                            cpssOsPrintf("Internal CPU WA error: illegal pllCoreParamsRegData configuration = %d\n", U32_GET_FIELD_MAC(pllCoreParamsRegData, 12, 9));
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                    }
                }
                else
                {
                    devPtr->coreClock = 365;
                }
            }
        }
#endif
    }
#endif



    /* For Multi-Group devices check that correct base address per port group as configured */
    if(PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        rc = checkMultiPortGroupIndication(devNum,pciCompatible,&drvPpPhase1InInfo);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : checkMultiPortGroupIndication(..) : return code is %d", rc);
            return rc;
        }
    }

    /* bind SMI related functions */
    prvCpssDxChPhySmiObjInit(devNum);

    /* initialize port ifMode configuration method */
    rc = prvCpssDxChPortIfCfgInit(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : prvCpssDxChPortIfCfgInit(..) : return code is %d", rc);
        return rc;
    }

    /* initialize only cpssDriver for HW access, skip the rest */
    if (dxChInitRegDefaults == GT_TRUE)
        return GT_OK;

#ifdef DEBUG_OPENED
    /* check that all enum value also appear in the 'strings' for debug */
    if(errataNames[PRV_CPSS_DXCH_ERRATA_MAX_NUM_E] == NULL ||
       cpssOsStrCmp(errataNames[PRV_CPSS_DXCH_ERRATA_MAX_NUM_E] , "--last one--"))
    {
        /* don't fail the initialization , only prompt about the problem */
        DUMP_PRINT_MAC(("hwPpPhase1Part1: errataNames[] not filled with all names properly \n"));
    }
#endif /*DEBUG_OPENED*/

    /* init counters modes*/
    for (i = 0; i < 2; i++)
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->portGroupsExtraInfo.bridgeIngressCntrMode[i].portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
        PRV_CPSS_DXCH_PP_MAC(devNum)->portGroupsExtraInfo.portEgressCntrModeInfo[i].portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    }
    PRV_CPSS_DXCH_PP_MAC(devNum)->portGroupsExtraInfo.cfgIngressDropCntrMode.portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    /* bind the system recovery hamdling functions */
    prvCpssSystemRecoveryMsgDisableModeHandleFuncPtr = prvCpssDxChSystemRecoveryDisableModeHandle;
    prvCpssSystemRecoveryCatchUpHandleFuncPtr = prvCpssDxChSystemRecoveryCatchUpHandle;

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        for (port = 0; port < devPtr->numOfPorts; port++)
        {
            /* use XSMI#0 controller to access port's PHY*/
            PRV_CPSS_PHY_XSMI_PORT_INTERFACE_MAC(devNum, port) =
                    CPSS_PHY_XSMI_INTERFACE_0_E;
        }

        /* allocate memory for the keyModePerFidBmpPtr */
        fidBitsCount = PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).fid;
        if (fidBitsCount > 32 || fidBitsCount < 5)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : fidBitsCount == %d : GT_OUT_OF_RANGE", fidBitsCount);
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        bmpBytesCount = 1 << (fidBitsCount-3); /* is always multiple to 4(GT_U32) if fidBitsCount >= 5 */
        bmpPtr = (GT_U32*) cpssOsMalloc(bmpBytesCount);
        if (NULL == bmpPtr)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : bmpPtr == NULL : GT_OUT_OF_CPU_MEM");
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
        }
        cpssOsMemSet(bmpPtr, 0, bmpBytesCount);
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.keyModePerFidBmpPtr = bmpPtr;
    }

    return GT_OK;
}


/*******************************************************************************
* hwPpPhase1Part2Config
*
* DESCRIPTION:
*       This function performs basic hardware configurations on the given PP, in
*       Hw registration phase.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Config
(
    IN      GT_U8                                   devNum
)
{
    /* CPU enable           */
    return prvCpssDrvHwPpSetRegField(devNum,
                                 PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.
                                 globalControl,1,1,1);
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_ch1_ch2
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given PP. - ch1,2
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_ch1_ch2
(
    IN      GT_U8                                   devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    fineTuningPtr->tableSize.fdb                        = _16K;

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH_E)
    {
        fineTuningPtr->tableSize.routerArp                  = _1K;

        /* CH/CH+ devices does not have TTI, TS, MLL and Router TCAM */
        fineTuningPtr->tableSize.tunnelStart                = 0;
        fineTuningPtr->tableSize.router                     = 0;
        fineTuningPtr->tableSize.tunnelTerm                 = 0;
        fineTuningPtr->tableSize.mllPairs                   = 0;
    }
    else
    {
        fineTuningPtr->tableSize.routerArp                  = _4K; /* ARP entries = 4 * TS entries */
        fineTuningPtr->tableSize.tunnelStart                = _1K; /* 1K TS entries */
        fineTuningPtr->tableSize.router                     = _1K;
        fineTuningPtr->tableSize.tunnelTerm                 = _1K;
        fineTuningPtr->tableSize.mllPairs                   = _1K;
    }

    fineTuningPtr->tableSize.routerNextHop              = _4K;
    fineTuningPtr->tableSize.ecmpQos                    = 0;
    fineTuningPtr->tableSize.policyTcamRaws             = 512;/* 512*2 --> '1K short rules' */
    fineTuningPtr->tableSize.cncBlocks                  = 0;
    fineTuningPtr->tableSize.transmitDescr              = 0;
    fineTuningPtr->tableSize.bufferMemory               = 0;

    fineTuningPtr->tableSize.vidxNum                    = VIDX_NUM_CNS;/* 0..0xffe */
    fineTuningPtr->tableSize.stgNum                     = STG_NUM_CNS;
    fineTuningPtr->tableSize.policersNum                = 256;
    fineTuningPtr->tableSize.trunksNum                  = TRUNKS_127_NUM_CNS;
    fineTuningPtr->tableSize.txQueuesNum                = TX_QUEUE_NUM_8_CNS;
    fineTuningPtr->tableSize.lpmRam                     = 0;
    fineTuningPtr->tableSize.bpePointToPointEChannels   = 0;

    if(((PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX163_CNS) ||
        (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX243_CNS) ||
        (PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX262_CNS))&&
       (PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
           PRV_CPSS_DXCH_RM_FDB_TABLE_ENTRIES_WA_E) == GT_FALSE))
    {
        fineTuningPtr->tableSize.fdb = _8K;
    }
    else if(PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX106_CNS)
    {
        fineTuningPtr->tableSize.fdb = _8K;
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_ch3
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given PP. -- ch3
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_ch3
(
    IN      GT_U8                                   devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    fineTuningPtr->tableSize.fdb                        = _32K;
    fineTuningPtr->tableSize.tunnelStart                = _4K; /* 4K TS entries */
    fineTuningPtr->tableSize.routerArp                  = _16K;/* ARP entries = 4 * TS entries */
    fineTuningPtr->tableSize.router                     = _5K; /* 5K --> '20k short rules' */
    fineTuningPtr->tableSize.tunnelTerm                 = _5K;
    fineTuningPtr->tableSize.routerNextHop              = _16K;
    fineTuningPtr->tableSize.ecmpQos                    = 0;
    fineTuningPtr->tableSize.mllPairs                   = _4K; /*8K MLLs*/
    fineTuningPtr->tableSize.policyTcamRaws             = 3584;/*3.5K --> '14K short rules' */
    fineTuningPtr->tableSize.cncBlocks                  = 10;/* 10 blocks of 2K counters */
    fineTuningPtr->tableSize.cncBlockNumEntries         = _2K;/*each CNC block is 2K entries*/
    fineTuningPtr->tableSize.transmitDescr              = _12K;
    fineTuningPtr->tableSize.bufferMemory               = _24M;

    fineTuningPtr->tableSize.vidxNum                    = VIDX_NUM_CNS;/* 0..0xffe */
    fineTuningPtr->tableSize.stgNum                     = STG_NUM_CNS;

    fineTuningPtr->tableSize.policersNum                = _1K;/*1K meters and another 1K counters*/
    fineTuningPtr->tableSize.trunksNum                  = TRUNKS_127_NUM_CNS;
    fineTuningPtr->tableSize.txQueuesNum                = TX_QUEUE_NUM_8_CNS;
    fineTuningPtr->tableSize.lpmRam                     = 0;
    fineTuningPtr->tableSize.bpePointToPointEChannels   = 0;

    fineTuningPtr->featureInfo.vlanTranslationSupported = GT_TRUE;

    /* POLICY TCAM  size */
    rc = prvCpssDrvHwPpSetRegField(
        devNum,
        PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.pclRegs.pclTcamConfig0,
        1, 4, 0);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* ROUTER TCAM size */
    rc = prvCpssDrvHwPpSetRegField(
        devNum,
        PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.ipRegs.ipTcamConfig0,
        1, 4, 0);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* Fix for device revision B2 */
    if( 1 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.mg.metalFix )
    {
        /* Inaccurate Policing Traffic Metering. (FEr#2089) */
        rc = prvCpssDrvHwPpSetRegField(devNum, 0xC00011C, 0, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_common
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       any device with features set in table format.
*
* APPLICABLE DEVICES:
*        xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3.
*
* INPUTS:
*       devNum  - The PP's device number.
*       tablesSize - number of elements in the 'fine tunning' table array(parameter tablePtr)
*       tablePtr - (array of) the table with the 'fine tuning' parameters
*       bufferMemoryTableSize - number of elements in the 'buffer memory' table array(parameter bufferMemoryTablePtr)
*       bufferMemoryTablePtr - (array of) the table with the 'buffer memory' parameters
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_NOT_SUPPORTED - the device not found in the DB
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_common
(
    IN GT_U8   devNum,
    IN GT_U32  tablesSize,
    IN FINE_TUNING_STC *tablePtr,
    IN GT_U32  bufferMemoryTableSize,
    IN FINE_TUNING_BUFFER_MANAGEMENT_PARAMS_STC *bufferMemoryTablePtr
)
{
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;
    GT_U32  ii,jj;/*iterators*/
    GT_BOOL found = GT_FALSE;
    GT_U32  totalCncCountersNeeded;
    GT_U32  tmpValue;/* temp value */

    /* first set the 'Fine tuning' parameters , from the DB */
    for(ii = 0 ; ii < tablesSize ; ii++)
    {
        for(jj = 0 ; tablePtr[ii].devTypePtr[jj] != LAST_DEV_IN_LIST_CNS ; jj++)
        {
            if(tablePtr[ii].devTypePtr[jj] == PRV_CPSS_PP_MAC(devNum)->devType)
            {
                /* found the device type */

                /* copy it's info */
                fineTuningPtr->tableSize = tablePtr[ii].config.tableSize;

                fineTuningPtr->featureInfo = tablePtr[ii].config.featureInfo;

                found = GT_TRUE;
                break;
            }
        }

        if(found == GT_TRUE)
        {
            break;
        }
    }

    if(found == GT_FALSE)
    {
        /* the device type not supported in the DB */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    found = GT_FALSE;

    /* now set the 'Buffer memory' parameters of the 'Fine tuning' parameters , from the DB */

    for(ii = 0 ; ii < bufferMemoryTableSize ; ii++)
    {
        for(jj = 0 ; bufferMemoryTablePtr[ii].devTypePtr[jj] != LAST_DEV_IN_LIST_CNS ; jj++)
        {
            if(bufferMemoryTablePtr[ii].devTypePtr[jj] == PRV_CPSS_PP_MAC(devNum)->devType)
            {
                /* found the device type */

                /* copy it's info */
                fineTuningPtr->tableSize.bufferMemory = bufferMemoryTablePtr[ii].config.bufferMemory;
                fineTuningPtr->tableSize.transmitDescr = bufferMemoryTablePtr[ii].config.transmitDescr;

                found = GT_TRUE;
                break;
            }
        }

        if(found == GT_TRUE)
        {
            break;
        }
    }

    if(fineTuningPtr->tableSize.transmitDescr == AUTO_CALC_FIELD_CNS)
    {
        fineTuningPtr->tableSize.transmitDescr =
            fineTuningPtr->tableSize.bufferMemory / _2K;/* 2K = 8bits * 256Bytes per buffer */
    }

    if(fineTuningPtr->tableSize.routerArp == AUTO_CALC_FIELD_CNS)
    {
        fineTuningPtr->tableSize.routerArp =
            fineTuningPtr->tableSize.tunnelStart * 4; /* the number of ARP entries: ARP = TS*4 */
    }

    /*  fix errata -- table sizes */

    if(fineTuningPtr->tableSize.cncBlocks == CNC_AUTO_CALC)
    {
        /* support auto calculation */
        totalCncCountersNeeded = fineTuningPtr->tableSize.cncBlockNumEntries;
    }
    else
    {
        /* support explicit value definitions */
        totalCncCountersNeeded = fineTuningPtr->tableSize.cncBlockNumEntries *
                                 fineTuningPtr->tableSize.cncBlocks;
    }

    if(totalCncCountersNeeded != 0)
    {
        /* update value - to support actual device silicon values */
        fineTuningPtr->tableSize.cncBlockNumEntries = PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries;
        /* calculate the number of CNC blocks needed to support the total number of CNC counters */
        fineTuningPtr->tableSize.cncBlocks =
            (totalCncCountersNeeded + (PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries-1)) /
            PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlockNumEntries;

        /* check that the fine tuning value not overrun the HW max support */
        if(fineTuningPtr->tableSize.cncBlocks >
           (PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncBlocks
            * PRV_CPSS_DXCH_PP_HW_INFO_CNC_MAC(devNum).cncUnits))
        {
            /* Error in fine tuning or in calculation */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    /* support 'auto calc' for pcl rules to be like tti rules , as those share the same tcam */
    if(fineTuningPtr->tableSize.policyTcamRaws == PCL_NUM_RULES_MAX_AS_TTI_AUTO_CALC)
    {
        fineTuningPtr->tableSize.policyTcamRaws = fineTuningPtr->tableSize.tunnelTerm;
    }


    /* support 'auto calc' for number of trunks */
    if(fineTuningPtr->tableSize.trunksNum == TRUNK_NUM_MAX_AUTO_CALC)
    {
        CPSS_TBD_BOOKMARK
        /* limited by 8K entries in the L2ECMP table -
           since we HARD coded split it (4K entries) for trunks with 8 members */
        /* value should be PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum); */
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            tmpValue = _8K;
                /* can not use next :
                    PRV_CPSS_DXCH_PP_MAC(devNum)->accessTableInfoPtr[
                        PRV_CPSS_DXCH_LION3_TABLE_EQ_L2_ECMP_E].maxNumOfEntries;
                    because not initialized yet !
                */
            /* full table size */
            PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers = tmpValue;
            /* second half of the table */
            /* (tmpValue / 2) is 'half' the table */
            /* (tmpValue / 2) / 8) is number of 8 members trunks in the half table */
            /* the '-1' it to 'skip' trunkId = 0 */
            fineTuningPtr->tableSize.trunksNum = ((tmpValue / 2) / 8) - 1;/* second half of the table */
        }
        else
        {
            fineTuningPtr->tableSize.trunksNum = PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum);
        }
    }
    else
    if(fineTuningPtr->tableSize.trunksNum & TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS)
    {
        /* indication that the value is 'L2Ecmp/trunk - number of members' and not 'trunk entries' */
        tmpValue = fineTuningPtr->tableSize.trunksNum & (~TRUNK_L2_ECMP_NUM_MEMBERS_INDICATION_CNS);
        CPSS_TBD_BOOKMARK
        /* limited by X entries in the L2ECMP table -
           since we HARD coded split it (X/2 entries) for trunks with 8 members */

        /* full table size */
        PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers = tmpValue;

        /* second half of the table */

        /* (tmpValue / 2) is 'half' the table */
        /* (tmpValue / 2) / 8) is number of 8 members trunks in the half table */
        /* the '-1' it to 'skip' trunkId = 0 */
        fineTuningPtr->tableSize.trunksNum = ((tmpValue / 2) / 8) - 1;/* second half of the table */
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE &&
       PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.l2EcmpNumMembers == 0 )
    {
        /* Error in fine tuning */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* check it anyway to see we not miscalculated */
    if(fineTuningPtr->tableSize.trunksNum >
       PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum))
    {
        /* Error in fine tuning */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    fineTuningPtr->featureInfo.TmSupported = GT_FALSE;/*support for BC3*/
    /* BC2 supported features */
    /* Enable TM for BC2, BobK-Cetus, Bobk-Caelum */
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
    {
        switch(PRV_CPSS_PP_MAC(devNum)->devSubFamily)
        {
            case CPSS_PP_SUB_FAMILY_NONE_E:
                /*Bobcat2 devices*/
                fineTuningPtr->featureInfo.TmSupported = GT_TRUE;
                break;
            case CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E:
                /*BobK devices*/
                switch (PRV_CPSS_PP_MAC(devNum)->devType)
                {
                    /* Cetus */
                    case CPSS_98DX4235_CNS:
                        fineTuningPtr->featureInfo.TmSupported = GT_TRUE;
                        break;

                    /* Caelum */
                    case CPSS_98DX42KK_CNS:
                    case CPSS_98DX4203_CNS:
                    case CPSS_98DX4204_CNS:
                        fineTuningPtr->featureInfo.TmSupported = GT_TRUE;
                        break;
                }
                break; /* case CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E */
            default:
                break;
        }

        /* verify TM HW is Enabled */
        if (fineTuningPtr->featureInfo.TmSupported == GT_TRUE)
        {
            tmpValue = 0;
            prvCpssDxChTMFreqGet(devNum, &tmpValue);

            if (tmpValue == 0) /* tm DRAM Frequency */
            {
                fineTuningPtr->featureInfo.TmSupported = GT_FALSE;
            }
            CPSS_LOG_INFORMATION_MAC("HwInit: Tm HW is disabled\n");
        }



    }

    if(PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_GET_MAC(devNum,PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E))
    {
        fineTuningPtr->tableSize.trunksNum /= 2;
        CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
            "Trunks",
            fineTuningPtr->tableSize.trunksNum);
    }

    if(PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_GET_MAC(devNum,PRV_CPSS_DXCH_LION_TABLE_STG_EGRESS_E))
    {
        fineTuningPtr->tableSize.stgNum /= 2;
        CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
            "STG",
            fineTuningPtr->tableSize.stgNum);
    }



    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_xcat
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       DxCh xCat device.
*
* APPLICABLE DEVICES:
*        xCat; xCat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_xcat
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;       /* return code       */
    GT_U32    hwValue;  /* HW Value to write */
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr =
        &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    rc = hwPpPhase1Part2Enhanced_common(devNum,
            dxChXcatTables_size,dxChXcatTables,
            dxChXcatBufferMemory_size,dxChXcatBufferMemory);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* PCL TCAM size in 4-STD-rule rows */
    switch (fineTuningPtr->tableSize.policyTcamRaws)
    {
        case 768: hwValue = 0; break;
        case 512: hwValue = 1; break;
        case 384: hwValue = 1; break;
        case 256: hwValue = 2; break;
        case 128: hwValue = 2; break;
        case 0: hwValue = 0xFFFFFFFF; break; /* skip configuration */
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    if (hwValue != 0xFFFFFFFF)
    {
        /* POLICY TCAM  size */
        rc = prvCpssDrvHwPpSetRegField(
            devNum,
            PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.pclRegs.pclTcamConfig0,
            1, 4, hwValue);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devType == CPSS_98DX3036_CNS)
    {
        fineTuningPtr->tableSize.tunnelTerm = _13K/4;
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_lion
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       DxCh Lion device.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_lion
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    rc = hwPpPhase1Part2Enhanced_common(devNum,
            lionTables_size,lionTables, 0 , NULL);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* add here lion B specifics */

    /* set the CPU as extended cascade port */
    rc = cpssDxChCscdPortTypeSet(devNum,
        CPSS_CPU_PORT_NUM_CNS,
        CPSS_PORT_DIRECTION_BOTH_E,
        CPSS_CSCD_PORT_DSA_MODE_EXTEND_E);

    return rc;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_lion2
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       DxCh Lion2 device.
*
* APPLICABLE DEVICES:
*        Lion2
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Bobcat2; Caelum; Bobcat3
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_lion2
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;

    rc = hwPpPhase1Part2Enhanced_common(devNum,
            lion2Tables_size,lion2Tables, 0 , NULL);
    return rc;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet
*
* DESCRIPTION:
*       This function returns supported bandwidth by dev family/reviosion/corecolock
*
* APPLICABLE DEVICES:
*
* NOT APPLICABLE DEVICES:
*
* INPUTS:
*       family       - device family
*       revision     - device revision
*       coreClockMHz - core clock in MHz
*
* OUTPUTS:
*       pipeBWCapacityInGbpsPtr - pointer to bw coreesponding to dev family/reviosion/corecolock
*
* RETURNS:
*       GT_OK            - on success
*       GT_BAD_PTR       - on error
*       GT_NOT_SUPPORTED - on device family/revison/coreclock not found
*
* COMMENTS:
*       None.
*
******************************************************************************/
typedef struct PRV_CPSS_DXCH_CORECLOCK_BW_STC
{
    GT_U32 coreClockMHz;
    GT_U32 gopBWGpbs;
}PRV_CPSS_DXCH_CORECLOCK_BW_STC;


typedef struct PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC
{
    CPSS_PP_FAMILY_TYPE_ENT         family;
    CPSS_PP_SUB_FAMILY_TYPE_ENT     subfamily;
    GT_U32                          revision;
    GT_U32                          pipeEnableBitMap;
    PRV_CPSS_DXCH_CORECLOCK_BW_STC *coreClockBWListPtr;
}PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC;

PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat2_A0_coreClockBw [] =
{
   /* ccMHz,  gopBWGpbs */
      { 221,   67 }
     ,{ 250,   84 }
     ,{ 362,  120 }
   /*,{ 400,      } */ /* NOT SUPPORTED */
   /*,{ 450,      } */ /* NOT SUPPORTED */
   /*,{ 500,      } */ /* NOT SUPPORTED */
     ,{ 521,  168 }
     ,{   0,    0 }  /* last item in list  */
};

PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat2_B0_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 175,   58 }
    ,{ 200,   67 }
    ,{ 221,   67 }
    ,{ 250,   84 }
    ,{ 362,  120 }
    ,{ 365,  121 }
 /* ,{ 400,    0 }  *//* NOT SUPPORTED */
 /* ,{ 450,    0 }  *//* NOT SUPPORTED */
    ,{ 521,  168 }
    ,{   0,    0 }  /* last item in list  */
};


PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat2_BobK_Pipe1_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 167,   67 }
    ,{ 200,  101 }
    ,{ 250,  121 }
    ,{ 365,  185 }
    ,{   0,    0 }  /* last item in list  */
};

#define BOBCAT3_GOP_BW_GPBS_CNS 340 /* need to be 1.86T , but limited by PRV_CPSS_DXCH_BC2_PA_MAP_TOTAL_FLDS_REG_CNS */
static PRV_CPSS_DXCH_CORECLOCK_BW_STC bobcat3_A0_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 175,  BOBCAT3_GOP_BW_GPBS_CNS }
    ,{ 200,  BOBCAT3_GOP_BW_GPBS_CNS }
    ,{ 221,  BOBCAT3_GOP_BW_GPBS_CNS }
    ,{ 250,  BOBCAT3_GOP_BW_GPBS_CNS }
    ,{ 362,  BOBCAT3_GOP_BW_GPBS_CNS }
    ,{ 365,  BOBCAT3_GOP_BW_GPBS_CNS }
 /* ,{ 400,    0 }  *//* NOT SUPPORTED */
 /* ,{ 450,    0 }  *//* NOT SUPPORTED */
    ,{ 521,  BOBCAT3_GOP_BW_GPBS_CNS }
    ,{   0,    0 }  /* last item in list  */
};

PRV_CPSS_DXCH_CORECLOCK_BW_STC aldrin_coreClockBw [] =
{
  /* ccMHz,  gopBWGpbs */
     { 200,  123 }
    ,{ 250,  243 }
    ,{ 365,  360 }
    ,{ 480,  360 }
    ,{   0,    0 }  /* last item in list  */
};

PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC devRev_x_CcBwList[] =
{
      /* dev                          subfamily                                revision,           pipeBmp, core clock x BW table */
     { CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,        /*BC2 A0 rev */ 0,             0x1, &bobcat2_A0_coreClockBw[0]                  }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_NONE_E,        /*BC2 B0 rev */ 1,             0x1, &bobcat2_B0_coreClockBw[0]                  }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E,                0, /*pipe-0-1*/0x3, &bobcat2_BobK_Pipe1_coreClockBw[0]          }
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT2_E, CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E,                0, /*pipe-1  */0x2, &bobcat2_BobK_Pipe1_coreClockBw[0]          }
    /* bc3 - currently use the BC2_B0 info */
    ,{ CPSS_PP_FAMILY_DXCH_BOBCAT3_E, CPSS_PP_SUB_FAMILY_NONE_E,/*BC3 A0 rev */         0,             0x1, &bobcat3_A0_coreClockBw[0]                  }
    ,{ CPSS_PP_FAMILY_DXCH_ALDRIN_E,  CPSS_PP_SUB_FAMILY_NONE_E,/*Aldrin A0 rev */      0,             0x7, &aldrin_coreClockBw[0]                      }
    ,{ CPSS_MAX_FAMILY              , CPSS_MAX_SUB_FAMILY,                   (GT_U32)(~0),             0x0, (PRV_CPSS_DXCH_CORECLOCK_BW_STC*)NULL       }
};

static GT_U32 internal_hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet
(
    IN  GT_U8    devNum,
    OUT GT_U32  *pipeBWCapacityInGbpsPtr
)
{
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;
    PRV_CPSS_DXCH_DEV_REV_x_CC_BW_STC * devRevPtr;
    PRV_CPSS_DXCH_CORECLOCK_BW_STC    * coreClockBwPtr;
    GT_U32                              min_distance;
    GT_U32                              cur_distance;
    PRV_CPSS_DXCH_CORECLOCK_BW_STC     *suitableRevCoreClockBWListPtr;
    CPSS_PP_FAMILY_TYPE_ENT             family;
    CPSS_PP_SUB_FAMILY_TYPE_ENT         subfamily;
    GT_U32                              revision;
    GT_U32                              coreClockMHz;


    if (pipeBWCapacityInGbpsPtr == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PTR, LOG_ERROR_NO_MSG);
    }

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);
    family       = pDev->genInfo.devFamily;
    subfamily    = pDev->genInfo.devSubFamily;
    revision     = pDev->genInfo.revision;
    coreClockMHz = pDev->genInfo.coreClock;
    /*-------------------------------------------------------------*/
    /* search greatest smaller or equal to than requested revision */
    /*-------------------------------------------------------------*/
    suitableRevCoreClockBWListPtr = NULL;
    min_distance                  = (GT_U32)(~0);
    for (devRevPtr = &devRev_x_CcBwList[0]; devRevPtr->family != CPSS_MAX_FAMILY; devRevPtr++)
    {
        if (devRevPtr->family == family && devRevPtr->revision <= revision && devRevPtr->subfamily == subfamily)
        {
            cur_distance = revision - devRevPtr->revision;
            if (cur_distance < min_distance)
            {
                min_distance = cur_distance;
                suitableRevCoreClockBWListPtr = devRevPtr->coreClockBWListPtr;
            }
        }
    }

    if (suitableRevCoreClockBWListPtr != NULL) /* suitable coreclock list is found */
    {
        for (coreClockBwPtr = suitableRevCoreClockBWListPtr; coreClockBwPtr->coreClockMHz != 0; coreClockBwPtr++)
        {
            if (coreClockBwPtr->coreClockMHz == coreClockMHz)
            {
                *pipeBWCapacityInGbpsPtr = coreClockBwPtr->gopBWGpbs;
                return GT_OK;
            }
        }
    }
    *pipeBWCapacityInGbpsPtr = 0;
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG); /* not supported */
}


GT_U32 hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet
(
    IN  GT_U8    devNum,
        OUT GT_U32  *pipeBWCapacityInGbpsPtr
)
{
    return internal_hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum,/*OUT*/pipeBWCapacityInGbpsPtr);
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_bobcat2
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       Bobcat2 device.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2; Bobcat3.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_bobcat2
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

    rc = hwPpPhase1Part2Enhanced_common(devNum,bobcat2Tables_size, bobcat2Tables, 0 , NULL);
    if (rc != GT_OK)
    {
        return rc;
    }

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

    rc = internal_hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum,/*OUT*/&pDev->fineTuning.tableSize.pipeBWCapacityInGbps);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_bobcat3
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       Bobcat3 device.
*
* APPLICABLE DEVICES:
*       Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2; Bobcat2; Caelum.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_bobcat3
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_PP_CONFIG_STC *pDev;

    rc = hwPpPhase1Part2Enhanced_common(devNum,bobcat3Tables_size, bobcat3Tables, 0 , NULL);
    if (rc != GT_OK)
    {
        return rc;
    }

    pDev = PRV_CPSS_DXCH_PP_MAC(devNum);

    rc = hwPpPhase1Part2Enhanced_BandWidthByDevRevCoreClockGet(devNum, /*OUT*/&pDev->fineTuning.tableSize.pipeBWCapacityInGbps);
    if (rc != GT_OK)
    {
        return rc;
    }
    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced_xcat2
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given
*       DxCh xCat2 device.
*
* APPLICABLE DEVICES:
*        xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced_xcat2
(
    IN      GT_U8     devNum
)
{
    GT_STATUS rc;       /* return code       */
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr =
        &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    rc = hwPpPhase1Part2Enhanced_common(devNum,
            dxChXcatTables_size,dxChXcatTables,
            dxChXcatBufferMemory_size,dxChXcatBufferMemory);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* all xCat2 devices supports CRC Hash */
    fineTuningPtr->featureInfo.trunkCrcHashSupported = GT_TRUE;

    /* set the CPU as extended cascade port */
    rc = cpssDxChCscdPortTypeSet(devNum,
        (GT_U8)CPSS_CPU_PORT_NUM_CNS,
        CPSS_PORT_DIRECTION_BOTH_E,
        CPSS_CSCD_PORT_DSA_MODE_EXTEND_E);

    return rc;
}

/*******************************************************************************
* hwPpPhase1Part2Enhanced
*
* DESCRIPTION:
*       This function performs Enhanced SW configurations for the given PP.
*
* INPUTS:
*       devNum  - The PP's device number.
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2Enhanced
(
    IN      GT_U8                                   devNum
)
{
    cpssOsMemSet(&PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning,0,
                sizeof(PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning));

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_CHEETAH_E:
        case CPSS_PP_FAMILY_CHEETAH2_E:
            return hwPpPhase1Part2Enhanced_ch1_ch2(devNum);
        case CPSS_PP_FAMILY_CHEETAH3_E:
            return  hwPpPhase1Part2Enhanced_ch3(devNum);
        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
        case CPSS_PP_FAMILY_DXCH_XCAT_E:
            return hwPpPhase1Part2Enhanced_xcat(devNum);
        case CPSS_PP_FAMILY_DXCH_LION_E:
            return hwPpPhase1Part2Enhanced_lion(devNum);
        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            return hwPpPhase1Part2Enhanced_xcat2(devNum);
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            return hwPpPhase1Part2Enhanced_lion2(devNum);
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
            return hwPpPhase1Part2Enhanced_bobcat2(devNum);
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
            return hwPpPhase1Part2Enhanced_bobcat3(devNum);
        default:
            return GT_OK;
    }
}

/*******************************************************************************
* hwPpPhase1Part2
*
* DESCRIPTION:
*       Part 2 of "phase 1"
*       This routine initialize the board specific parameters and registers
*       the packet processor for pre-discovery phase access and diagnostics.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The Pp's device number
*
* OUTPUTS:
*
* RETURNS:
*       GT_OK   - on success.
*       GT_FAIL - on failure.
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part2
(
    IN  GT_U8                               devNum
)
{
    GT_STATUS           rc;

    /* Set basic device registration parameters.     */
    rc = hwPpPhase1Part2Config(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part2(..) : hwPpPhase1Part2Config(..) : return code is %d", rc);
        return rc;
    }

    /* Set Enhanced device capabilities parameters.     */
    rc = hwPpPhase1Part2Enhanced(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part2(..) : hwPpPhase1Part2Enhanced(..) : return code is %d", rc);
    }

    return rc;
}


/*******************************************************************************
* hwPpPhase1Part3
*
* DESCRIPTION:
*       Part 3 of "phase 1"
*       Performs configures that should be done at the end of "Phase 1" and
*       before Pp "start-init" operation.
*       Set Errata issues and registers settings.
*
*       function called from the "phase 1" sequence.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The Pp's device number to run the errata Wa on.
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       was called "pre start init"
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part3
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC       *ppPhase1ParamsPtr
)
{
    GT_STATUS rc; /* return code */

    /* Device number        */
    if (systemRecoveryInfo.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
    {
        rc = cpssDxChCfgHwDevNumSet(devNum, devNum);
        if(GT_OK != rc)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part3(..) : cpssDxChCfgHwDevNumSet(..) : return code is %d", rc);
            return rc;
        }
    }
    else if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
             /* unmark the old HW dev number to default single mode */
            rc = cpssDxChCscdDbRemoteHwDevNumModeSet(PRV_CPSS_HW_DEV_NUM_MAC(devNum),
                                                     CPSS_GEN_CFG_HW_DEV_NUM_MODE_SINGLE_E);
            if (rc != GT_OK)
            {
                return rc;
            }

            /* mark the new HW dev as daul device in the DB */
            rc = cpssDxChCscdDbRemoteHwDevNumModeSet(devNum,
                                                     CPSS_GEN_CFG_HW_DEV_NUM_MODE_DUAL_E);
            if (rc != GT_OK)
            {
                return rc;
            }
     }
     /* set default values of registers */
    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_CHEETAH_E:
            return hwPpCheetahRegsDefault(devNum);

        case CPSS_PP_FAMILY_CHEETAH2_E:
            return hwPpCheetah2RegsDefault(devNum);

        case CPSS_PP_FAMILY_CHEETAH3_E:
            return hwPpCheetah3RegsDefault(devNum, ppPhase1ParamsPtr);

        case CPSS_PP_FAMILY_DXCH_XCAT_E:
            return hwPpDxChXcatRegsDefault(devNum, ppPhase1ParamsPtr);

        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            return hwPpDxChXcat3RegsDefault(devNum, ppPhase1ParamsPtr);

        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            return hwPpDxChXcat2RegsDefault(devNum, ppPhase1ParamsPtr);

        case CPSS_PP_FAMILY_DXCH_LION_E:
            return hwPpDxChLionRegsDefault(devNum, ppPhase1ParamsPtr);

        case CPSS_PP_FAMILY_DXCH_LION2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
            return hwPpDxChLion2RegsDefault(devNum, ppPhase1ParamsPtr);

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
}


/*******************************************************************************
* prvCpssDxChBobcat2PortMappingConfigSet
*
* DESCRIPTION:
*       Bobcat2 Port mapping initial configuration
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat3.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChBobcat2PortMappingConfigSet
(
    IN  GT_U8  devNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32 regAddr;     /* register address */
    GT_U32 regValue;    /* register value */
    GT_U32 i;           /* loop iterator */
    PRV_CPSS_DXCH_TABLE_ENT tableType; /* table type */

    /***************************************/
    /* Bobcat2 Port Mapping Configurations */
    /***************************************/

    /* Enable TXQ to DMA port mapping */
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 1);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* Port To DMA Map Table Configuration */
    for(i = 0; i < 72; i++)
    {
        regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.portToDMAMapTable[i];

        regValue = (i == CPSS_CPU_PORT_NUM_CNS) ? 72 : i;

        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 0, 8, regValue);
        if(GT_OK != rc)
        {
            return rc;
        }
    }


    tableType = PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_QAG_TARGET_PORT_MAPPER_E;
    /* EGF Physical port To TXQ port Table Configuration */
    for(i = 0; i < 72; i++)
    {
        /* 1:1 mapping for all TXQ ports */
        rc = prvCpssDxChWriteTableEntry(devNum, tableType, i, &i);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    return GT_OK;
}


/*******************************************************************************
* prvCpssDxChBobcat3PortMappingConfigSet
*
* DESCRIPTION:
*       Bobcat2 Port mapping initial configuration
*
* APPLICABLE DEVICES:
*        Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxChBobcat3PortMappingConfigSet
(
    IN  GT_U8  devNum
)
{
    GT_STATUS rc;       /* return code */
    GT_U32 regAddr;     /* register address */
    GT_U32 i;     /* loop iterator */
    GT_U32 dpIndex;     /* data path index */
    GT_U32 localDmaNum; /* local DMA number 0..12 */
    GT_U32 globalDmaNum; /* local DMA number 0..72 */
    GT_U32 localDqPort; /* local DP portNumber 0..95 */
    GT_U32 globalTxqPort;/* global txq port 0..575  (575=96*6) */
    GT_U32 globalPortNum;/* global prot Num 0..255*/

    /***************************************/
    /* Bobcat2 Port Mapping Configurations */
    /***************************************/

    /* Enable TXQ to DMA port mapping */
    regAddr = PRV_DXCH_REG1_UNIT_TXQ_DQ_MAC(devNum).global.globalDQConfig.globalDequeueConfig;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, 10, 1, 1);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* DQ Port To DMA Map Table Configuration */
    /* loop on all DMA numbers and do map from DQ port to those DMAs */

    for(dpIndex = 0 ;
        dpIndex < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp ;
        dpIndex++)
    {
        for(localDmaNum = 0 ;
            localDmaNum < PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts ;
            localDmaNum++)
        {
            if(dpIndex != 0 &&
               localDmaNum != 0 &&
               PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum == localDmaNum)
            {
                /* do not bind the DMA of the 'CPU port' ... yet */
                continue;
            }

            if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum == localDmaNum)
            {
                /* bind CPU to DP[0] */
                /* set global DMA of the CPU */
                globalDmaNum = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.dmaNumber;
            }
            else
            {
                /* calculate the global DMA number */
                rc =  prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert(devNum,
                    dpIndex,
                    localDmaNum,
                    &globalDmaNum);
                if(GT_OK != rc)
                {
                    return rc;
                }

            }
            localDqPort = localDmaNum;
            /* calculate the global DQ port number */
            globalTxqPort =
                SIP_5_20_LOCAL_TXQ_DQ_PORT_TO_GLOBAL_TXQ_DQ_PORT_MAC(devNum,localDqPort,dpIndex);

            /* bind the DQ port to the DMA number */
            rc = prvCpssDxChPortMappingTxQPort2TxDMAMapSet(devNum,
                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                globalTxqPort,
                globalDmaNum);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
    }

    /* EGF Physical port To TXQ port Table Configuration */
    for(i = 0; i < PRV_CPSS_PP_MAC(devNum)->numOfPorts; i++)
    {
        globalPortNum = i;
        if( i == CPSS_CPU_PORT_NUM_CNS )
        {/**/
         /*PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.dmaNumber*/
            dpIndex = 0;
            localDmaNum = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum;
        }
        else
        {
            /*txq-port num --> set default to equal  'TXQ-DQ-port number' */
            /* every 12 ports move to next DQ unit */
            rc = prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert(
                devNum,
                i/*globalDmaNum*/,
                &dpIndex,
                &localDmaNum);
            if(GT_OK != rc)
            {
                return rc;
            }
        }

        localDqPort = localDmaNum;

        /* every 12 ports move to next DQ unit --> the globalTxqPort jump to
            next 96 ports */
        globalTxqPort =
            SIP_5_20_LOCAL_TXQ_DQ_PORT_TO_GLOBAL_TXQ_DQ_PORT_MAC(devNum,localDqPort,dpIndex);

        rc = prvCpssDxChPortMappingEGFTargetLocalPhys2TxQPortMapSet(
            devNum,
            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
            globalPortNum, /*physical port*/
            globalTxqPort);/*txq-port num --> set default to equal  'TXQ-DQ-port number' */
        if(GT_OK != rc)
        {
            return rc;
        }
    }



    return GT_OK;
}

#ifndef ASIC_SIMULATION
/*******************************************************************************
* xcat3PllInit
*
* DESCRIPTION:
*       XCAT3 PLL init and configuration
*
* APPLICABLE DEVICES:
*       xCat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2; Bobcat2.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS xcat3PllInit
(
    IN  GT_U8 devNum
)
{
    GT_STATUS   rc;         /* return code */
    GT_U32      regAddr;    /* register address */
    GT_U32      regValue;   /* register value */

    /* 1. Shut off PLL */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.pllMiscConfig;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 1, 1);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 2. Disable dividers */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl10;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 8, 0);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 3. Configure dividers in spare control */

    /*
        Device General Control 6:
            Misc_pll_gunit_clk_div_ratio    [12:7] -> value 0x14
        Device General Control 9:
            Misc_pll_pci_ref                [7:2]   -> value 0x19
            Misc_pll_dp_clk_div             [21:16] -> value 0x7
            Misc_pll_pci_clk_in             [27:22] -> value 0x14
    */

    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl6;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 7, 6, 0x14);
    if (rc != GT_OK)
    {
        return rc;
    }

    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl9;
    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    U32_SET_FIELD_MAC(regValue, 2, 6, 0x19);
    U32_SET_FIELD_MAC(regValue, 16, 6, 0x7);
    U32_SET_FIELD_MAC(regValue, 22, 6, 0x14);

    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 4. Configure PLL params (second is 2.5Ghz) */

    /* PLL misc Parameters register:
        Set "NDIV"      [20:12] -> value 0x63
        Set "VCO_BAND"  [24:21] -> value 0x9
    */

    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.pllMiscParameters;
    rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &regValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    U32_SET_FIELD_MAC(regValue, 12, 9, 0x63);
    U32_SET_FIELD_MAC(regValue, 21, 4, 0x9);

    rc = prvCpssDrvHwPpResetAndInitControllerWriteReg(devNum, regAddr, regValue);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 5. Enable Use PLL RF settings */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.pllMiscConfig;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 9, 1, 1);
    if (rc != GT_OK)
    {
        return rc;
    }


    /* 6. Enable PLL */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.pllMiscConfig;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 1, 0);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 7. Wait 1ms */
    cpssOsTimerWkAfter(1);

    /* 8. Enable dividers (Spare control) */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->DFXServerUnitsBC2SpecificRegs.deviceCtrl10;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 8, 0xFF);
    return rc;
}
#endif

/*******************************************************************************
* hwPpPhase1RegisterMisconfigurationAfterTablesInit
*
* DESCRIPTION:
*       RM (Register Miss-configuration) after calling to
*       prvCpssDxChTablesAccessInit(...)
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpPhase1RegisterMisconfigurationAfterTablesInit
(
    IN  GT_U8               devNum
)
{
    GT_STATUS   rc;
    /* data that will be written to the table */
    GT_U32 hwDataArray[6] = {0,0,0,0,0,0};
    GT_U32    port;    /* port number */
    CPSS_PORTS_BMP_STC        portBitmap;/* bit map of ports */
    GT_U16      vidx;/* vidx */
    GT_U32      regAddr;        /* register address */
    GT_U32      data;
    GT_U32      portGroupId;    /* port group id    */
    GT_U32      routerVlanUrpfTableEntryData[1]; /* size of each entry is 1 word */
    GT_U32      i=0;
    GT_U32      cpuPortIndex;/* index for the SDMA cpu port */

    if(0 == PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
    {
        /* not xcat and above */
        return GT_OK;
    }

    /* clear entry for VLAN 0 in VLAN Table */
    /* The VLAN#0 is not initialized in HW */
    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        rc = prvCpssDxChWriteTableEntry(devNum,
                                        PRV_CPSS_DXCH_TABLE_VLAN_E,
                                        0,/* vid */
                                        &hwDataArray[0]);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        /* invalidate vlan 0 */
        rc = cpssDxChBrgVlanEntryInvalidate(devNum, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_XCAT_RM_EXTENDED_DSA_BYPASS_BRIDGE_WA_E))
    {
        /* enable Bypass Bridge for Extended DSA tag packets */
        for( port = 0; port <= PRV_CPSS_PP_MAC(devNum)->numOfPorts; port++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, port);

            rc = cpssDxChCscdPortBridgeBypassEnableSet(devNum,port,GT_TRUE);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        /* enable on CPU port Bypass Bridge for Extended DSA tag packets */
        rc = cpssDxChCscdPortBridgeBypassEnableSet(devNum,CPSS_CPU_PORT_NUM_CNS,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /* set all ePort entries to support Extended DSA bypass bridge */
            for( port = 0; port < PRV_CPSS_DXCH_MAX_DEFAULT_EPORT_NUMBER_MAC(devNum); port++)
            {
                rc = cpssDxChCscdPortBridgeBypassEnableSet(devNum,port,GT_TRUE);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
        PRV_CPSS_DXCH_LION_RM_MULTI_PORT_GROUP_CPU_IN_VIDX_WA_E))
    {
        vidx = 0xFFF;
        rc = cpssDxChBrgMcEntryRead(devNum, vidx, &portBitmap);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* remove ports : 15,31,47 */
        CPSS_PORTS_BMP_PORT_CLEAR_MAC(&portBitmap,15);
        CPSS_PORTS_BMP_PORT_CLEAR_MAC(&portBitmap,31);
        CPSS_PORTS_BMP_PORT_CLEAR_MAC(&portBitmap,47);

        /* use private function to avoid flood VIDX check */
        rc = prvCpssDxChBrgMcEntryWrite(devNum, vidx, &portBitmap);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                               PRV_CPSS_DXCH_LION_URPF_PER_VLAN_NOT_SUPPORTED_WA_E))
    {
        /* Run a procedure that sets the VLAN uRPF table output to "uRPF Disable",
           thus effectively support uRPF check per route using the LTT.
           The procedure is write 0 to one of the accessible entries,
           read it and then turn off the RAM.
           By doing so the RAM output turns to '0' constantly. */

        regAddr = 0x02800D70  ;
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
        {
            PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
            {
                /* read register 0x02800D70 to verify that WA is not already activated (bits 30 and 19)*/
                rc = prvCpssDrvHwPpPortGroupReadRegister(devNum,
                                                         portGroupId,
                                                         regAddr,
                                                         &data);
                if(rc != GT_OK)
                {
                    return rc;
                }

                if ((0x40080000 & data) > 0 )
                {
                    continue;
                }

                /* set value 0 to regAddr = 0x2801400 --> PRV_CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E */
                routerVlanUrpfTableEntryData[0] = 0;

                rc = prvCpssDxChPortGroupWriteTableEntry(devNum,
                                                         portGroupId,
                                                         PRV_CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E,
                                                         0,
                                                         routerVlanUrpfTableEntryData);
                if(rc != GT_OK)
                {
                    return rc;
                }

                rc = prvCpssDxChPortGroupReadTableEntry(devNum,
                                                     portGroupId,
                                                     PRV_CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E,
                                                     0,
                                                     routerVlanUrpfTableEntryData);
                if(rc != GT_OK)
                {
                    return rc;
                }

                rc = prvCpssDrvHwPpPortGroupWriteRegister(
                     devNum,
                     portGroupId,
                     regAddr,
                     0x58380000);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }

            PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        }
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* next function call tables so must be called only after tables DB
           initialization */

        /* set the CPU as 2 words DSA tag */
        rc = cpssDxChCscdPortTypeSet(devNum,
            (GT_U8)CPSS_CPU_PORT_NUM_CNS,
            CPSS_PORT_DIRECTION_BOTH_E,
            CPSS_CSCD_PORT_DSA_MODE_2_WORDS_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    /*******************************/
    /* Port Mapping Configurations */
    /*******************************/
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))
    {

        /* NOTE: cpssDxChCscdPortTypeSet(...) must be called for 'eArch' device
            only after 'tables initialization' because the setting done using 'tables engine' */

        /* set the CPU as '4 words' cascade port , because the 2 words(extended DSA)
            tag can't support receive from physical port > 63 and do not support eArch */
        rc = prvCpssDxChCscdPortSet(devNum,
            CPSS_CPU_PORT_NUM_CNS,
            PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.dmaNumber,
            1,/*do ingress*/
            1,/*do egress*/
            CPSS_CSCD_PORT_DSA_MODE_4_WORDS_E);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /*Virtual 2 Physical Port Remap <%n>*/
            /* set 1:1 the 'virtual port' to the physical port mapping for the
                'EGF_EFT' link up/down issues */
            for( port = 0 ;
                 port < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) ;
                 port++ )
            {
                rc = prvCpssDxChHwEgfEftFieldSet(devNum,port/*virtual port (target port)*/,
                    PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_VIRTUAL_2_PHYSICAL_PORT_REMAP_E,
                    port/*global physical port*/);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        /* Port To Hemisphere Mapping Reg %n */
        /* default of the device is :
            ports 0..127 --> hemisphere 0
            ports 128..255 --> hemisphere 1

            because the CPSS and simulation still uses '16 ports per port group'
            Next code will set :
            ports 64..127 --> hemisphere 1
            (not change 0..63 , 128..255)
        */
        /* there are 32 ports in each register */
        if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum) == 1)
        {   /* the device has only one hemisphere. Need to reset values of
               registers for ports 128..255 */
            GT_U32  numRegs = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts/32;
            for (i = 4; i < numRegs; i++)
            {
                regAddr = PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.portToHemisphereMapReg[i];
                rc = prvCpssHwPpWriteRegister(devNum, regAddr, 0);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }
        else
        {
            for(port = 64 ; port < 128 ;port++)
            {
                rc = prvCpssDxChHwEgfEftFieldSet(devNum,port,
                    PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_HEMISPHERE_MAP_E,
                    1/*target hemisphere - 1*/);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
        }

        if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /* together with the configuration from prvCpsssDxChPortMappingArgumentsBuild(...)
            it will bind 'SDMA_CPU_PORT' (63) to 'last physical port' and will set 'force link up' */
            rc = prvCpssDxChHwPpSdmaCpuPortReservedIndexGet(devNum,&cpuPortIndex);
            if(rc != GT_OK)
            {
                return rc;
            }

            rc = prvCpssDxChHwEgfEftFieldSet(devNum,cpuPortIndex,
                PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_E,
                1/*force link UP*/);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        else
        {
            /* we set ALL ports to be 'force link up' , otherwise the traffic not egress event from ports with link up.
               The HW default of this 'link down' filter , is to 'filter all' ports.
               The CPSS initialization change those defaults to 'filter none'.
               The 'unaware' application will have egress traffic.(with potential unwanted replications)
               The 'aware' application will use new CPSS API to explicitly manipulate this 'link down' filter
               (without potential unwanted replications)
             */
            for(port = 0 ; port < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) ; port += 32)
            {
                rc = prvCpssHwPpWriteRegister(devNum,
                    PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.physicalPortLinkStatusMask[port/32],
                    0xFFFFFFFF);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }

        }

        /* init EGF EFT/Global/CPU Code to Physical Port Mapping %n*/
        rc = prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
        {
            /*init EGF qag/TC DP Mapper Table */
            rc = prvCpssDxChHwEgfQagTcDpMapperInit(devNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            rc = prvCpssDxChBobcat2PortMappingConfigSet(devNum);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
        else if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E)
        {
            rc = prvCpssDxChBobcat3PortMappingConfigSet(devNum);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
    }


#ifndef ASIC_SIMULATION
    /* PLL SAR init for XCAT3:
        1. A0 device
        2. Only on A0 device that Device Sample at Reset (SAR) and Bonding Status<1>[17] is set to 0x0.

        For Core clock is lower than 360MHz:
            We must apply the WA when the GigE MACs of the 2.5Gbe ports is in reset.
            Because we cannot change the MAC Clock (DP clock) when it is out of reset.
            After applying the PLL WA, you need to take out the 2.5GbE MACs out of reset (and reset again).
    */
    if(PRV_CPSS_DXCH_XCAT3_A0_CHECK_MAC(devNum) == GT_TRUE)
    {

        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, 0xF8204, 17, 1, &data);
        if(rc != GT_OK)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }

        if(data == 0)
        {
            rc = xcat3PllInit(devNum);
            if(GT_OK != rc)
            {
                return rc;
            }

            if(PRV_CPSS_PP_MAC(devNum)->coreClock < 360)
            {
                /* After PLL manipulations - unreset and reset stack GIG ports 24..27 */
                for(i = 24; i < 28; i++)
                {
                    PRV_CPSS_DXCH_PORT_MAC_CTRL2_REG_MAC(devNum, i, PRV_CPSS_PORT_GE_E, &regAddr);
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 1, 0);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }

                cpssOsTimerWkAfter(1);

                for(i = 24; i < 28; i++)
                {
                    PRV_CPSS_DXCH_PORT_MAC_CTRL2_REG_MAC(devNum, i, PRV_CPSS_PORT_GE_E, &regAddr);
                    rc = prvCpssHwPpSetRegField(devNum, regAddr, 6, 1, 1);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
            }
        }
    }
#endif

    return GT_OK;
}

/*******************************************************************************
* xcatA1ErrataAddrCheckWaDbInit
*
* DESCRIPTION:
*       Initialize Unit Address Ranges Data Base for Address Check WA.
*       The DB will be initialized according to the following Address ranges
*       list:
*           Where Unit Id is defined by bits 23-28.
*
*           1.        0x02900000 - 0x0290FFFF   (Unit 5)
*               0x02C00000 - 0x02CFFFFF
*           2.        0x07E40000 - 0x07FC0000         (Unit 15)
*           3.        0x08800000 - 0x08801700         (Unit 17)
*               0x08801C00 - 0x08803F00
*           4.        0x09000000 - 0x092FFFF0         (Unit 18)
*               0x09380000 - 0x097FFFFF
*           5.        0x098007FF - 0x09800C00         (Unit 19)
*               0x098017FF - 0x09801C00
*               0x098027FF - 0x09802C00
*               0x098037FF - 0x09803C00
*               0x098047FF - 0x09804C00
*               0x098057FF - 0x09805C00
*               0x098067FF - 0x09806C00
*               0x098077FF - 0x09807C00
*               0x098087FF - 0x09808C00
*               0x098097FF - 0x09809C00
*               0x0980F7FF - 0x0980FC00
*           6.        0x0A807000 - 0x0A80F800        (Unit 21)
*
* APPLICABLE DEVICES:
*        xCat; xCat3;
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       None.
*
* COMMENTS:
*       Note: The ranges should be in growing order.
*
*******************************************************************************/
static GT_VOID xcatA1ErrataAddrCheckWaDbInit
(
    IN  GT_U8               devNum
)
{
    GT_U32      unitId;     /* loop iterator */
    PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC  emptyUnit = EMPTY_UNIT_MAC; /* empty unit ranges */


    /* initialize XCAT DB */
    for (unitId = 0; unitId < UNITS_NUM_CNS; unitId++)
    {
        xcatBadAddressRanges[unitId] = emptyUnit;
    }

    /* Unit 3 */
    xcatBadAddressRanges[3].numOfRanges = (sizeof(xCat2Unit3RangesArray) / sizeof(xCat2Unit3RangesArray[0]));
    xcatBadAddressRanges[3].rangesPtr = xCat2Unit3RangesArray;

    /* Unit 5 */
    xcatBadAddressRanges[5].numOfRanges = (sizeof(unit5RangesArray) / sizeof(unit5RangesArray[0]));
    xcatBadAddressRanges[5].rangesPtr = unit5RangesArray;

    /* Unit 7 */
    xcatBadAddressRanges[7].numOfRanges = (sizeof(xCat2Unit7RangesArray) / sizeof(xCat2Unit7RangesArray[0]));
    xcatBadAddressRanges[7].rangesPtr = xCat2Unit7RangesArray;

    /* Unit 15 */
    xcatBadAddressRanges[15].numOfRanges = (sizeof(unit15RangesArray) / sizeof(unit15RangesArray[0]));
    xcatBadAddressRanges[15].rangesPtr = unit15RangesArray;

    /* Unit 17 */
    xcatBadAddressRanges[17].numOfRanges = (sizeof(unit17RangesArray) / sizeof(unit17RangesArray[0]));
    xcatBadAddressRanges[17].rangesPtr = unit17RangesArray;

    /* Unit 18 */
    xcatBadAddressRanges[18].numOfRanges = (sizeof(unit18RangesArray) / sizeof(unit18RangesArray[0]));
    xcatBadAddressRanges[18].rangesPtr = unit18RangesArray;

    /* Unit 19 */
    xcatBadAddressRanges[19].numOfRanges = (sizeof(unit19RangesArray) / sizeof(unit19RangesArray[0]));
    xcatBadAddressRanges[19].rangesPtr = unit19RangesArray;

    /* Unit 21 */
    xcatBadAddressRanges[21].numOfRanges = (sizeof(unit21RangesArray) / sizeof(unit21RangesArray[0]));
    xcatBadAddressRanges[21].rangesPtr = unit21RangesArray;

    /* Unit 23 */
    xcatBadAddressRanges[23].numOfRanges = (sizeof(unit23RangesArray) / sizeof(unit23RangesArray[0]));
    xcatBadAddressRanges[23].rangesPtr = unit23RangesArray;

    /* Unit 24 */
    xcatBadAddressRanges[24].numOfRanges = (sizeof(unit24RangesArray) / sizeof(unit24RangesArray[0]));
    xcatBadAddressRanges[24].rangesPtr = unit24RangesArray;

    /* Unit 25 */
    xcatBadAddressRanges[25].numOfRanges = (sizeof(unit25RangesArray) / sizeof(unit25RangesArray[0]));
    xcatBadAddressRanges[25].rangesPtr = unit25RangesArray;

    /* Unit 26 */
    xcatBadAddressRanges[26].numOfRanges = (sizeof(unit26RangesArray) / sizeof(unit26RangesArray[0]));
    xcatBadAddressRanges[26].rangesPtr = unit26RangesArray;

    /* Unit 28 */
    xcatBadAddressRanges[28].numOfRanges = (sizeof(unit28RangesArray) / sizeof(unit28RangesArray[0]));
    xcatBadAddressRanges[28].rangesPtr = unit28RangesArray;

    /* Unit 29 */
    xcatBadAddressRanges[29].numOfRanges = (sizeof(unit29RangesArray) / sizeof(unit29RangesArray[0]));
    xcatBadAddressRanges[29].rangesPtr = unit29RangesArray;

    /* Unit 30 */
    xcatBadAddressRanges[30].numOfRanges = (sizeof(unit30RangesArray) / sizeof(unit30RangesArray[0]));
    xcatBadAddressRanges[30].rangesPtr = unit30RangesArray;


    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.unitRangesPtr[0]
                                                            = xcatBadAddressRanges;
    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
    info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.lastValidAddress
                                                            = 0xF80C0FF;
}

/*******************************************************************************
* lionErrataAddrCheckWaDbInit
*
* DESCRIPTION:
*       Initialize Unit Address Ranges Data Base for Address Check WA.
*       The DB will be initialized according to the following Address ranges
*       list:
*           Where Unit Id is defined by bits 23-28.
*           PortGroups 1,2,3:
*           1.        0x03800000 - 0x038FFFFC   (Unit 7)
*           2.        0x07000000 - 0x0707FFFC   (Unit 14)
*           3.        0x0A000000 - 0x0A7FFFFC   (Unit 20)
*           4.        0x10800000 - 0x10FFFFFC   (Unit 33)
*           5.        0x11800000 - 0x11FFFFFC   (Unit 35) only for PortGroup 2
*
* APPLICABLE DEVICES:
*        Lion;
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       None.
*
* COMMENTS:
*       Note: The ranges should be in growing order.
*
*******************************************************************************/
static GT_VOID lionErrataAddrCheckWaDbInit
(
    IN  GT_U8               devNum
)
{
    GT_U32  portGroupId; /* the port group Id - support multi-port-groups device */
    GT_U32  unitId;      /* loop iterator */
    PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC  emptyUnit = EMPTY_UNIT_MAC; /* empty unit ranges */


    /* initialize Lion B0 bad addresses DB */
    /* loop on all active port groups */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        for (unitId = 0; unitId < UNITS_NUM_CNS; unitId++)
        {
            lionBadAddressRanges[portGroupId][unitId] = emptyUnit;
        }

        if (portGroupId > 0)
        {
            /* Unit 7 */
            lionBadAddressRanges[portGroupId][7].numOfRanges = (sizeof(lionUnit7RangesArray) /
                                                                  sizeof(lionUnit7RangesArray[0]));
            lionBadAddressRanges[portGroupId][7].rangesPtr = lionUnit7RangesArray;


            /* Unit 14 */
            lionBadAddressRanges[portGroupId][14].numOfRanges = (sizeof(lionUnit14RangesArray) /
                                                                   sizeof(lionUnit14RangesArray[0]));
            lionBadAddressRanges[portGroupId][14].rangesPtr = lionUnit14RangesArray;

            /* Unit 20 */
            lionBadAddressRanges[portGroupId][20].numOfRanges = (sizeof(lionUnit20RangesArray) /
                                                                   sizeof(lionUnit20RangesArray[0]));
            lionBadAddressRanges[portGroupId][20].rangesPtr = lionUnit20RangesArray;

            /* Unit 33 */
            lionBadAddressRanges[portGroupId][33].numOfRanges = (sizeof(lionUnit33RangesArray) /
                                                                   sizeof(lionUnit33RangesArray[0]));
            lionBadAddressRanges[portGroupId][33].rangesPtr = lionUnit33RangesArray;
        }

        if (portGroupId > 1)
        {
            /* Unit 35, only for port group 2 and 3 */
            lionBadAddressRanges[portGroupId][35].numOfRanges = (sizeof(lionUnit35RangesArray) /
                                                                   sizeof(lionUnit35RangesArray[0]));
            lionBadAddressRanges[portGroupId][35].rangesPtr = lionUnit35RangesArray;
        }

        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.unitRangesPtr[portGroupId]
                                                                = lionBadAddressRanges[portGroupId];
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.lastValidAddress
                                                            = 0x118F0E03;
}


/*******************************************************************************
* xCat2ErrataAddrCheckWaDbInit
*
* DESCRIPTION:
*       Initialize Unit Address Ranges Data Base for Address Check WA.
*       The DB will be initialized according to the following Address ranges
*       list:
*           Where Unit Id is defined by bits 23-28.
*
*           1.      Unit 3
*               {0x01B40000, 0x01B7FFFC}
*               {0x01C00000, 0x01CBFFFC}
*               {0x01D00000, 0x01D3FFFC}
*               {0x01DC0000, 0x01DFFFFC}
*               {0x01E4000C, 0x01E7FFFC}
*
*           2.      Unit 7
*               {0x03801000, 0x038017FC}
*               {0x03901000, 0x03F017FC}
*
*           3.      Unit 12
*               {0x06000100, 0x063FFFFC}
*               {0x06500100, 0x067FFFFC}
*
*           4.      Unit 15
*               {0x07E40000, 0x07FFFFFC}
*
*           5.      Unit 19
*               {0x09805000, 0x0980FFFC}
*
*           6.      Unit 21
*               {0x0A807000, 0x0A80FBFC}
*
*           7.      Unit 23
*               {0x0B800800, 0x0B800FFC}
*               {0x0B840000, 0x0BF481FC}
*
*           8.      Unit 24
*               {0x0C000600, 0x0C0008FC}
*               {0x0C001800, 0x0C001FFC}
*               {0x0C006000, 0x0C006FFC}
*               {0x0C020000, 0x0C02106C}
*               {0x0C100600, 0x0C72106C}
*
*           9.      Unit 25
*               {0x0C801000, 0x0C8017FC}
*               {0x0C901000, 0x0C9017FC}
*
*           10.     Unit 26
*               {0x0D001000, 0x0D0017FC}
*               {0x0D101000, 0x0D1017FC}
*
*           11.     Unit 28
*               {0x0E000400, 0x0E0010FC}
*               {0x0E002000, 0x0E0027FC}
*               {0x0E100400, 0x0E7027FC}
*
*           12.     Unit 29
*               {0x0E800100, 0x0E8027FC}
*               {0x0E900100, 0x0EF027FC}
*
*           13.     Unit 30
*               {0x0F018000, 0x0F0187FC}
*               {0x0F118000, 0x0F7187FC}
*
* APPLICABLE DEVICES:
*        xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       None.
*
* COMMENTS:
*       Note: The ranges should be in growing order.
*
*******************************************************************************/
static GT_VOID xCat2ErrataAddrCheckWaDbInit
(
    IN  GT_U8               devNum
)
{
    GT_U32      unitId;     /* loop iterator */
    PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC  emptyUnit = EMPTY_UNIT_MAC; /* empty unit ranges */


    /* initialize XCAT DB */
    for (unitId = 0; unitId < UNITS_NUM_CNS; unitId++)
    {
        xCat2BadAddressRanges[unitId] = emptyUnit;
    }

    /* Unit 3 */
    xCat2BadAddressRanges[3].numOfRanges = (sizeof(xCat2Unit3RangesArray) / sizeof(xCat2Unit3RangesArray[0]));
    xCat2BadAddressRanges[3].rangesPtr = xCat2Unit3RangesArray;

    /* Unit 7 */
    xCat2BadAddressRanges[7].numOfRanges = (sizeof(xCat2Unit7RangesArray) / sizeof(xCat2Unit7RangesArray[0]));
    xCat2BadAddressRanges[7].rangesPtr = xCat2Unit7RangesArray;

    /* Unit 12 */
    xCat2BadAddressRanges[12].numOfRanges = (sizeof(xCat2Unit12RangesArray) / sizeof(xCat2Unit12RangesArray[0]));
    xCat2BadAddressRanges[12].rangesPtr = xCat2Unit12RangesArray;

    /* Unit 15 */
    xCat2BadAddressRanges[15].numOfRanges = (sizeof(xCat2Unit15RangesArray) / sizeof(xCat2Unit15RangesArray[0]));
    xCat2BadAddressRanges[15].rangesPtr = xCat2Unit15RangesArray;

    /* Unit 19 */
    xCat2BadAddressRanges[19].numOfRanges = (sizeof(xCat2Unit19RangesArray) / sizeof(xCat2Unit19RangesArray[0]));
    xCat2BadAddressRanges[19].rangesPtr = xCat2Unit19RangesArray;

    /* Unit 21 */
    xCat2BadAddressRanges[21].numOfRanges = (sizeof(xCat2Unit21RangesArray) / sizeof(xCat2Unit21RangesArray[0]));
    xCat2BadAddressRanges[21].rangesPtr = xCat2Unit21RangesArray;

    /* Unit 23 */
    xCat2BadAddressRanges[23].numOfRanges = (sizeof(xCat2Unit23RangesArray) / sizeof(xCat2Unit23RangesArray[0]));
    xCat2BadAddressRanges[23].rangesPtr = xCat2Unit23RangesArray;

    /* Unit 24 */
    xCat2BadAddressRanges[24].numOfRanges = (sizeof(xCat2Unit24RangesArray) / sizeof(xCat2Unit24RangesArray[0]));
    xCat2BadAddressRanges[24].rangesPtr = xCat2Unit24RangesArray;

    /* Unit 25 */
    xCat2BadAddressRanges[25].numOfRanges = (sizeof(xCat2Unit25RangesArray) / sizeof(xCat2Unit25RangesArray[0]));
    xCat2BadAddressRanges[25].rangesPtr = xCat2Unit25RangesArray;

    /* Unit 26 */
    xCat2BadAddressRanges[26].numOfRanges = (sizeof(xCat2Unit26RangesArray) / sizeof(xCat2Unit26RangesArray[0]));
    xCat2BadAddressRanges[26].rangesPtr = xCat2Unit26RangesArray;

    /* Unit 28 */
    xCat2BadAddressRanges[28].numOfRanges = (sizeof(xCat2Unit28RangesArray) / sizeof(xCat2Unit28RangesArray[0]));
    xCat2BadAddressRanges[28].rangesPtr = xCat2Unit28RangesArray;

    /* Unit 29 */
    xCat2BadAddressRanges[29].numOfRanges = (sizeof(xCat2Unit29RangesArray) / sizeof(xCat2Unit29RangesArray[0]));
    xCat2BadAddressRanges[29].rangesPtr = xCat2Unit29RangesArray;

    /* Unit 30 */
    xCat2BadAddressRanges[30].numOfRanges = (sizeof(xCat2Unit30RangesArray) / sizeof(xCat2Unit30RangesArray[0]));
    xCat2BadAddressRanges[30].rangesPtr = xCat2Unit30RangesArray;

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.unitRangesPtr[0]
                                                            = xCat2BadAddressRanges;
    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.lastValidAddress
                                                            = 0xF80C0FF;
}


/*******************************************************************************
* internal_hwPpLionStartInitSet
*
* DESCRIPTION:
*
*       Trigger the device to do 'start init' then wait for the device to finish
*       the operation. The function will wait up to 1 second for operation to
*       end
* APPLICABLE DEVICES:
*        Lion.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
* INPUTS:
*       devNum          - The Pp's device number.
*       regAddrExtendedGlobalControl - Address of register globalRegs.extendedGlobalControl
*       regAddrGlobalControl         - Address of register globalRegs.globalControl
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_TIMEOUT  - the device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_hwPpLionStartInitSet
(
    IN  GT_U8               devNum,
    IN  GT_U32              regAddrExtendedGlobalControl,
    IN  GT_U32              regAddrGlobalControl
)
{
    GT_U32              tmpData = 3;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_STATUS           rc;             /* Return code */
    GT_U32              portGroupId=0;  /* the port group Id - support multi-port-groups device */

    /* Check if start-Init was already done .
       check if register 0x5C bits [14:13] is 0x3 --> only in port group 0 */

    rc = prvCpssDrvHwPpGetRegField(devNum,
                                   regAddrExtendedGlobalControl,
                                   13, 2, &tmpData);
    if(rc != GT_OK)
        return rc;

    if(tmpData == 0x3)
    {
        return GT_OK;
    }

    /* set 1 second timeout */
    timeout = 100;
    tmpData = 0;

    while(tmpData != 1)
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init.
               This means HW problem... */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

       /* wait till : EEPROM initialization is done and Internal memory initialization is not done.
          Wait for register 0x5C bits [14:13] = 0x1 --> only in port group 0 */
        rc = prvCpssDrvHwPpGetRegField(devNum,
                                   regAddrExtendedGlobalControl,
                                   13, 2, &tmpData);
        if(rc != GT_OK)
            return rc;


#ifdef _FreeBSD
        /* under FreeBSD required longer timeout untill
         * ASIC reset finished
         */
        cpssOsTimerWkAfter(1000);
#else
        cpssOsTimerWkAfter(10);
#endif
        timeout--;
    }

    /* go over all group ports and do device init sequence */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        /****************/
        /* Start Init   */
        /****************/

        rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId,
                                                regAddrGlobalControl,
                                                31, 1, 0);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    /* set 1 second timeout */
    timeout = 100;
    tmpData = 0;
    while(tmpData != 3)
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init.
               This means HW problem... */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* wait till : Initialize is fully functional.
           Wait for register 0x5C bits [14:13] = 0x3 --> only in port group 0 */
        rc = prvCpssDrvHwPpGetRegField(devNum,
                                   regAddrExtendedGlobalControl,
                                   13, 2, &tmpData);
        if(rc != GT_OK)
            return rc;

#ifdef _FreeBSD
        /* under FreeBSD required longer timeout untill
         * ASIC reset finished
         */
        cpssOsTimerWkAfter(1000);
#else
        cpssOsTimerWkAfter(10);
#endif
        timeout--;
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpLionStartInitSet
*
* DESCRIPTION:
*
*       Trigger the device to do 'start init' then wait for the device to finish
*       the operation. The function will wait up to 1 second for operation to
*       end
* APPLICABLE DEVICES:
*        Lion.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_TIMEOUT  - the device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpLionStartInitSet
(
    IN  GT_U8               devNum
)
{
    return internal_hwPpLionStartInitSet(devNum,
                                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl,
                                         PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl);
}

/*******************************************************************************
* hwPpLionStartInitSet_PexOnly
*
* DESCRIPTION:
*
*       Trigger the device to do 'start init' then wait for the device to finish
*       the operation. The function will wait up to 1 second for operation to
*       end
* APPLICABLE DEVICES:
*        Lion.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_TIMEOUT  - the device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpLionStartInitSet_PexOnly
(
    IN  GT_U8               devNum
)
{
    return internal_hwPpLionStartInitSet(devNum,
                                         0x5C, /* PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl */
                                         0x58);/* PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl */
}


/*******************************************************************************
* hwPpLion2StartInitSet
*
* DESCRIPTION:
*
*       Trigger the device to do 'start init' then wait for the device to finish
*       the operation. The function will wait up to 1 second for operation to
*       end
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_TIMEOUT  - the device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpLion2StartInitSet
(
    IN  GT_U8               devNum
)
{
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC  *regsAddrPtr;
    GT_U32              tmpData;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_STATUS           rc;             /* Return code */
    GT_U32  timeToSleepMilisec;

#ifdef _FreeBSD
    /* under FreeBSD required longer timeout untill
     * ASIC reset finished
     */
    timeToSleepMilisec = 1000;
#else
    timeToSleepMilisec = 10;
#endif
    regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum);

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
    {
        return GT_OK;
    }


    /* Check Internal init done */
    rc = prvCpssHwPpGetRegField(devNum, regsAddrPtr->dfxUnits.server.initDoneStatus,
                                   0, 2, &tmpData);
    if(rc != GT_OK)
        return rc;

    if(tmpData == 0)
    {
        return GT_OK;
    }

    /* set 1 second timeout */
    timeout = 100;
    tmpData = 1;

    while(tmpData == 1)
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init. This means HW problem. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

       /* wait till : dfx_server init done */
        rc = prvCpssHwPpGetRegField(devNum, regsAddrPtr->dfxUnits.server.initDoneStatus,
                                   1, 1, &tmpData);
        if(rc != GT_OK)
            return rc;

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }

    /* Activating the start_tables_init */
    rc = prvCpssHwPpSetRegField(devNum, regsAddrPtr->dfxUnits.server.resetControl,
                                            2, 1, 0);
    if(rc != GT_OK)
        return rc;

    rc = prvCpssHwPpSetRegField(devNum, regsAddrPtr->dfxUnits.server.resetControl,
                                            2, 1, 1);
    if(rc != GT_OK)
        return rc;

    /* set 1 second timeout */
    timeout = 100;
    tmpData = 1;
    while(tmpData == 1)
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init. This means HW problem. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* wait for All_INIT_DONE. */
        rc = prvCpssHwPpGetRegField(devNum,
                                   regsAddrPtr->dfxUnits.server.initDoneStatus,
                                   0, 1, &tmpData);
        if(rc != GT_OK)
            return rc;

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }

    return GT_OK;
}


/*******************************************************************************
* hwPpLion3StartInitSet
*
* DESCRIPTION:
*
*       After DEV_INIT_DONE signal is asserted, software can read fully
*       functional state from the chip.
*
* APPLICABLE DEVICES:
*        xCat3; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum          - The Pp's device number.
*       ignoreInitDone  - Whether to return OK though initDone bits are still 'init_onGoing'.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_TIMEOUT  - the device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpLion3StartInitSet
(
    IN  GT_U8               devNum,
    IN  GT_BOOL             ignoreInitDone
)
{
    GT_U32              regAddr;        /* register address */
    GT_U32              tmpData;
    GT_U32              tmpData1;
    GT_U32              mask;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_STATUS           rc;             /* Return code */
    GT_U32              timeToSleepMilisec;
    GT_U32              tmFrequency = 0;/* tm dram frequency if != 0 tm is supported*/

#ifdef _FreeBSD
    /* under FreeBSD required longer timeout untill
     * ASIC reset finished
     */
    timeToSleepMilisec = 1000;
#else
    timeToSleepMilisec = 10;
#endif
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
    {
        return GT_OK;
    }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum) ||
       CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        timeout = 100;
        regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.initializationStatusDone;

        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            if (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                /* verify whether TM is supported*/
                rc = prvCpssDxChTMFreqGet(devNum, &tmFrequency);
                if(rc != GT_OK)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(rc, "cpssDxChHwPpPhase1Init-initDone: Fail to get TM frequency\n");
                }
            }
        }

        do
        {
            if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
            {
                break;
            }

            /* Check init stage status */
            rc = prvCpssDrvHwPpResetAndInitControllerReadReg(devNum, regAddr, &tmpData);
            if( GT_OK != rc )
            {
                return rc;
            }


            if(timeout == 0)
            {
                /* timeout, no initDone indication its System with TM or some other issue */
                if (ignoreInitDone)
                {
                    CPSS_LOG_INFORMATION_MAC("cpssDxChHwPpPhase1Init-initDone: ignore Uncompleted HW init value: %0x\n", tmpData);
                    tmpData = 0;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
                }
            }

            if(PRV_CPSS_DXCH_BOBCAT2_A0_CHECK_MAC(devNum))
            {   /* BC2 A0*/
                rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, 0xF8520, 0, 1, &tmpData1);
                if( GT_OK != rc )
                {
                    return rc;
                }
            }
            else
            {   /* BC2 B0 + XCAT3 */
                rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum, 0xF8F20, 0, 1, &tmpData1);
                if( GT_OK != rc )
                {
                    return rc;
                }
            }

            /************************************************************************
                On BC2/AC3 systems there might be IDEfuse burned devices with
                security bit enabled or disabled.

                When the security bit is disabled, in case of burning some
                effuse bits, we might run into an issue of wrong the
                <dfx_server_Init_Done>[1]  status indication (MSB bit of field {2:1})

                Thus, we need to check on the <dfx_server_Init_Done>[1] only when
                ID Efuse[256] - (bit [0] of 0x000F8F20) is burned to 0x1.
                If it's not burned (0x1) SW needs to check only on <dfx_server_Init_Done>[0] .

            ************************************************************************/
            if(tmpData1 == 1)
            {
                mask = 0xFFFFFDDE;
            }
            else
            {
                mask = 0xFFFFFDDA;
            }

            if(tmpData && tmFrequency)
            {
                if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
                {
                    if (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
                    {
                        /* system has TM, TM init status done after TM externam memory init, turn-off next bits:
                        12:  tm_Init_Done
                         8:  bc2 Init Done
                         4:  Table Init Done
                         1:  initDone-initOnGoing */
                        mask &= ~(0x1112);
                        CPSS_LOG_INFORMATION_MAC("cpssDxChHwPpPhase1Init-initDone: System has TM, ignore Uncompleted TM unit, init value: %0x, mask: %0x\n", tmpData, mask);
                    }
                }
            }


            #ifdef ASIC_SIMULATION
                /* single iteration is enough */
                tmpData = 0;
            #endif /*ASIC_SIMULATION*/

            if((tmpData & mask) == 0)
            {/* if all needed units passed init, clear "all init done" */
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr,
                                                                     0, 1, 0);
                if( GT_OK != rc )
                {
                    return rc;
                }
                break;
            }
            cpssOsTimerWkAfter(timeToSleepMilisec);
            timeout--;
        }
        while (1);
    }

    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                      DFXServerUnits.DFXServerRegs.serverStatus;

    timeout = 100;

    do
    {
        if(PRV_CPSS_PP_MAC(devNum)->ppHAState == CPSS_SYS_HA_MODE_STANDBY_E)
        {
            break;
        }

        if(timeout == 0)
        {
            /* time over, the device is not finished init. This means HW problem. */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* Check init stage status */
        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                               devNum, regAddr, 4, 2, &tmpData);
        if( GT_OK != rc )
        {
            return rc;
        }

        cpssOsTimerWkAfter(timeToSleepMilisec);
        timeout--;
    }
    while (tmpData != 0x3);

    return GT_OK;
}


/*******************************************************************************
* internal_cpssDxChHwPpPhase1Init
*
* DESCRIPTION:
*       This function performs basic hardware configurations on the given PP, in
*       Hw registration phase.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*
* OUTPUTS:
*       deviceTypePtr - The Pp's device Id.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - one of the parameters value is wrong
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_ALREADY_EXIST         - the devNum already in use
*       GT_NOT_SUPPORTED         - the device not supported by CPSS
*       GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
*       GT_BAD_VALUE             - the driver found unknown device type
*       GT_NOT_IMPLEMENTED       - the CPSS was not compiled properly
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpPhase1Init
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    OUT     CPSS_PP_DEVICE_TYPE                 *deviceTypePtr
)
{
    GT_STATUS rc ;
    GT_U8     devNum;
    GT_BOOL   multiPortGroupDevice = GT_FALSE;/*indication that the device is 'multi-port-groups' device */
    GT_U32    portGroupId;/*iterator for port group Id*/
    PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_ENT prePhase1InitMode;
    GT_BOOL   ignoreInitDone = GT_FALSE;
    CPSS_NULL_PTR_CHECK_MAC(ppPhase1ParamsPtr);
    CPSS_NULL_PTR_CHECK_MAC(deviceTypePtr);

    rc = prvCpssPrePhase1PpInitModeGet(&prePhase1InitMode);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("prvCpssPrePhase1PpInitModeGet(..) : return code is %d", rc);
        return rc;
    }

    if(ppPhase1ParamsPtr->busBaseAddr == CPSS_PARAM_NOT_USED_CNS)
    {
        /* this is indication that the device should be 'multi-port-groups' device */
        /* so we need to use the parameters of :
            ppPhase1ParamsPtr->numOfPortGroups
            ppPhase1ParamsPtr->multiPortGroupsInfoPtr
        */

        if(ppPhase1ParamsPtr->numOfPortGroups == 0 ||
           ppPhase1ParamsPtr->numOfPortGroups > CPSS_MAX_PORT_GROUPS_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        CPSS_NULL_PTR_CHECK_MAC(ppPhase1ParamsPtr->multiPortGroupsInfoPtr);

        multiPortGroupDevice = GT_TRUE;
    }

    devNum = ppPhase1ParamsPtr->devNum;

    /* check input parameters */
    if(devNum >= PRV_CPSS_MAX_PP_DEVICES_CNS)
    {
        /* bad device number -- out of range */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    else if(PRV_CPSS_PP_MAC(devNum))
    {
        /* the device occupied by some device ... */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_ALREADY_EXIST, LOG_ERROR_NO_MSG);
    }

    /* initialize the cpssDriver , build the DB needed for the device */
    rc = hwPpPhase1Part1(ppPhase1ParamsPtr,multiPortGroupDevice,deviceTypePtr);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part1(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    /* initialize only cpssDriver for HW access, skip the rest */
    if (dxChInitRegDefaults == GT_TRUE)
    {
        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
        {
            /* start init sequence for Lion */
            hwPpLionStartInitSet_PexOnly(devNum);
         }

        return GT_OK;
    }

    /* Trigger the device for the start-init operation. */
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
    {
        /* start init sequence for Lion */
        rc = hwPpLionStartInitSet(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpLionStartInitSet(..) : return code is %d", rc);
            return rc;
        }
     }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* start init sequence for Lion2 */
        rc = hwPpLion2StartInitSet(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpLion2StartInitSet(..) : return code is %d", rc);
            return rc;
        }
    }
    else if (PRV_CPSS_SIP_5_CHECK_MAC(devNum) ||
             PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        /* start init sequence for Bobcat2; Caelum; Bobcat3
        if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
        {
            if (PRV_CPSS_PP_MAC(devNum)->devSubFamily == CPSS_PP_SUB_FAMILY_BOBCAT2_BOBK_E)
            {
                / * WA for initDone * /
                ignoreInitDone = GT_TRUE;
            }
        }
        */
        rc = hwPpLion3StartInitSet(devNum, ignoreInitDone);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpLion3StartInitSet(..) : return code is %d", rc);
            return rc;
        }
     }

    /* initialize the board specific parameters and registers the packet
    processor for pre-discovery phase access and diagnostics */
    rc = hwPpPhase1Part2(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part2(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    if(multiPortGroupDevice == GT_FALSE)
    {
        /* Initialize the interrupts mechanism for a given device. */
        rc = prvCpssDrvInterruptsInit(devNum,CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS,
                                 ppPhase1ParamsPtr->intVecNum,
                             (GT_U32)ppPhase1ParamsPtr->intMask);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("prvCpssDrvInterruptsInit(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }
    }
    else
    {
        /* the per port group information taken from ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId] */
        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
        {
            /* Initialize the interrupts mechanism for a given device. */
            rc = prvCpssDrvInterruptsInit(devNum,portGroupId,
                                     ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].intVecNum,
                                     (GT_U32)ppPhase1ParamsPtr->multiPortGroupsInfoPtr[portGroupId].intMask);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDrvInterruptsInit(..) : return code is %d", rc);
                goto exit_cleanly_lbl;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    }

    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        /* do enhanced initialization of SW and HW parameters , if needed */
        if(prvCpssDxChPpConfigEnhancedInitFuncPtr)
        {
            rc = prvCpssDxChPpConfigEnhancedInitFuncPtr(devNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("prvCpssDxChPpConfigEnhancedInitFuncPtr(..) : return code is %d", rc);
                goto exit_cleanly_lbl;
            }
        }
    }
    /* init Cheetah tables database .
       called after : prvCpssDxChPpConfigEnhancedInitFuncPtr
       but should be called even if prvCpssDxChPpConfigEnhancedInitFuncPtr
       is NULL
    */
    rc = prvCpssDxChTablesAccessInit(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("prvCpssDxChTablesAccessInit(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        /* Set Errata issues and registers settings.*/
        rc = hwPpPhase1Part3(devNum, ppPhase1ParamsPtr);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part3(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }
    }
    /* wait for the device to be ready for traffic */
    rc = hwPpPhase1Part4(devNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

    /* set RM (Register Miss-configuration) after tables initialization */
    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        rc = hwPpPhase1RegisterMisconfigurationAfterTablesInit(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1RegisterMisconfigurationAfterTablesInit(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }
    }
    /* set final phase 1 register settings :
       called after : prvCpssDxChPpConfigEnhancedInitFuncPtr
       but should be called even if prvCpssDxChPpConfigEnhancedInitFuncPtr
       is NULL
       */
    if (prePhase1InitMode != PRV_CPSS_PP_PRE_PHASE1_INIT_MODE_NO_PP_INIT_E)
    {
        rc = hwPpPhase1Part5(devNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }

        /* set final phase 1 register settings for devices with internal CPU (xCat etc.) where this CPI is disabled    */
        rc = hwPpPhase1Part6(devNum, ppPhase1ParamsPtr);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part6(..) : return code is %d", rc);
            goto exit_cleanly_lbl;
        }

        if (systemRecoveryInfo.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
        {
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->genInfo.devFamily >= CPSS_PP_FAMILY_DXCH_BOBCAT2_E)
            {
                rc = prvCpssDxChPortDynamicPATxQHighSpeedPortInit(devNum);
                if (GT_OK != rc)
                {
                    return rc;
                }
            }
        }

    }
exit_cleanly_lbl:
    if(rc != GT_OK && PRV_CPSS_DXCH_PP_MAC(devNum))
    {
        /* restore all the DB state to start point */
        (void)prvCpssDxChHwRegAddrDbRemove(devNum);

        /* do not modify 'rc' that hold ERROR at this point */

        /* free the memory of this device */
        cpssOsFree(PRV_CPSS_PP_MAC(devNum));

        /* set this index as "not occupied" */
        prvCpssPpConfig[devNum] = NULL;
        dxCh_prvCpssPpConfig[devNum] = prvCpssPpConfig[devNum];
    }

    return rc;
}

/*******************************************************************************
* cpssDxChHwPpPhase1Init
*
* DESCRIPTION:
*       This function performs basic hardware configurations on the given PP, in
*       Hw registration phase.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       ppPhase1ParamsPtr  - Packet processor hardware specific parameters.
*
* OUTPUTS:
*       deviceTypePtr - The Pp's device Id.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - one of the parameters value is wrong
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_ALREADY_EXIST         - the devNum already in use
*       GT_NOT_SUPPORTED         - the device not supported by CPSS
*       GT_OUT_OF_CPU_MEM        - failed to allocate CPU memory,
*       GT_BAD_VALUE             - the driver found unknown device type
*       GT_NOT_IMPLEMENTED       - the CPSS was not compiled properly
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpPhase1Init
(
    IN      CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr,
    OUT     CPSS_PP_DEVICE_TYPE                 *deviceTypePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpPhase1Init);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, ppPhase1ParamsPtr, deviceTypePtr));

    rc = internal_cpssDxChHwPpPhase1Init(ppPhase1ParamsPtr, deviceTypePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, ppPhase1ParamsPtr, deviceTypePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* hwPpPhase1Part4
*
* DESCRIPTION:
*       Part 4 of "phase 1"
*       wait for the device , until it is ready for traffic,
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part4
(
    IN  GT_U8               devNum
)
{
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC  *    regsAddrPtr;
    GT_U32              tmpData;
    GT_U32              timeout;        /* Timeout for waiting for the      */
                                        /* startinit operation to be done.  */
    GT_U32              portGroupId;/*port group Id*/

    /* not needed for xCat3; Lion2; Bobcat2; Caelum; Bobcat3 */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E ||
        (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE) ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        return GT_OK;
    }
    regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum);

    /* read Init State field */
    if(prvCpssDrvHwPpGetRegField(devNum, regsAddrPtr->globalRegs.globalControl,
                              17, 2, &tmpData) != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : prvCpssDrvHwPpGetRegField(..) : GT_HW_ERROR");
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    /*need to support multi port groups device,to loop on all port groups*/
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        /* set 1 second timeout */
        timeout = 100;
        while(tmpData != 3)
        {
            if(timeout == 0)
            {
                /* time over, the device is not finished init.
                   This means HW problem... */
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : timeout == 0 : GT_FAIL");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            }

            /* wait till : Initialize is fully functional. */
            if(prvCpssDrvHwPpPortGroupGetRegField(devNum, portGroupId,regsAddrPtr->globalRegs.globalControl,
                                      17, 2, &tmpData) != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part4(..) : prvCpssDrvHwPpPortGroupGetRegField(..) : GT_HW_ERROR");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            cpssOsTimerWkAfter(10);
            timeout--;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)


    return GT_OK;
}

/*******************************************************************************
* hwPpPhase1Part5
*
* DESCRIPTION:
*       Part 5 of "phase 1"
*       set part 5 phase 1 register settings -
*       called after : prvCpssDxChPpConfigEnhancedInitFuncPtr
*      but should be called even if prvCpssDxChPpConfigEnhancedInitFuncPtr
*      is NULL
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The Pp's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part5
(
    IN  GT_U8               devNum
)
{
    PRV_CPSS_DXCH_PP_REGS_ADDR_STC  *    regsAddrPtr;
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;
    GT_U32    txDescNum;    /* number of transmit descriptors */
    GT_STATUS rc; /* returned status */
    GT_U32    startBit;/*start bit of the field */
    GT_BOOL   didHwReset; /* flag indicating whether HW reset was done */
    GT_U32    regAddr;/* register address */

    fineTuningPtr = &PRV_CPSS_DXCH_PP_MAC(devNum)->fineTuning;

    if(PRV_CPSS_PP_MAC(devNum)->devFamily >= CPSS_PP_FAMILY_CHEETAH3_E)
    {
        /* Set the FDB size configuration */
        rc = prvCpssDxChBrgFdbSizeSet(devNum,fineTuningPtr->tableSize.fdb);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else /* initialize for FDB of CH1,2 */
    {
        if(fineTuningPtr->tableSize.fdb == _8K)
        {
            PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.fdbHashParams.size =
                    CPSS_DXCH_BRG_FDB_TBL_SIZE_8K_E;
        }
        else
        {
            PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.fdbHashParams.size =
                    CPSS_DXCH_BRG_FDB_TBL_SIZE_16K_E;
        }
    }

    if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum))
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_HA_MAC(devNum).haGlobalConfig;
            startBit = 12;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig;
            startBit = 11;
        }

        /* TR101 feature configuration */
        rc = prvCpssDrvHwPpSetRegField(devNum,
                                       regAddr,
                                       startBit,
                                       1,
               BOOL2BIT_MAC(fineTuningPtr->featureInfo.tr101Supported));
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
            return rc;
        }

        /* Resources - buffers & descriptors - size configuration for xCat devices */
        if( (CPSS_PP_FAMILY_DXCH_XCAT_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
            (CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
            (CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily))
        {
            regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum);
            txDescNum = fineTuningPtr->tableSize.transmitDescr;

            /* MaxBufLimit */
            rc = prvCpssDrvHwPpSetRegField(devNum,
                                           regsAddrPtr->bufferMng.bufMngGlobalLimit,
                                           22, 9,
                                           (txDescNum >> 5 ) - ((txDescNum == _2K) ? 1 : 2 ));
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* GlobalXoff */
            rc = cpssDxChGlobalXoffLimitSet(devNum,(txDescNum - 8)/2);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChGlobalXoffLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GlobalXon */
            rc = cpssDxChGlobalXonLimitSet(devNum,(txDescNum - 8)/2);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChGlobalXonLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GPortsMaxBufLimit */
            rc = cpssDxChPortGroupRxBufLimitSet(devNum, CPSS_DXCH_PORT_GROUP_GIGA_E,
                                                txDescNum - 16);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortGroupRxBufLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GPortsXoff */
            rc = cpssDxChPortGroupXoffLimitSet(devNum, CPSS_DXCH_PORT_GROUP_GIGA_E,
                                               txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortGroupXoffLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* GPortsXon */
            rc = cpssDxChPortGroupXonLimitSet(devNum, CPSS_DXCH_PORT_GROUP_GIGA_E,
                                              txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortGroupXonLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* HGSPortsMaxBufLimit */
            rc = cpssDxChPortGroupRxBufLimitSet(devNum, CPSS_DXCH_PORT_GROUP_HGS_E,
                                                txDescNum - 16);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortGroupRxBufLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* HGSPortsXoff */
            rc = cpssDxChPortGroupXoffLimitSet(devNum, CPSS_DXCH_PORT_GROUP_HGS_E,
                                               txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortGroupXoffLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* HGSPortsXon */
            rc = cpssDxChPortGroupXonLimitSet(devNum, CPSS_DXCH_PORT_GROUP_HGS_E,
                                              txDescNum - 8);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortGroupXonLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* MaxSharedBuffersLimit */
            rc = cpssDxChPortTxBuffersSharingMaxLimitSet(devNum, txDescNum - 1);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortTxBuffersSharingMaxLimitSet(..) : return code is %d", rc);
                return rc;
            }

            rc = prvCpssPpConfigDevDbHwResetGet(devNum, &didHwReset);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssPpConfigDevDbHwResetGet(..) : return code is %d", rc);
                return rc;
            }

            if( GT_TRUE == didHwReset )
            {
                /* FllWrEn set:Write to fll memory, fll_head_ptr and fll_tail_ptr enabled */
                rc = prvCpssDrvHwPpSetRegField(devNum,
                                               regsAddrPtr->bufferMng.bufMngMetalFix,
                                               0, 1, 1);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                    return rc;
                }

                /* LlTailPtr */
                rc = prvCpssDrvHwPpSetRegField(devNum,
                                               regsAddrPtr->bufferMng.linkedListTailPtr,
                                               0, 14, txDescNum - 1);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                    return rc;
                }

                /* FllWrEn unset */
                rc = prvCpssDrvHwPpSetRegField(devNum,
                                               regsAddrPtr->bufferMng.bufMngMetalFix,
                                               0, 1, 0);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                    return rc;
                }
            }

            /* TotalBuffersLimit */
            rc = prvCpssDrvHwPpSetRegField(devNum,
                                           regsAddrPtr->egrTxQConf.totalBufferLimitConfig,
                                           0, 18, txDescNum - 1);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* TotalDescLimit */
            rc = prvCpssDrvHwPpSetRegField(devNum,
                                           regsAddrPtr->egrTxQConf.txQueueConfig,
                                           16, 16,
                                           txDescNum - PRV_DXCH_XCAT_PRE_ALLOC_DESC_CNS);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* LinkListSize */
            rc = prvCpssDrvHwPpSetRegField(devNum,
                                           regsAddrPtr->egrTxQConf.linkListControlConfig,
                                           0, 2,
                                           (txDescNum == _2K) ? 1 : ((txDescNum == _4K) ? 2 : 0) );
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssDrvHwPpSetRegField(..) : return code is %d", rc);
                return rc;
            }

            /* SharePoolBufLimit, SharePoolDescLimit */
            rc = cpssDxChPortTxSharedGlobalResourceLimitsSet(devNum,
                                                             txDescNum - 4,
                                                             txDescNum - 4);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortTxSharedGlobalResourceLimitsSet(..) : return code is %d", rc);
                return rc;
            }
        }
    }

    /* Resources - buffers & descriptors - size configuration for Bobcat2 devices */
    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        if(fineTuningPtr->tableSize.transmitDescr == _8K)
        {
            /* Limits of total descriptors in all egress queues */
            rc = cpssDxChPortTxGlobalDescLimitSet(devNum, 0x1D98);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : cpssDxChPortTxGlobalDescLimitSet(..) : return code is %d", rc);
                return rc;
            }

            /* Limits the total number of buffers in all egress queues */
            regAddr = PRV_DXCH_REG1_UNIT_TXQ_Q_MAC(devNum).
                                    tailDrop.tailDropLimits.globalBufferLimit;
            rc = prvCpssHwPpPortGroupSetRegField(devNum,
                                                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                regAddr, 0, 20, 0x2000);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part5(..) : prvCpssHwPpPortGroupSetRegField(..) : return code is %d", rc);
                return rc;
            }
        }
    }

    return GT_OK;

}

/*******************************************************************************
* hwPpPhase1Part6
*
* DESCRIPTION:
*       Part 6 of "phase 1"
*       Set final phase 1 register settings for devices with internal CPU (xCat etc.) where this CPU is disabled
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion.
*
* INPUTS:
*       devNum            - The Pp's device number.
*       ppPhase1ParamsPtr - (pointer to) phase1 parameters
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpPhase1Part6
(
    IN  GT_U8               devNum,
    IN  CPSS_DXCH_PP_PHASE1_INIT_INFO_STC   *ppPhase1ParamsPtr
)
{
    GT_STATUS   rc; /* returned status */
    GT_BOOL     pexWindUpd = GT_FALSE;
    GT_U32      baseAddrVal = 0, sizeVal = 0xFFFF0000, baseAddrEn = 0x3e;
    GT_U32      regAddr; /* register address */

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E)
    {/* For xCat: if internal CPU is disabled (bit 17 of device type is 1) or
        external CPU is connected - set address decoding register */
        pexWindUpd = ((PRV_CPSS_PP_MAC(devNum)->devType) & 0x20000)
                        || (ppPhase1ParamsPtr->isExternalCpuConnected == GT_TRUE);
        baseAddrVal = 0x0000080F; /* set window's target to PEX [0xF] with memory attribute [0x08] */
    }
    else if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        pexWindUpd = (ppPhase1ParamsPtr->isExternalCpuConnected == GT_TRUE);
        baseAddrVal = 0xe804;/* attribute 0xe8, target 0x4 */
    }

    if(pexWindUpd)
    {
        /* Base_Address_0 register 0x30C */
        regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddress[0];
        rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, baseAddrVal);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part6(..) : prvCpssDrvHwPpWriteRegister(..) :return code is %d", rc);
            return rc;
        }

        /* Size_0 register - set to max windows size */
        regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.windowSize[0];
        rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, sizeVal);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part6(..) : prvCpssDrvHwPpWriteRegister(..) :return code is %d", rc);
            return rc;
        }

        /* Base_Address_Enable register - window0 enable */
        regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
        rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, baseAddrEn);
        if (rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase1Part6(..) : prvCpssDrvHwPpWriteRegister(..) :return code is %d", rc);
            return rc;
        }
    }

    return GT_OK;

}

/*******************************************************************************
* hwPpPhase2
*
* DESCRIPTION:
*       Set new devNumber to the PP in Hw and in PP,
*       update the cpssDriver
*       initialize the AU descriptors
*       initialize the FU descriptors
*       initialize the network interface
*
*       Assume that we are under "locked interrupts"
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       oldDevNum          - The PP's "old" device number.
*       ppPhase2ParamsPtr  - Phase2 initialization parameters..
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*
* COMMENTS:
*       function called when PP's interrupts are disabled !
*
*******************************************************************************/
static GT_STATUS hwPpPhase2
(
    IN  GT_U8                                oldDevNum,
    IN  CPSS_DXCH_PP_PHASE2_INIT_INFO_STC    *ppPhase2ParamsPtr
)
{
    GT_STATUS   rc;
    PRV_CPSS_DXCH_MODULE_CONFIG_STC *moduleCfgPtr;/* module config of the device */
    GT_U8   newDevNum = ppPhase2ParamsPtr->newDevNum;/* the new devNum*/
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr;/* pointer to common device info */
    GT_BOOL         enable;/* enable value returned from hw */
    CPSS_DXCH_BRG_EGR_FLT_VLAN_PORT_ACCESS_MODE_ENT fltTabAccessMode;
                           /* port VLAN egress filtering table access mode */

    /* update the driver about this action */
    /* let the cpss driver know that the device changed number */
    rc = prvCpssDrvHwPpPhase2Init(oldDevNum,newDevNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDrvHwPpPhase2Init(..) : return code is %d", rc);
        return rc;
    }

    /* update the DB of the CPSS */

    if(oldDevNum != newDevNum)
    {
        /* set the DB of "old" device number to the "new" device number */
        prvCpssPpConfig[newDevNum] = PRV_CPSS_PP_MAC(oldDevNum);
        /* invalidate the "old" place */
        prvCpssPpConfig[oldDevNum] = NULL;

        dxCh_prvCpssPpConfig[newDevNum] = prvCpssPpConfig[newDevNum];
        dxCh_prvCpssPpConfig[oldDevNum] = prvCpssPpConfig[oldDevNum];

        /* swap the device number at the special DB */
        rc = prvCpssPpConfigDevDbRenumber(oldDevNum,newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssPpConfigDevDbRenumber(..) : return code is %d", rc);
            return rc;
        }
    }

    /*************************************************/
    /* from now on we only use the new device number */
    /*************************************************/
    devPtr = PRV_CPSS_PP_MAC(newDevNum);

    /* update the devNum of the device */
    devPtr->devNum = newDevNum;

    if(devPtr->devFamily == CPSS_PP_FAMILY_CHEETAH_E)
    {
        /* ignore this parameter for cheetah devices , because no HW support anyway */
        ppPhase2ParamsPtr->fuqUseSeparate = GT_FALSE;
    }

    if(PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(newDevNum))
    {
        if (ppPhase2ParamsPtr->netifSdmaPortGroupId != CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
        {
            /* check requested port group is active one */
            if( (ppPhase2ParamsPtr->netifSdmaPortGroupId < PRV_CPSS_PP_MAC(newDevNum)->portGroupsInfo.firstActivePortGroup) ||
                (ppPhase2ParamsPtr->netifSdmaPortGroupId > PRV_CPSS_PP_MAC(newDevNum)->portGroupsInfo.lastActivePortGroup)  ||
                (0 == (PRV_CPSS_PP_MAC(newDevNum)->portGroupsInfo.activePortGroupsBmp &
                                         (1<<(ppPhase2ParamsPtr->netifSdmaPortGroupId)))) )
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : check requested port group is active one : GT_FAIL");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
            }
            /* check that this port group is active ... */
            if (0==(devPtr->portGroupsInfo.activePortGroupsBmp & (1 << ppPhase2ParamsPtr->netifSdmaPortGroupId)))
            {
                /* the needed port group is not active , so can't be used for RGMII */
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : the needed port group is not active , so can't be used for RGMII : GT_BAD_PARAM");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }
        /* here not important which CPU port mode actually used */
        devPtr->portGroupsInfo.cpuPortPortGroupId = devPtr->netifSdmaPortGroupId = ppPhase2ParamsPtr->netifSdmaPortGroupId;

    }
    else
    {
        /* cpuPortPortGroupId for such boards configured in hwPpPhase1Part1 */
        devPtr->portGroupsInfo.cpuPortPortGroupId = devPtr->netifSdmaPortGroupId = PRV_CPSS_FIRST_ACTIVE_PORT_GROUP_ID_MAC(newDevNum);
    }

    devPtr->noTraffic2CPU = ppPhase2ParamsPtr->noTraffic2CPU;
    /*--------------------------*/
    /* initialize pizza arbiter */
    /*--------------------------*/
    if(   devPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E )
    {
        if (systemRecoveryInfo.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
        {
            rc = prvCpssDxChPortPizzaArbiterIfInit(newDevNum);
            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDxChPortPizzaArbiterIfInit(..) : return code is %d", rc);
                return rc;
            }
        }
    }

    if( PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(newDevNum)==GT_TRUE)
    {
        rc = prvCpssDxChPortPizzaArbiterIfInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDxChPortPizzaArbiterIfInit(..) : return code is %d", rc);
            return rc;
        }

        rc = prvCpssDxChPortResourcesInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDxChPortResourcesInit(..) : return code is %d", rc);
            return rc;
        }
    }

    /* update the special DB -- must be called after the device numbers swapped
       in prvCpssPpConfig and after prvCpssPpConfigDevDbRenumber was called */
    rc = prvCpssPpConfigDevDbInfoSet(newDevNum,
                                    &ppPhase2ParamsPtr->netIfCfg,
                                    &ppPhase2ParamsPtr->auqCfg,
                                    ppPhase2ParamsPtr->fuqUseSeparate,
                                    &ppPhase2ParamsPtr->fuqCfg);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssPpConfigDevDbInfoSet(..) : return code is %d", rc);
        return rc;
    }

    /* update the HW about the new devNum */
    /* Device number  */
    if (systemRecoveryInfo.systemRecoveryProcess != CPSS_SYSTEM_RECOVERY_PROCESS_FAST_BOOT_E)
    {
        rc = cpssDxChCfgHwDevNumSet(newDevNum,newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChCfgHwDevNumSet(..) : return code is %d", rc);
            return rc;
        }
    }


    if(ppPhase2ParamsPtr->useSecondaryAuq == GT_FALSE)
    {
        /* the WA not requested by the application , even if may be required */
        PRV_CPSS_DXCH_ERRATA_CLEAR_MAC(newDevNum,
            PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E);
    }

    /* Now set the rest of the parameters into the  */
    /* module configuration struct in ppConfig.     */
    moduleCfgPtr = PRV_CPSS_DXCH_DEV_MODULE_CFG_MAC(newDevNum);

    moduleCfgPtr->fuqUseSeparate = ppPhase2ParamsPtr->fuqUseSeparate;
    /* AUQ config               */
    moduleCfgPtr->auCfg.auDescBlock     = ppPhase2ParamsPtr->auqCfg.auDescBlock;
    moduleCfgPtr->auCfg.auDescBlockSize = ppPhase2ParamsPtr->auqCfg.auDescBlockSize;
    /* Use addtional primary AU queue */
    moduleCfgPtr->useDoubleAuq = ppPhase2ParamsPtr->useDoubleAuq;

    /* FUQ config               */
    moduleCfgPtr->fuCfg.fuDescBlock     = ppPhase2ParamsPtr->fuqCfg.auDescBlock;
    moduleCfgPtr->fuCfg.fuDescBlockSize = ppPhase2ParamsPtr->fuqCfg.auDescBlockSize;

    /* Network interface config */
    cpssOsMemCpy(&(moduleCfgPtr->netIfCfg.rxBufInfo),
             &(ppPhase2ParamsPtr->netIfCfg.rxBufInfo),sizeof(CPSS_RX_BUF_INFO_STC));

    moduleCfgPtr->netIfCfg.rxDescBlock     = ppPhase2ParamsPtr->netIfCfg.rxDescBlock;
    moduleCfgPtr->netIfCfg.rxDescBlockSize =
        ppPhase2ParamsPtr->netIfCfg.rxDescBlockSize;
    moduleCfgPtr->netIfCfg.txDescBlock     = ppPhase2ParamsPtr->netIfCfg.txDescBlock;
    moduleCfgPtr->netIfCfg.txDescBlockSize =
        ppPhase2ParamsPtr->netIfCfg.txDescBlockSize;

    moduleCfgPtr->useMultiNetIfSdma = ppPhase2ParamsPtr->useMultiNetIfSdma;
    moduleCfgPtr->multiNetIfCfg = ppPhase2ParamsPtr->multiNetIfCfg;

    /* configure Policer memories sizes */
    if (PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(newDevNum))
    {
        /* xCat */

        if (PRV_CPSS_DXCH_PP_MAC(newDevNum)->
            fineTuning.featureInfo.iplrSecondStageSupported)
        {
            /* There are two Policer Ingress stages, 256 to lower and the rest to
               upper memory */
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[0] =
                (PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.policersNum - 256);
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[1] = 256;

            /* fix xCat2 HW default for memory configuration to be
                PLR0_28_PLR1_172_84; Policer 0 uses one memory 28
                Policer 1 uses two memories 172+84 = 256.
                Fix Lion2 HW default like xCat and Lion -
                Policer 1 256 entiries, Policer 0 rest.  */
            if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(newDevNum,
                     PRV_CPSS_DXCH_XCAT2_RM_POLICER_MEM_CONTROL_WA_E))
            {
                rc = cpssDxChPolicerMemorySizeModeSet(newDevNum, CPSS_DXCH_POLICER_MEMORY_CTRL_MODE_0_E);
                if (rc != GT_OK)
                {
                    CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMemorySizeModeSet(..) : return code is %d", rc);
                    return rc;
                }
            }
        }
        else
        {
            /* Only one Policer Ingress stage supported.
               Configure memory to be only for IPLR0. */
            rc = cpssDxChPolicerMemorySizeModeSet(newDevNum,
                     CPSS_DXCH_POLICER_MEMORY_CTRL_MODE_PLR0_UPPER_AND_LOWER_E);
            if (rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChPolicerMemorySizeModeSet(..) : return code is %d", rc);
                return rc;
            }
        }

        /* Policer Egress memory size */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[2] =
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.egressPolicersNum;
    }
    else
    {
        /* DxCh1-DxCh3 */

        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[0] =
            PRV_CPSS_DXCH_PP_MAC(newDevNum)->fineTuning.tableSize.policersNum;
        /* No Egress nor Ingress #1 Policer memories */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[1] = 0;
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.memSize[2] = 0;
    }

    PRV_CPSS_DXCH_PP_MAC(newDevNum)->policer.meteringCalcMethod =
        CPSS_DXCH_POLICER_METERING_CALC_METHOD_CIR_ONLY_E;

    rc = prvCpssDrvInterruptsAfterPhase2(oldDevNum,newDevNum);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDrvInterruptsAfterPhase2(..) : return code is %d", rc);
        return rc;
    }

    /* we are checking if the eArch is supported and not enabled because it is
       possible to have <ePort and eVLAN Enable> = Disable and <Extended AU
       Message Enable> is a valide configuration resulting by extended AU
       message to the CPU. */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(newDevNum) == GT_TRUE)
    {
        /* set FDB Data base*/
        switch(ppPhase2ParamsPtr->auMessageLength)
        {
            case  CPSS_AU_MESSAGE_LENGTH_4_WORDS_E:
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : ppPhase2ParamsPtr->auMessageLength == CPSS_AU_MESSAGE_LENGTH_4_WORDS_E : GT_NOT_SUPPORTED");
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            case CPSS_AU_MESSAGE_LENGTH_8_WORDS_E:
                PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.auMessageNumOfWords = 8;
                break;
            default:
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : ppPhase2ParamsPtr->auMessageLength == %d : GT_NOT_SUPPORTED", ppPhase2ParamsPtr->auMessageLength);
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* get default value from hw */
        rc = cpssDxChBrgFdbMaxLengthSrcIdEnableGet(newDevNum, &enable);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgFdbMaxLengthSrcIdEnableGet(..) : return code is %d", rc);
            return rc;
        }

        /* set FDB data base */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.maxLengthSrcIdInFdbEn = enable;

        /* get default value from hw */
        rc = cpssDxChBrgFdbVid1AssignmentEnableGet(newDevNum, &enable);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgFdbVid1AssignmentEnableGet(..) : return code is %d", rc);
            return rc;
         }

        /* set FDB data base */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.tag1VidFdbEn = enable;

        /* get default value from hw */
        rc = cpssDxChBrgEgrFltVlanPortAccessModeGet(newDevNum, &fltTabAccessMode);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChBrgEgrFltVlanPortAccessModeGet(..) : return code is %d", rc);
            return rc;
        }

        /* set FDB data base */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.portVlanfltTabAccessMode = fltTabAccessMode;

        /* get default value from hw */
        /* and save to database */
        rc = cpssDxChNstPortIsolationLookupBitsGet(newDevNum,
                    &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupPortBits,
                    &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupDeviceBits,
                    &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkBits);

        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupBitsGet(..) : return code is %d", rc);
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupDeviceBits != 5)
        {
            /* restore BC3 defaults to be like in legacy devices */
            rc = cpssDxChNstPortIsolationLookupBitsSet(newDevNum,
                        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupPortBits,
                        5,/*device Bits*/
                        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkBits);

            if(rc != GT_OK)
            {
                CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupBitsSet(..) : return code is %d", rc);
                return rc;
            }
         }


        /* get default value from hw */
        /* and save to database */
        rc = cpssDxChNstPortIsolationLookupTrunkIndexBaseGet(newDevNum,
            &PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkIndexBase);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : cpssDxChNstPortIsolationLookupTrunkIndexBaseGet(..) : return code is %d", rc);
            return rc;
        }

    }
    else
    {
        /* AU message size is 4 words */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->bridge.auMessageNumOfWords = 4;

        /* set Port data base - default value is 6 bits*/
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupPortBits = 6;

        /* set Port data base - default value is 5 bits*/
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupDeviceBits = 5;

        /* set Port data base - default value is 7 bits*/
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkBits = 7;

        /* set Port data base - default value is _2K */
        PRV_CPSS_DXCH_PP_MAC(newDevNum)->port.portIsolationLookupTrunkIndexBase = _2K;
    }

    /*--------------------*/
    /* init MAC TG driver */
    /*--------------------*/
    if(   PRV_CPSS_SIP_5_CHECK_MAC(newDevNum)
       || PRV_CPSS_PP_MAC(newDevNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        rc = prvCpssDxChMacTGDrvInit(newDevNum);
        if(rc != GT_OK)
        {
            CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : prvCpssDxChMacTGDrvInit(..) : return code is %d", rc);
            return rc;
        }
    }
    return GT_OK;
}

/*******************************************************************************
* internal_cpssDxChHwPpPhase2Init
*
* DESCRIPTION:
*       This function performs basic hardware configurations on the given PP.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The PP's device number.
*       ppPhase2ParamsPtr  - Phase2 initialization parameters..
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success, or
*       GT_FAIL otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpPhase2Init
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PP_PHASE2_INIT_INFO_STC       *ppPhase2ParamsPtr
)
{

    GT_STATUS  rc;
    GT_32      intKey;/* Interrupt key.                   */
    GT_U8   oldDevNum;/* the "old" device number -- as was given in "phase 1" */

    oldDevNum =  devNum;

    CPSS_NULL_PTR_CHECK_MAC(ppPhase2ParamsPtr);
    PRV_CPSS_DXCH_DEV_CHECK_MAC(oldDevNum);

    if(ppPhase2ParamsPtr->newDevNum != oldDevNum)
    {
        /* we need to check the new device number */

        /* check input parameters */
        if(ppPhase2ParamsPtr->newDevNum >= PRV_CPSS_MAX_PP_DEVICES_CNS)
        {
            /* bad device number -- out of range */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        else if(PRV_CPSS_PP_MAC(ppPhase2ParamsPtr->newDevNum))
        {
            /* the device occupied by some device ... */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_ALREADY_EXIST, LOG_ERROR_NO_MSG);
        }
    }

    /* Lock the interrupts, this phase changes the interrupts nodes       */
    /* pool data. And relocates the port group / driverPpDevs elements.   */
    cpssExtDrvSetIntLockUnlock(CPSS_OS_INTR_MODE_LOCK_E,&intKey);

    /*
    *       Set new devNumber to the PP in Hw and in PP,
    *       update the cpssDriver
    *       initialize the AU descriptors
    *       initialize the network interface
    */
    rc = hwPpPhase2(oldDevNum,ppPhase2ParamsPtr);
    if(rc != GT_OK)
    {
        CPSS_LOG_INFORMATION_MAC("hwPpPhase2(..) : return code is %d", rc);
        goto exit_cleanly_lbl;
    }

exit_cleanly_lbl:
    /* UnLock the interrupts */
    cpssExtDrvSetIntLockUnlock(CPSS_OS_INTR_MODE_UNLOCK_E,&intKey);

    return rc;

}

/*******************************************************************************
* cpssDxChHwPpPhase2Init
*
* DESCRIPTION:
*       This function performs basic hardware configurations on the given PP.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The PP's device number.
*       ppPhase2ParamsPtr  - Phase2 initialization parameters..
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success, or
*       GT_FAIL otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpPhase2Init
(
    IN  GT_U8                                   devNum,
    IN  CPSS_DXCH_PP_PHASE2_INIT_INFO_STC       *ppPhase2ParamsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpPhase2Init);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ppPhase2ParamsPtr));

    rc = internal_cpssDxChHwPpPhase2Init(devNum, ppPhase2ParamsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ppPhase2ParamsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* hwPpPhyRegisterWrite
*
* DESCRIPTION:
*       Performs smi Phy write operation including poling on Buzy bit.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - device number.
*       addr - the smi phy configuration register.
*       data - data to write including the phy address.
*       mask - perform read modify write.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_TIMEOUT - on timed out retries
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpPhyRegisterWrite
(
    IN GT_U8  devNum,
    IN GT_U32 addr,
    IN GT_U32 mask,
    IN GT_U32 data
)
{
    GT_U32      smiRegConfig;     /* holds the content of the
                                  configuration register*/
    GT_U32      busyBitNumber;    /* holds the smi busy valid bit number*/
    GT_BOOL     isXgPort;         /* GT_TRUE - XG port PHY is configured
                                     GT_FALSE - GE port PHY is configured*/
    GT_U32      comp;
    GT_U32      j;                /* Time out pooling index*/
    /* Control register or Phy register - device with Single XG port*/
    static GT_BOOL setPhyRegBeforeControlReg = GT_FALSE;

    /* Get the Xg smi control register address*/
    if ((addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeControl) ||
        (addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeAddr))
    {
        isXgPort = GT_TRUE;
    }
    else
    {
        isXgPort = GT_FALSE;
    }

    /* Zero SMi control word*/
    smiRegConfig = 0;

    /* Set the busy bit, opcode for xg phy*/
    if (isXgPort == GT_TRUE)
    {
        busyBitNumber = 30;
    }
    else
    {
        busyBitNumber = 28;
    }

    /* Perform write operation - check that SMI of XSMI Master is finished
       previous transaction by polling the busy bit */
    if (((isXgPort == GT_TRUE) && (addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeAddr))||
        (isXgPort == GT_FALSE))
    {
        j = 0;
        do
        {
            if (prvCpssDrvHwPpReadRegister(devNum, addr, &smiRegConfig) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }
            comp = (smiRegConfig >> busyBitNumber) & 0x1;

            if( (j++) == HW_INIT_SMI_POOLING_TIMEOUT_CNS )
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);

#ifdef ASIC_SIMULATION
            /* one iteration is enough */
            comp = 0;
#endif /*ASIC_SIMULATION*/
        }while (comp);
    }


    /* Set the data according to the mask*/
    mask &= 0xFFFF;                     /* Zero 16 msbis*/
    smiRegConfig &= (~mask);            /* Turn the field off.   */
    smiRegConfig |= (data & mask);

    if (isXgPort == GT_TRUE)
    {
        if (addr == PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.smi10GeAddr)
        {
            if(setPhyRegBeforeControlReg == GT_TRUE)
            {
                /*OpCode 0x5 - issue 'Address' SMI Frame the issue 'Write' SMI frame*/
                U32_SET_FIELD_MAC(smiRegConfig, 26, 3, 5);
                setPhyRegBeforeControlReg = GT_FALSE;
            }
            else
            {
                /*OpCode 0x1 - issue 'WRITE' SMI frame*/
                U32_SET_FIELD_MAC(smiRegConfig, 26, 3, 1);
            }

            /* Set the address from the input*/
            U32_SET_FIELD_MAC(smiRegConfig, 16, 10, (data >> 16));
        }
        else
        {
            setPhyRegBeforeControlReg = GT_TRUE;
        }
    }
    else
    {
        U32_SET_FIELD_MAC(smiRegConfig, 26, 1, 0);      /*OpCode 0x0 - issue 'WRITE' SMI frame*/
        /* Set the address from the input*/
        U32_SET_FIELD_MAC(smiRegConfig, 16, 10, (data >> 16));
    }

    /* Perform the phy write operation*/
    if (prvCpssDrvHwPpWriteRegister(devNum, addr, smiRegConfig) != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* hwPpStartInit
*
* DESCRIPTION:
*       This phase performs the start-init operation on a given device, and sets
*       it's registers according to the registers value list passed by user.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The device number to which the start-init operation
*                         should be done.
*       initDataListPtr - (pointer to) List of registers values to be set to the device.
*       initDataListLen - Number of elements in ppRegConfigList
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK   - on success,
*       GT_FAIL - otherwise.
*
* COMMENTS:
*       This function should be invoked after cpssExMxHwPpPhase1Init() and
*       before cpssDxChHwPpPhase2Init().
*       1.  Before the device is enabled, all ports will be set to disable state
*           to make sure that no packets are forwarded before the system is
*           fully initialized.
*
*******************************************************************************/
static GT_STATUS hwPpStartInit
(
    IN  GT_U8                       devNum,
    IN  CPSS_REG_VALUE_INFO_STC     *initDataListPtr,
    IN  GT_U32                      initDataListLen
)
{
    GT_STATUS   rc = GT_OK;         /* Function's return value.                 */
    GT_BOOL     setMatch;       /* Indicates if the device's set matches    */
                                /* the next section.                        */
    GT_BOOL     deviceFound;    /* Indicates if the device's set was found  */
                                /* in the data-list.                        */
    GT_U32      i;              /* Loops index.                             */
    GT_U32      j;              /* Loops index.                             */
    GT_U32      cnt;            /* Repeat counter index.                    */
    CPSS_REG_VALUE_INFO_STC  *regValuePtr; /* pointer to the current reg value*/
    PRV_CPSS_GEN_PP_CONFIG_STC *devPtr = PRV_CPSS_PP_MAC(devNum);/* pointer to common device info */

    deviceFound = GT_FALSE;

    /* Search for the corresponding set to configure.   */
    /* Currently the set number is the device's         */
    /* revision number.                                 */
    /* SHOULD BE FIXED TO CONSIDER THE DEVICE'S SET #   */
    i = 0;
    while(i < initDataListLen)
    {
        /* For now, just find the device's revision number  */
        setMatch = GT_FALSE;
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            if(devPtr->revision == initDataListPtr[i].addrType)
            {
                setMatch = GT_TRUE;
                break;
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(setMatch == GT_FALSE)
        {
            /* Go to the next section.          */
            /* Count 3 delimiters.              */
            j = 0;
            while((j < 3) && (i < initDataListLen))
            {
                if(initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                {
                    j++;
                }
                i++;
            }

            if((i == initDataListLen) && (deviceFound == GT_FALSE))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            continue;
        }

        deviceFound = GT_TRUE;

        /* set Match == GT_TRUE         */
        /* Find the first delimiter.    */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Jump over the delimiter.     */
        i++;

        /* Write the pre start-init register values.        */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            /* This is a phy read/write */
            if (initDataListPtr[i].addrType == CPSS_REG_PHY_ADDR_TYPE_CNS)
            {
                /* Search for the next delimiter*/
                j=i+1;
                while((initDataListPtr[j].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS) &&
                      (j < initDataListLen))
                {
                    /* section delimiter found before phy delimiter*/
                    if (initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    j++;
                }

                /* If phy second delimiter was not found */
                if (j == initDataListLen)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Perform the write operation for all the phy whithin the
                    section*/
                while(initDataListPtr[i].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS)
                {
                    regValuePtr = &initDataListPtr[i];
                    /* section delimiter found before phy delimiter*/
                    rc = hwPpPhyRegisterWrite(devNum,
                                              regValuePtr->addrType,
                                              regValuePtr->regMask,
                                              regValuePtr->regVal);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                    i++;
                }
                /* Skip the delimiter*/
                i++;
                continue;
            }

            for(cnt = 0; cnt < initDataListPtr[i].repeatCount; cnt++)
            {
                rc = prvCpssDrvHwPpWriteRegBitMask(devNum,initDataListPtr[i].addrType,
                                             initDataListPtr[i].regMask,
                                             initDataListPtr[i].regVal);

                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Reached the end of a section.            */
        /* Jump over the delimiter.                 */
        i++;

        /* Find the delimiter of the section end.   */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        i++;
    }

    if((deviceFound == GT_FALSE) && (initDataListLen != 0))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_FOUND, LOG_ERROR_NO_MSG);
    }

    /* Search for the corresponding set to configure.   */
    /* Currently the set number is the device's         */
    /* revision number.                                 */
    /* SHOULD BE FIXED TO CONSIDER THE DEVICE'S SET #   */
    i = 0;
    while(i < initDataListLen)
    {
        /* For now, just find the device's revision number  */
        setMatch = GT_FALSE;
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            if(devPtr->revision == initDataListPtr[i].addrType)
            {
                setMatch = GT_TRUE;
                break;
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        if(setMatch == GT_FALSE)
        {
            /* Go to the next section.          */
            /* Count 3 delimiters.              */
            j = 0;
            while((j < 3) && (i < initDataListLen))
            {
                if(initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                {
                    j++;
                }
                i++;
            }

            if((i == initDataListLen) && (deviceFound == GT_FALSE))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            continue;
        }

        /* set Match == GT_TRUE         */
        /* Count 2 delimiters.          */
        j = 0;
        while((j < 2) && (i < initDataListLen))
        {
            if(initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
            {
                j++;
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* Write the post start-init register values.       */
        while((initDataListPtr[i].addrType != CPSS_REG_LIST_DELIMITER_CNS) &&
              (i < initDataListLen))
        {
            /* Phy delimiter operation*/
            if (initDataListPtr[i].addrType == CPSS_REG_PHY_ADDR_TYPE_CNS)
            {
                /* Search for the next delimiter*/
                j=i+1;
                while((initDataListPtr[j].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS) &&
                      (j < initDataListLen))
                {
                    /* section delimiter found before phy delimiter*/
                    if (initDataListPtr[i].addrType == CPSS_REG_LIST_DELIMITER_CNS)
                    {
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                    }
                    j++;
                }

                /* If phy second delimiter was not found */
                if (j == initDataListLen)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Perform the write operation for all the phy whithin the
                    section*/
                i++;
                while(initDataListPtr[i].addrType != CPSS_REG_PHY_ADDR_TYPE_CNS)
                {
                    regValuePtr = &initDataListPtr[i];
                    /* section delimiter found before phy delimiter*/
                    rc = hwPpPhyRegisterWrite(devNum,
                                                       regValuePtr->addrType,
                                                       regValuePtr->regMask,
                                                       regValuePtr->regVal);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                    i++;
                }
                /* Skip the delimiter*/
                i++;
                continue;
            }

            for(cnt = 0; cnt < initDataListPtr[i].repeatCount; cnt++)
            {
                rc = prvCpssDrvHwPpWriteRegBitMask(devNum,initDataListPtr[i].addrType,
                                             initDataListPtr[i].regMask,
                                             initDataListPtr[i].regVal);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            i++;
        }

        if(i == initDataListLen)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }


        /* Reached the end of a section.            */
        /* Jump over the delimiter.                 */
        i++;
    }


    return GT_OK;
}

/*******************************************************************************
* hwPpStartInitEpromReload
*
* DESCRIPTION:
*       Trigers reload registers from EPROM
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The device number reload should be done.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK       - on success
*       GT_FAIL     - on error
*       GT_HW_ERROR - on hardware error
*       GT_BAD_PARAM - wrong devNum
*
* COMMENTS:
*       NONE
*
*******************************************************************************/
static GT_STATUS hwPpStartInitEpromReload
(
    IN  GT_U8               devNum
)
{

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    return prvCpssDrvHwPpSetRegField(devNum,
                              PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->twsiReg.
                              serInitCtrl,22, 1, 1);
}

/*******************************************************************************
* hwPpUnitAddressCheck
*
* DESCRIPTION:
*       Check if single unit address range comprises restricted addresses.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - The device number
*       portGroupId - The port group Id. relevant only to 'multi-port-groups' devices,
*                        supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
*       addr        - Start offset address to check inside the unit
*       length      - The length of the memory to check inside the unit (the legth is in words).
*
* OUTPUTS:
*       none.

* RETURNS:
*       GT_OK         - on success
*       GT_BAD_PARAM  - on restricted address
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpUnitAddressCheck
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 addr,
    IN GT_U32 length
)
{
    PRV_CPSS_DXCH_ERRATA_UNIT_RANGES_STC    *unitRangesPtr; /* unit ranges and
                                                               their number */
    GT_U32                                  unitId;         /* unit Id */
    GT_U32                                  rangeId;        /* range Id, inside
                                                               the unit */
    GT_U32                                  portGroupsBmp;

    /* Ignore 2 LSB */
    addr &= 0xFFFFFFFC;/* ignore 2 LSB */
    unitId = (addr >> 23) & 0x3F;

    if (unitId >= UNITS_NUM_CNS)
    {
        return GT_OK;
    }

    if (!PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* XCAT A1 */
        portGroupId = 0;
    }

    if (portGroupId == CPSS_PORT_GROUP_UNAWARE_MODE_CNS)
    {
        portGroupsBmp = PRV_CPSS_PP_MAC(devNum)->
                                    portGroupsInfo.activePortGroupsBmp;
    }
    else
    {
        portGroupsBmp = (1 << portGroupId);
    }

    /* loop on all active port groups in the bmp */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)
    {
        unitRangesPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.unitRangesPtr[portGroupId];

        if (unitRangesPtr[unitId].numOfRanges == 0)
        {
            /* no restricted ranges in this unit, move to the next portGroup */
            continue;
        }

        /* There are some restricted ranges in this unit */

        /* check if there is restricted range inside the address range given */
        for (rangeId = 0; rangeId < unitRangesPtr[unitId].numOfRanges; rangeId++)
        {
            if (addr > unitRangesPtr[unitId].rangesPtr[rangeId].addrEnd)
            {
                /* move to the next range */
                continue;
            }

            /* check if the address range ends before start of the restricted range */
            if ((addr + (length * 4) - 4) < unitRangesPtr[unitId].rangesPtr[rangeId].addrStart)
            {
                /* the address range has no restricted ranges */
                return GT_OK;
            }

            /* the restricted range is fully or partially inside the address range */
            if (unitRangesPtr[unitId].rangesPtr[rangeId].addrMask == 0x0)
            {
                /* the whole range is restricted */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            else
            {
                /* Not the whole range is restricted, there are valid and not
                   valid adrdesses inside the range */

                if ((addr & unitRangesPtr[unitId].rangesPtr[rangeId].addrMask) ==
                     unitRangesPtr[unitId].rangesPtr[rangeId].addrPattern)
                {
                    /* this specific address is not valid */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* this specific address is valid */
                return GT_OK;
            }
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)


    return GT_OK;
}

/*******************************************************************************
* hwPpAddressCheck
*
* DESCRIPTION:
*       Check if address range comprises restricted addresses.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - The device number
*       portGroupId - The port group Id. relevant only to 'multi-port-groups' devices,
*                        supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS.
*       addr        - Start offset address to check
*       length      - The length of the memory to check (the legth is in words).
*
* OUTPUTS:
*       none.

* RETURNS:
*       GT_OK         - on success
*       GT_HW_ERROR   - on hardware error.
*       GT_BAD_PARAM  - on bad devNum or restricted address
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS hwPpAddressCheck
(
    IN GT_U8  devNum,
    IN GT_U32 portGroupId,
    IN GT_U32 addr,
    IN GT_U32 length
)
{
    GT_U32      unitId;         /* unit Id, loop iterator           */
    GT_U32      unitIdStart;    /* start unit Id of the range       */
    GT_U32      unitIdEnd;      /* end unit Id of the range         */
    GT_U32      startAddr;      /* start address of the range       */
    GT_U32      endAddr;        /* end address of the range         */
    GT_U32      unitLen;        /* The length inside specific unit  */
    GT_STATUS   rc;             /* return status                    */


    /* calculate end address of the range */
    endAddr = (addr + (length * 4) - 4) & 0xFFFFFFFC;

    /* Unit Id is defined by bits 23-28 */
    unitIdStart = ((addr >> 23) & 0x3F);
    unitIdEnd = ((endAddr >> 23) & 0x3F);

    if(endAddr >
       PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
       info_PRV_CPSS_DXCH_XCAT_RESTRICTED_ADDRESS_FILTERING_WA_E.lastValidAddress)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (unitIdStart == unitIdEnd)
    {
        /* There is only one unit to check */
        rc = hwPpUnitAddressCheck(devNum,
                                  portGroupId,
                                  addr,
                                  length);
        return rc;
    }

    /* In case there are more then one unit in a range */
    for (unitId = unitIdStart; unitId <= unitIdEnd; unitId++)
    {
        if (unitId == unitIdStart)
        {
            /* The range ends in the start of the next unit */
            startAddr = addr;
            unitLen = (((unitId + 1) << 23) - (addr & 0xFFFFFFFC)) / 4 ;
        }
        else if (unitId == unitIdEnd)
        {
            /* The address starts at the start of unit */
            startAddr = (unitId << 23);
            unitLen = ((endAddr - startAddr) / 4) + 1;
        }
        else
        {
            /* all units that are inside the range */
            startAddr = (unitId << 23);
            /* The whole unit range should be checked */
            unitLen = PRV_DXCH_MAX_UNIT_ADDR_RANGE_CNS;
        }

        rc = hwPpUnitAddressCheck(devNum,
                                  portGroupId,
                                  startAddr,
                                  unitLen);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* internal_cpssDxChHwPpStartInit
*
* DESCRIPTION:
*       This phase performs the start-init operation on a given device, and sets
*       it's registers according to the registers value list passed by user.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The device number to which the start-init operation
*                         should be done.
*       loadFromEeprom  - GT_TRUE, trigger the device to re-load the eeprom.
*       initDataListPtr - List of registers values to be set to the device.
*       initDataListLen - Number of elements in ppRegConfigList
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_TIMEOUT               - on timed out retries
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       This function should be invoked after cpssDxChHwPpPhase1Init() and
*       before cpssDxChHwPpPhase2Init().
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpStartInit
(
    IN  GT_U8                       devNum,
    IN  GT_BOOL                     loadFromEeprom,
    IN  CPSS_REG_VALUE_INFO_STC     *initDataListPtr,
    IN  GT_U32                      initDataListLen
)
{
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(initDataListPtr);

    /* set registers according to the registers value list passed by user */
    rc = hwPpStartInit(devNum,initDataListPtr,initDataListLen);
    if(rc != GT_OK)
    {
        return rc;
    }

    if (loadFromEeprom == GT_TRUE)
    {
        /* Triggers reload registers from EPROM */
        rc = hwPpStartInitEpromReload(devNum);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChHwPpStartInit
*
* DESCRIPTION:
*       This phase performs the start-init operation on a given device, and sets
*       it's registers according to the registers value list passed by user.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum          - The device number to which the start-init operation
*                         should be done.
*       loadFromEeprom  - GT_TRUE, trigger the device to re-load the eeprom.
*       initDataListPtr - List of registers values to be set to the device.
*       initDataListLen - Number of elements in ppRegConfigList
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_TIMEOUT               - on timed out retries
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       This function should be invoked after cpssDxChHwPpPhase1Init() and
*       before cpssDxChHwPpPhase2Init().
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpStartInit
(
    IN  GT_U8                       devNum,
    IN  GT_BOOL                     loadFromEeprom,
    IN  CPSS_REG_VALUE_INFO_STC     *initDataListPtr,
    IN  GT_U32                      initDataListLen
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpStartInit);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, loadFromEeprom, initDataListPtr, initDataListLen));

    rc = internal_cpssDxChHwPpStartInit(devNum, loadFromEeprom, initDataListPtr, initDataListLen);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, loadFromEeprom, initDataListPtr, initDataListLen));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock
*
* DESCRIPTION:
*       Locks/unlocks the task switching and disables/enables the link status
*       change interrupt
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion.
*
* INPUTS:
*       devNum          - device number
*       portGroupId     - The port group Id. relevant only to 'multi-port-groups' devices.
*                         supports value CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
*                         although in xcat/xcat2 not relevant let it be as preparation for
*                         future
*       portNum         - port number
*       lock            - GT_TRUE - to lock task switching and to disable interrupt
*                       - GT_FALSE - to enable interrupt and to unlock task switching
*       savedStatePtr   - for "lock" - nothing, for "unlock" - saved state
* OUTPUTS:
*       savedStatePtr   - for "lock" - place to save state, for "unlock" - nothing
*
* RETURNS :
*       GT_OK    - success
*       GT_NOT_INITIALIZED - the internal DB for the 'WA' was not initialized
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock
(
    IN    GT_U8                             devNum,
    IN    GT_U32                            portGroupId,
    IN    GT_PHYSICAL_PORT_NUM              portNum,
    IN    GT_BOOL                           lock,
    INOUT GT_U32                            *savedStatePtr
)
{
    GT_BOOL   linkChIntEn; /* link chanhe interrupt enable       */
    GT_32     intKey;      /* CPU interrupt state                */
    GT_U32    data;        /* work data                          */
    GT_STATUS rc;          /* return code                        */

    if (lock != GT_FALSE)
    {
        /* initialize for abnormal return case */
        *savedStatePtr = 0;
    }

    if (lock == GT_FALSE)
    {
        /* UNLOCK case */

        linkChIntEn = (GT_BOOL)*savedStatePtr;
        rc = GT_OK;

        /* Link Change - interrupt enable */

        if (GT_FALSE != linkChIntEn)
        {
            cpssExtDrvSetIntLockUnlock(
                CPSS_OS_INTR_MODE_LOCK_E, &intKey);

            /* clear Port Interrupt Cause register by read */
            rc = prvCpssDrvHwPpPortGroupReadRegister(devNum,
                    portGroupId,
                    GE_MAC_PORT_INTERRUPT_CAUSE_MAC(portNum),
                    &data);

            /* unmask - i.e. event enable.                */
            /* prvCpssDrvEventsMask may return not GT_OK  */
            /* if interrupt was not binded by application */
            /* or interrupts are not used.                */
            /* Need to ignore this fail.                  */
            (void)prvCpssDrvEventsMask(devNum,
                GE_MAC_PORT_INTERRUPT_INDEX_MAC(devNum, portNum),
                GT_FALSE);

            cpssExtDrvSetIntLockUnlock(
                CPSS_OS_INTR_MODE_UNLOCK_E, &intKey);
        }

        PRV_CPSS_UNLOCK_BY_MUTEX;

        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        /* LOCK case */
        PRV_CPSS_LOCK_BY_MUTEX;

        cpssExtDrvSetIntLockUnlock(
            CPSS_OS_INTR_MODE_LOCK_E, &intKey);

        prvCpssDrvEventsMaskGet(devNum,
            GE_MAC_PORT_INTERRUPT_INDEX_MAC(devNum, portNum),
            &linkChIntEn);

        if (GT_FALSE != linkChIntEn)
        {
            /* Link Change - interrupt disable            */
            /* mask - i.e. event disable.                 */
            /* prvCpssDrvEventsMask may return not GT_OK  */
            /* if interrupt was not binded by application */
            /* or interrupts are not used.                */
            /* Need to ignore this fail.                  */
            (void)prvCpssDrvEventsMask(devNum,
                GE_MAC_PORT_INTERRUPT_INDEX_MAC(devNum, portNum),
                GT_TRUE);
        }

        cpssExtDrvSetIntLockUnlock(
            CPSS_OS_INTR_MODE_UNLOCK_E, &intKey);

        *savedStatePtr = (GT_U32)linkChIntEn;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix
*
* DESCRIPTION:
*       Discover and fix bad state of flex link status change state machine
*
* APPLICABLE DEVICES:
*        xCat; xCat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; xCat2.
*
* INPUTS:
*       devNum      - device number
*       portNum     - port number
*
* OUTPUTS:
*       None
*
* RETURNS :
*       GT_OK    - success
*       GT_TIMEOUT - state machine fix failed after numerous tries
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix
(
    IN GT_U8 devNum,
    IN GT_PHYSICAL_PORT_NUM portNum
)
{
    GT_STATUS   rc;     /* return code */
    GT_U32      status; /* port link state machine status */
    GT_U32      savedState; /* link change interrupt state */
    GT_U32      timeout;    /* counter of tries to fix link up
                                state machine */
    GT_U32      regAddr;    /* register address */
    GT_U32      lms0MiscCfgRegAddr = PRV_CPSS_SW_PTR_ENTRY_UNUSED;
                                    /* register address of lms0MiscConfig */
    GT_U32      debugBusRegOffset; /* offset to read in debug bus register */

    FLEX_LINK_UP_WA_DBG_PRINT_MAC(("prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix:  \
                                    devNum=%d,portNum=%d\n",
                                    devNum, portNum));

    if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_TRUE)
    {
        /* The XG port number "port_num" drives the debug bus */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->debugBusRegs.debugCtrl2;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 0, 6, portNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* Control which internal XG debug register will drive the debug bus */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 6, 3);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        lms0MiscCfgRegAddr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->smiRegs.lms0MiscConfig;

        /*Port number to be debugged.*/
        rc = prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr, 6, 6, portNum);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* The Debug Group of the selected port */
        rc = prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr, 0, 6, 3);
        if (rc != GT_OK)
        {
           return rc;
        }

        /* Selects Ports in debug mode - must be cleared at the end. */
        rc = prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr, 12, 1, 1);
        if (rc != GT_OK)
        {
            return rc;
        }

     }
    /* debug bus info read port link state machine status */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->debugBusRegs.debugBus;
    /* for ports 12-23 need to read bits 29-31 */
    debugBusRegOffset = ((portNum > 23) || (portNum < 12)) ? 13 : 29;
    rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, debugBusRegOffset, 3, &status);
    if (rc != GT_OK)
    {
        /* Must clean bit 12 in LMS0 at the end */
        if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
        {
            (GT_VOID)prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                                12, 1, 0);
        }

        return rc;
    }

    FLEX_LINK_UP_WA_DBG_PRINT_MAC(("try=0,status=%d\n", status));

    /* if no problem exit */
    if(2 != status)
    {
        if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
        {
            /* Must clean bit 12 in LMS0 at the end */
            rc = prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                            12, 1, 0);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        return GT_OK;
    }

    rc = prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_TRUE/* lock */,
                                    &savedState);
    if (rc != GT_OK)
    {
        goto restoreAndExit;
    }

    timeout = 0;
    while(2 == status)
    {
        if(++timeout > 100)
        {
            rc = GT_TIMEOUT;
            goto restoreAndExit;
        }

        rc = cpssDxChPortForceLinkDownEnableSet(devNum,portNum,GT_TRUE);
        if (rc != GT_OK)
        {
            goto restoreAndExit;
        }

        /* wait at least 10 usec */
        cpssOsTimerWkAfter(1);

        rc = cpssDxChPortForceLinkDownEnableSet(devNum,portNum,GT_FALSE);
        if (rc != GT_OK)
        {
            goto restoreAndExit;
        }

        rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, debugBusRegOffset, 3, &status);
        if (rc != GT_OK)
        {
            goto restoreAndExit;
        }

        FLEX_LINK_UP_WA_DBG_PRINT_MAC(("try=%d,status=%d\n",
                                        timeout, status));
    }

    if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
    {
        /* Must clean bit 12 in LMS0 at the end */
        rc = prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                        12, 1, 0);
        if (rc != GT_OK)
        {
            (GT_VOID)prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                            portNum, GT_FALSE/* unlock */,
                                            &savedState);
            return rc;
        }
    }

    return prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_FALSE/* unlock */,
                                    &savedState);

restoreAndExit:

    /* Must clean bit 12 in LMS0 at the end */
    if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) == GT_FALSE)
    {
        (GT_VOID)prvCpssDrvHwPpSetRegField(devNum, lms0MiscCfgRegAddr,
                                            12, 1, 0);
    }

    (GT_VOID)prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_FALSE/* unlock */,
                                    &savedState);
    return rc;
}

/*******************************************************************************
* prvCpssDxChHwPpXcat2Sgmii25FLUpBadStateCheckAndFix
*
* DESCRIPTION:
*       Discover and fix bad state of flex link status change state machine
*
* APPLICABLE DEVICES:
*        xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion.
*
* INPUTS:
*       devNum      - device number
*       portNum     - port number
*
* OUTPUTS:
*       None
*
* RETURNS :
*       GT_OK    - success
*       GT_TIMEOUT - state machine fix failed after numerous tries
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwPpXcat2Sgmii25FLUpBadStateCheckAndFix
(
    IN GT_U8 devNum,
    IN GT_PHYSICAL_PORT_NUM portNum
)
{
    GT_STATUS   rc;     /* return code */
    GT_U32      status; /* port link state machine status */
    GT_U32      savedState; /* link change interrupt state */
    GT_U32      timeout;    /* counter of tries to fix link up
                                state machine */
    GT_U32      regAddr;    /* register address */
    GT_U32      index;  /* register address index accordinly to port */
    GT_U32      value;  /* value to write to register */

    FLEX_LINK_UP_WA_DBG_PRINT_MAC(("prvCpssDxChHwPpXcat2Sgmii25FLUpBadStateCheckAndFix:  \
                                    devNum=%d,portNum=%d\n",
                                    devNum, portNum));

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->debugBusRegs.debugCtrl2;
    /* Control which internal XG debug register will drive the debug bus */
    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 6, 3);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* 0x820000 (client 4) is for ports 26_27
     * 0x850000 (client 10) is for ports 24_25
     */
    index = (portNum < 26) ? 1 : 0;
    value = ((portNum%2) == 0) ? 0x100 : 0x101;
    /* debug bus info read port link state machine status */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.client[index].dataCtrl;
    rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, value);
    if (rc != GT_OK)
    {
        return rc;
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.client[index].dataSamplingCtrl;
    rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0x20);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* debug bus info read port link state machine status */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.client[index].debugInfo;
    rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, 13, 3, &status);
    if (rc != GT_OK)
    {
        return rc;
    }

    FLEX_LINK_UP_WA_DBG_PRINT_MAC(("try=0,status=%d\n", status));

    /* if no problem exit */
    if(2 != status)
        return GT_OK;

    rc = prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_TRUE/* lock */,
                                    &savedState);
    if (rc != GT_OK)
    {
        return rc;
    }

    timeout = 0;
    while(2 == status)
    {
        rc = cpssDxChPortForceLinkDownEnableSet(devNum,portNum,GT_TRUE);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* wait at least 10 usec */
        cpssOsTimerWkAfter(1);

        rc = cpssDxChPortForceLinkDownEnableSet(devNum,portNum,GT_FALSE);
        if (rc != GT_OK)
        {
            return rc;
        }

        FLEX_LINK_UP_WA_DBG_PRINT_MAC(("try=%d,status=%d\n",
                                        timeout+1, status));

        if(++timeout >= 100)
        {
            rc = prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                            portNum, GT_FALSE/* unlock */,
                                            &savedState);
            if (rc != GT_OK)
            {
                return rc;
            }
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* debug bus info read port link state machine status */
        rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, 13, 3, &status);
        if (rc != GT_OK)
        {
            return rc;
        }
    }

    rc = prvCpssDxChHwPpErrataFlexLinkUpWaInterruptLock(devNum,
                                    CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                    portNum, GT_FALSE/* unlock */,
                                    &savedState);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwPpSgmii_2_5G_LinkUpWa
*
* DESCRIPTION:
*       WA for Flex link TX hangs upon link establish
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion.
*
* INPUTS:
*       devNum      - device number
*       portNum     - port number
*
* OUTPUTS:
*       None
*
* RETURNS :
*       GT_OK    - success
*       GT_TIMEOUT - state machine fix failed after numerous tries
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwPpSgmii_2_5G_LinkUpWa
(
    IN GT_U8 devNum,
    IN GT_PHYSICAL_PORT_NUM portNum
)
{
    GT_STATUS rc;   /* return code */
    GT_BOOL linkState;  /* current link state of port */
    GT_U32  i;          /* iterator */
    GT_U32  fieldData; /* data to write to register */
    GT_U32  fieldOffset; /* offset in register */
    GT_U32  regAddr;    /* address of register */

    PRV_CPSS_PHY_PORT_CHECK_MAC(devNum,portNum);

    if(PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,portNum) != PRV_CPSS_PORT_GE_E)
        return GT_OK;

    /* check if dp_clk enabled on port, otherwise treatment not needed */
    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        if(PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum) != GT_TRUE)
            return GT_OK;

        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
            PRV_CPSS_DXCH_XCAT_RM_METAL_FIX_SGMII25G_DPCLK_SEL_WA_E))
        {/* check enable dp_clk */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->macRegs.perPortRegs[portNum].
                                        macRegsPerType[PRV_CPSS_PORT_GE_E].macCtrl4;
            if (prvCpssDrvHwPpGetRegField(devNum, regAddr, 2, 1, &fieldData) != GT_OK)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            }

            if(fieldData != 1)
                return GT_OK;
        }
        else
        {/* because XCAT2 A0 isn't production version, WA not implemented */
            return GT_OK;
        }
    }
    else
    {
        if(GT_FALSE == PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum))
        {   /* check dp_clk on network ports */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl;
            fieldOffset = (GT_TRUE == PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum)) ? 22 : 21;
            if((rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, fieldOffset, 1, &fieldData)) != GT_OK)
                return rc;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.metalFix;
            fieldOffset = (GT_TRUE == PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum)) ?
                            (22 + (portNum-24)) : (26 + (portNum/4));
            rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, fieldOffset, 1, &fieldData);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        if(fieldData != 1)
            return GT_OK;
    }

    rc = cpssDxChPortLinkStatusGet(devNum, portNum, &linkState);
    if (GT_OK != rc)
        return rc;

    if(linkState != GT_TRUE)
        return GT_OK;

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        rc = prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix(devNum,portNum);
        if (GT_OK != rc)
            return rc;
    }
    else
    {
        rc = prvCpssDxChHwPpXcat2Sgmii25FLUpBadStateCheckAndFix(devNum,portNum);
        if (GT_OK != rc)
            return rc;
    }

    /* in xcat revisions older then B1(A3B) mixed mode of sgmii 2.5G and 1G
        has limited support, so all flex links or network ports could
        be infuenced by link up on one of them and we
        must run WA on all other ports that are up and configured as GE
        (1000BaseX or SGMII), no matter what speed they use
    */
    if (GT_FALSE == PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum))
    {
        GT_U32  firstPort,  /* first port in loop to check affected ports */
                lastPort;   /* last port in loop to check affected ports */

        firstPort = (GT_TRUE ==
                    PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum)) ? 24 : 0;
        lastPort = (GT_TRUE == PRV_CPSS_DXCH_IS_FLEX_LINK_MAC(devNum,portNum))
                                    ? PRV_CPSS_PP_MAC(devNum)->numOfPorts : 24;

        for( i = firstPort; i < lastPort; i++)
        {
            PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, i);

            if(i == portNum)
                continue;

            if(PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,portNum) != PRV_CPSS_PORT_GE_E)
                continue;

            rc = cpssDxChPortLinkStatusGet(devNum, (GT_U8)i, &linkState);
            if (GT_OK != rc)
                return rc;

            if(linkState != GT_TRUE)
                continue;

            rc = prvCpssDxChHwPpXcatSgmii25FLUpBadStateCheckAndFix(devNum,(GT_U8)i);
            if (GT_OK != rc)
                return rc;
        }
    }

    return GT_OK;
}


/*******************************************************************************
* appDemoDxChBobcat2FcAutoNegotiationTriSpeedPortFix
*
* DESCRIPTION:
*      Perform fix of flow control auto negotiation for tri-speed ports.
*
* INPUTS:
*       devNum  - device number
*       portMacNum - MAC port number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK   - on success,
*       GT_FAIL - otherwise.
*       GT_HW_ERROR - hw error
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS prvCpssDxChBobcat2FcAutoNegotiationTriSpeedPortFix
(
    IN   GT_U8      devNum,
    IN   GT_U32     portMacNum
)
{
    GT_STATUS               rc;         /* return code */
    GT_BOOL                 isLinkUp;   /* link status */
    GT_PHYSICAL_PORT_NUM    portNum;    /* physical port nuymber */
    CPSS_PORT_MAC_TYPE_ENT  portMacType;/* MAC type */
    GT_U32                  regAddr;    /* register address */
    GT_U32                  anRegAddr;  /* auto negotiation register address */
    GT_U32                  regValue;   /* register value */
    GT_U32                  regValue1;  /* register value */
    GT_U32                  timeoutCntr;/* count timeout of auto negotiation */


    rc = prvCpssDxChPortPhysicalPortMapReverseMappingGet(devNum, PRV_CPSS_DXCH_PORT_TYPE_MAC_E, portMacNum, &portNum);
    if(GT_OK != rc)
    {
        return rc;
    }

    /************************************************************
    *   The workaround is relevant for tri-speed ports that are *
    *   enabled to run the Auto-Negotiation process.            *
    *************************************************************/
    rc = cpssDxChPortMacTypeGet(devNum,portNum,&portMacType);
    if(GT_OK != rc)
    {
        return rc;
    }

    PRV_CPSS_DXCH_PORT_AUTO_NEG_CTRL_REG_MAC(devNum, portMacNum,&anRegAddr);
    if(PRV_CPSS_SW_PTR_ENTRY_UNUSED == anRegAddr)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);

    rc = prvCpssHwPpGetRegField(devNum, anRegAddr, 11, 1, &regValue);
    if(GT_OK != rc)
    {
        return rc;
    }
    if((regValue == 0) /* Auto Negotiation is disabled */ ||
       ((portMacType != CPSS_PORT_MAC_TYPE_FE_E) && (portMacType != CPSS_PORT_MAC_TYPE_GE_E)))
    {
        return GT_OK;
    }

    /* Get Link Status */
    rc = cpssDxChPortLinkStatusGet(devNum,portNum,&isLinkUp);
    if (GT_OK != rc)
    {
        return rc;
    }

    /*
        - Clear the <SetFcEnTx> field in the Port MAC Control Register4 register.
        - Bind the following sequence to the LinkStatusChange interrupt of the Port Interrupt Cause Register:
        When the port link is UP:
          1. Read the <AnDone> field in the Port Status Register0 register to verify that auto-negotiation completed
          2. Read the <TxFcEn> field in the Port Status Register0 register
          3. If TxFcEn is 1: Clear the <Bypass FCA> field in the FCA Control register and the <AnFcEn> field in
             the Port Auto-Negotiation Configuration register
          4. If TxFcEn is 0: Set the <Bypass FCA> field in the FCA Control register to 1.
        When the Port link is DOWN:
          Set the <AnFcEn> field in the Port Auto-Negotiation Configuration register to 1.
    */

    if (isLinkUp == GT_FALSE)
    {
        rc = prvCpssHwPpSetRegField(devNum, anRegAddr, 11, 1, 1);
        if(GT_OK != rc)
        {
            return rc;
        }
    }
    else
    {
        timeoutCntr = 0;
        PRV_CPSS_DXCH_PORT_STATUS_CTRL_REG_MAC(devNum,portMacNum,&regAddr);
        if(PRV_CPSS_SW_PTR_ENTRY_UNUSED == regAddr)
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);

        do
        {
            /* should check with delays of 30msec => 300msec overall
                length of auto-neg. process according to protocol
                here 600 msec to be sure */
            HW_WAIT_MILLISECONDS_MAC(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS, 60);
            /* read AnDone bit */
            if (prvCpssHwPpReadRegister(devNum, regAddr, &regValue) != GT_OK)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_HW_ERROR, LOG_ERROR_NO_MSG);
            timeoutCntr++;
        } while((U32_GET_FIELD_MAC(regValue, 11, 1) != 1) && (timeoutCntr < 10));

        if(10 == timeoutCntr)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

        /* AN done */
        if(U32_GET_FIELD_MAC(regValue, 11, 1) == 1)
        {
            if(U32_GET_FIELD_MAC(regValue, 5, 1) == 1)
            {
                regValue1 = 0;

                rc = prvCpssHwPpSetRegField(devNum, anRegAddr, 11, 1, regValue1);
                if(GT_OK != rc)
                {
                    return rc;
                }
            }
            else
            {
                regValue1 = 1;
            }

            regAddr = PRV_DXCH_REG1_UNIT_GOP_FCA_MAC(devNum, portMacNum).FCACtrl;
            rc = prvCpssHwPpSetRegField(devNum, regAddr, 1, 1, regValue1);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_TIMEOUT, LOG_ERROR_NO_MSG);
        }

    }

    return GT_OK;
}


/*******************************************************************************
* lion2ErrataIpmBridgeCopyGetDroppedWaInit
*
* DESCRIPTION:
*       WA for IPM Bridge Copy Dropped
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; xCat; xCat3; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum      - device number
*
* OUTPUTS:
*       None
*
* RETURNS :
*       GT_OK    - success
*       GT_FAIL  - otherwise
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS lion2ErrataIpmBridgeCopyGetDroppedWaInit
(
    IN GT_U8 devNum
)
{
    GT_STATUS rc;   /* return code */

    CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS tailDropProfileParams;
    GT_U8     trafficClass;

    GT_BOOL   tailDropIsEnabled;

    /* Tail Drop must be enabled */

    /*  if tail drop was already configured to be enable then nothing to do.
        If tail drop was configured to be disabled then need to :
        1. enable tailDrop.
        2. per TC and DP - Keep Limit values in a shadow
        3. per TC and DP - Set Limits to be MAX_LIMITS use
    */

    rc = cpssDxChPortTxTailDropUcEnableGet(devNum,&tailDropIsEnabled);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(tailDropIsEnabled==GT_FALSE)
    {
        /* when calling cpssDxChPortTxTailDropUcEnableSet form WA init
           we do not need to set limits inside cpssDxChPortTxTailDropUcEnableSet */
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                        tailDropUcEnable = GT_TRUE;

        /* enable tailDrop */
        rc = cpssDxChPortTxTailDropUcEnableSet(devNum,GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }

        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                        tailDropUcEnable = tailDropIsEnabled;

        /* per TC and DP - Keep Limit values in a shadow and Set Limits to be MAX_LIMITS  */
        rc = prvCpssDxChPortIpmBridgeCopyGetDroppedWaTailDropMaxLimitsSet(devNum);
        if(rc != GT_OK)
        {
            return rc;
        }
        /* When the application call explicitly cpssDxChPortTxTailDropUcEnableSet(devNum, GT_TRUE),
           then  need to return all the limits kept in the shadow.*/
    }
    else
    {
        PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.
                        tailDropUcEnable = tailDropIsEnabled;
    }

    /* Configure Port 14 to TailDropProfile 8 */
    rc = prvCpssDxChPortTxBindPortToDpSet(devNum,14,CPSS_PORT_TX_DROP_PROFILE_8_E);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Configure Port 64+14 to TailDropProfile 8 */
    if (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum) >= 2)
    {
        rc = prvCpssDxChPortTxBindPortToDpSet(devNum,78,CPSS_PORT_TX_DROP_PROFILE_8_E);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    /* Set Queue limits of profile8 (last 8 lines of each table) to all_zeros */
    cpssOsMemSet(&tailDropProfileParams,0,sizeof(CPSS_PORT_TX_Q_TAIL_DROP_PROF_TC_PARAMS));
    for(trafficClass=0; trafficClass<CPSS_TC_RANGE_CNS;trafficClass++)
    {
        rc = cpssDxChPortTx4TcTailDropProfileSet(devNum,
                                             CPSS_PORT_TX_DROP_PROFILE_8_E,
                                             trafficClass,
                                             &tailDropProfileParams);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled = GT_TRUE;


    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwPpInitWaCutThroughSlowToFast
*
* DESCRIPTION:
*       This function implements the Cut Through Slow to Fast Port WA.
*
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum      - The device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum or numOfWa = 0 or bad WA value
*       GT_HW_ERROR              - on hardware error
*       GT_TIMEOUT               - on timed out retries
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Only Lion2 version B1 and above.
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwPpInitWaCutThroughSlowToFast
(
    IN GT_U8                        devNum
)
{
    GT_STATUS           rc;              /* return code */
    GT_U32              portNum;         /* Port number */
    GT_U32              maxPortNum;      /* Maximal Port number */
    GT_U32              localPort;       /* Local Port  */
    GT_BOOL             readyToWrite;    /* ready To Write */
    GT_U32              portGroupId;     /* Port Group Id */
    CPSS_PORT_SPEED_ENT portSpeed;       /* port speed */
    GT_U32              savePortGroupId; /* Save Port Group Id */
    GT_U32              writePortGroupId;/* Write Port Group Id */
    GT_U32              hwRxData;        /* HW RX data */
    GT_U32              hwTxData;        /* HW TX data */
    GT_U32              hwRxMask;        /* HW RX mask */
    GT_U32              hwTxMask;        /* HW TX mask */
    GT_U32              hwSpeed;         /* HW port speed value */
    GT_U32              rxRegAddr;       /* RX register address */
    GT_U32              txRegAddr;       /* TX register address */
    GT_U32              rxRegOff;        /* bit offset in RX register */
    GT_U32              txRegOff;        /* bit offset in TX register */
    GT_U32              saveHwRxData;    /* save HW RX data */
    GT_U32              saveHwTxData;    /* save HW TX data */
    GT_U32              saveHwRxMask;    /* save HW RX mask */
    GT_U32              saveHwTxMask;    /* save HW TX mask */

    if (GT_FALSE == PRV_CPSS_DXCH_ERRATA_GET_MAC(
        devNum, PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
        info_PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E.
            enabled = GT_TRUE;

    /* to prevent compiler warning */
    txRegAddr     = 0;
    rxRegAddr     = 0;
    hwRxData      = 0;
    hwTxData      = 0;
    hwRxMask      = 0;
    hwTxMask      = 0;
    portGroupId   = 0;
    saveHwRxData  = 0;
    saveHwTxData  = 0;
    saveHwRxMask  = 0;
    saveHwTxMask  = 0;

    /* stamp for first loop */
    savePortGroupId  = 0xFFFFFFFF;
    writePortGroupId = 0xFFFFFFFF;
    maxPortNum       = PRV_CPSS_PP_MAC(devNum)->numOfPorts;
    readyToWrite     = GT_FALSE;

    /* this loop has additional cycle to write accumulated results */
    /* of the last port group                                      */
    for (portNum = 0; (portNum <= maxPortNum); portNum++)
    {
        if (portNum == maxPortNum)
        {
            readyToWrite     = GT_TRUE;
            writePortGroupId = portGroupId;
            saveHwRxData     = hwRxData;
            saveHwTxData     = hwTxData;
            saveHwRxMask     = hwRxMask;
            saveHwTxMask     = hwTxMask;
        }

        if (readyToWrite != GT_FALSE)
        {
            /* write results accumulated by previous loops for previous port group */
            rc = prvCpssDrvHwPpPortGroupWriteRegBitMask(
                devNum, writePortGroupId, rxRegAddr, saveHwRxMask, saveHwRxData);
            if(rc != GT_OK)
            {
                return rc;
            }

            rc = prvCpssDrvHwPpPortGroupWriteRegBitMask(
                devNum, writePortGroupId, txRegAddr, saveHwTxMask, saveHwTxData);
            if(rc != GT_OK)
            {
                return rc;
            }
        }

        readyToWrite = GT_FALSE;

        if (portNum == maxPortNum)
        {
            break;
        }

        PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, portNum);

    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        rc = cpssDxChPortSpeedGet(devNum, portNum, &portSpeed);
        if(rc != GT_OK)
        {
            return rc;
        }

        if (portSpeed == CPSS_PORT_SPEED_NA_E)
        {
            /* if port speed yet not configured */
            /* use some valid value             */
            portSpeed = CPSS_PORT_SPEED_1000_E;
        }

        rc = prvCpssDxChPortSpeedForCutThroughWaCalc(
            devNum, localPort, portSpeed,
            &hwSpeed, &rxRegAddr, &txRegAddr, &rxRegOff, &txRegOff);
        if(rc != GT_OK)
        {
            return rc;
        }


        if ((savePortGroupId != portGroupId) && (savePortGroupId != 0xFFFFFFFF))
        {
            readyToWrite     = GT_TRUE;
            writePortGroupId = savePortGroupId;
            saveHwRxData     = hwRxData;
            saveHwTxData     = hwTxData;
            saveHwRxMask     = hwRxMask;
            saveHwTxMask     = hwTxMask;
        }

        if (savePortGroupId != portGroupId)
        {
            /* RX DMA */
            hwRxData = 2; /* enable bit */
            /* TX DMA */
            hwTxData = (1 << 24); /* enable bit */

            hwRxMask = hwRxData;
            hwTxMask = hwTxData;
        }

        savePortGroupId = portGroupId;

        hwRxData |= (hwSpeed << rxRegOff);
        hwTxData |= (hwSpeed << txRegOff);
        hwRxMask |= (3 << rxRegOff);
        hwTxMask |= (3 << txRegOff);
    }

    return GT_OK;
}

/*******************************************************************************
* internal_cpssDxChHwPpImplementWaInit
*
* DESCRIPTION:
*       This function allow application to state which WA (workarounds) the CPSS
*       should implement.
*       NOTEs:
*       1. The function may be called several times with different needed WA.
*       2. The CPSS will implement the WA for the requested WA , even when the HW
*          not require the 'WA' anymore.
*          for example:
*                assume the xcat A1 has erratum regarding "wrong trunk id
*                source port information of packet to CPU" , and in the WA the CPSS
*                will limit application to specific trunk-IDs.
*                but if no longer have this problem , but the application
*                still request for the WA , the CPSS will continue to handle the
*                WA.
*                further more - application may ask the WA for ch3...
*       3. The function can be invoked only after cpssDxChHwPpPhase1Init().
*
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - The device number.
*       numOfWa             - number of WA needed (number of elements in
*                             waArr[] and additionalInfoBmpArr[] arrays).
*       waArr[]     - (array of) WA needed to implement
*       additionalInfoBmpArr[] - (array of) bitmap for additional WA info.
*                              The meaning of the additional info is located
*                              in the description of the specific WA. May be NULL.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum or numOfWa = 0 or bad WA value
*       GT_BAD_STATE             - the WA can't be called at this stage ,
*                                  because it's relate library already initialized.
*                                  meaning it is 'too late' to request for the WA.
*       GT_NOT_IMPLEMENTED       - the WA can't be implemented for the current device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_HW_ERROR              - on hardware error
*       GT_TIMEOUT               - on timed out retries
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpImplementWaInit
(
    IN GT_U8                        devNum,
    IN GT_U32                       numOfWa,
    IN CPSS_DXCH_IMPLEMENT_WA_ENT   waArr[],
    IN GT_U32                       additionalInfoBmpArr[]
)
{
    GT_STATUS rc;       /* return code */
    GT_U32    waIndex;/* WA index */
    GT_U32    waInfoBmp;/*bmp info. indicate if additionalInfoBmpArr is NULL*/
    GT_U32    regAddr; /* register's address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(waArr);

    if(numOfWa == 0)
    {
        /* no need to call the API , if nothing to do ...*/
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    /* loop on the WA needed from CPSS and set internal flags according to them */
    for(waIndex = 0 ; waIndex < numOfWa; waIndex++)
    {
        waInfoBmp = (additionalInfoBmpArr) ? additionalInfoBmpArr[waIndex] : 0;
        switch(waArr[waIndex])
        {
            case CPSS_DXCH_IMPLEMENT_WA_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E:
                if(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E.
                        enabled == GT_TRUE)
                {
                    /* the WA already stated , no need to check that trunk init
                       was not done */
                    break;
                }

                if(PRV_CPSS_PP_MAC(devNum)->trunkInfo.initDone == GT_TRUE)
                {
                    /* indication that cpssDxChTrunkInit(...) was already called */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E.
                        enabled = GT_TRUE;

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E.
                        additionalInfoBmp = waInfoBmp;

                /* initialize the WA */
                rc = prvCpssDxChTrunkTrafficToCpuWaUpInit(devNum,
                                                          waInfoBmp);
                if(rc != GT_OK)
                {
                    return rc;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_E:

                if(PRV_CPSS_DXCH_PP_MAC(devNum)->netIf.initDone == GT_TRUE)
                {
                    /* indication that cpssDxChNetIfInit(...) was already called */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_E.
                        enabled = GT_TRUE;
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_E.
                        devNum = (GT_U8)waInfoBmp;
                break;

            case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FIFO_E:

                 if(PRV_CPSS_PP_MAC(devNum)->
                    intCtrl.auDescCtrl[PRV_CPSS_FIRST_ACTIVE_PORT_GROUP_ID_MAC(devNum)].blockAddr != 0)
                {
                    /* indication cpssDxChCfgPpLogicalInit(...)
                       that inits AU queues was already called */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_FDB_AU_FIFO_CORRUPT_WA_E.
                        enabled = GT_TRUE;

                break;

            case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_PADDING_E:

                /* Enable packet from CPU padding WA */
                PRV_CPSS_DXCH_ERRATA_SET_MAC(devNum,
                                             PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E);

                break;

            case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FU_FROM_NON_SOURCE_PORT_GROUP_E:
                /* check that the device is 'multi-port groups' device -->
                   otherwise return GT_NOT_APPLICABLE_DEVICE */
                PRV_CPSS_MULTI_PORT_GROUPS_DEVICE_CHECK_MAC(devNum);

                if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
                {
                    /* the device hold single FDB instance , so no meaning for port group filter */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_LION_FDB_AU_FU_MESSAGES_FROM_NON_SOURCE_PORT_GROUP_WA_E.
                        enabled = GT_TRUE;

                break;

            case CPSS_DXCH_IMPLEMENT_WA_RESTRICTED_ADDRESS_FILTERING_E:

                /* Check if the device is XCAT */
                if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum) &&
                    (! PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum)))
                {
                    /* Initialize WA DB */
                    xcatA1ErrataAddrCheckWaDbInit(devNum);

                    /* Bind callback to driver errata db */
                    rc = prvCpssDrvAddrCheckWaBind(devNum, &hwPpAddressCheck);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }

                if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
                {
                    /* Initialize WA DB */
                    lionErrataAddrCheckWaDbInit(devNum);

                    /* Bind callback to driver errata db */
                    rc = prvCpssDrvAddrCheckWaBind(devNum, &hwPpAddressCheck);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }

                if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
                {
                    /* Initialize WA DB for xCat2*/
                    xCat2ErrataAddrCheckWaDbInit(devNum);

                    /* Bind callback to driver errata db */
                    rc = prvCpssDrvAddrCheckWaBind(devNum, &hwPpAddressCheck);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_RGMII_EDGE_ALIGN_MODE_E:
                /* Check if the device is XCAT */
                if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum) &&
                    (! PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum)))
                {
                    /* Set the FTDLL register to 0x0 */
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.ftdllReg;
                    rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, 0);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_IP_MC_UNDER_STRESS_E:
                /* Check if the device is dxCh3 B2 */
                if( (CPSS_PP_FAMILY_CHEETAH3_E == PRV_CPSS_PP_MAC(devNum)->devFamily) &&
                    (1 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.mg.metalFix) )
                {
                    /* IP Multicast traffic under stress conditions may lead to device hang. */
                    /* (FEr#2263) */
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;
                    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 6, 1, 1);
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_GE_PORT_UNIDIRECT_E:

                if ((PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT_E) &&
                    (PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT3_E) &&
                    (PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E) &&
                    (PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_LION_E))
                {
                    /* the erratum exists only in XCAT/xcat2/lion devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.enabled = GT_TRUE;

                /* ports PCS loopback state shadow */
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.pcsLoopbackBmpPtr =
                            (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.
                                pcsLoopbackBmpPtr == NULL)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
                }

                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.portEnableBmpPtr =
                            (CPSS_PORTS_BMP_STC *)cpssOsMalloc(sizeof(CPSS_PORTS_BMP_STC));
                if (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.
                                portEnableBmpPtr == NULL)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_CPU_MEM, LOG_ERROR_NO_MSG);
                }
                /* assume initial state of PCS loopback - disabled */
                CPSS_PORTS_BMP_PORT_CLEAR_ALL_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                     info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.pcsLoopbackBmpPtr);
                /* assume initial state of port - enabled */
                CPSS_PORTS_BMP_PORT_SET_ALL_MAC(PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                     info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.portEnableBmpPtr);

                break;

            case CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E:

                if ((PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT_E) &&
                    (PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT2_E))
                {
                    /* the erratum exists only in XCAT/xcat2 devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                rc = prvCpssDxChHwPpSgmii_2_5G_LinkUpWa(devNum,
                                                        (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if (GT_OK != rc)
                {
                    return rc;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_TRI_SPEED_PORT_AN_FC_E:

                if(!PRV_CPSS_SIP_5_10_CHECK_MAC(devNum))
                {
                    rc = prvCpssDxChBobcat2FcAutoNegotiationTriSpeedPortFix(devNum,(GT_U32)waInfoBmp);
                    if(GT_OK != rc)
                    {
                        return rc;
                    }
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_CFG_E:
            case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_NETWORKP_CFG_E:

                if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT_E)
                {
                    /* the WA applicable only in XCAT devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl;
                if(GT_FALSE == PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum))
                {   /* configure dp_clk on network ports if not FE */
                    switch(PRV_CPSS_PP_MAC(devNum)->devType)
                    {
                        case PRV_CPSS_DXCH_XCAT_FE_DEVICES_CASES_MAC:
                        break;
                        default:
                            if((rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 21, 1, 1)) != GT_OK)
                                return rc;
                    }
                }

                /* disable network_ports_dp_sync_fifo_bypass if not FE */
                switch(PRV_CPSS_PP_MAC(devNum)->devType)
                {
                    case PRV_CPSS_DXCH_XCAT_FE_DEVICES_CASES_MAC:
                    break;
                    default:
                        rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,13,1,0);
                        if(rc != GT_OK)
                        {
                            return rc;
                        }
                }

                if(waArr[waIndex] != CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_CFG_E)
                    break;
                /* else continue to stack ports */

            case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_STACKP_CFG_E:

                if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_DXCH_XCAT_E)
                {
                    /* the WA applicable only in XCAT devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.extendedGlobalControl;
                if(GT_FALSE == PRV_CPSS_DXCH_XCAT_B1_ONLY_CHECK_MAC(devNum))
                {
                    /* configure dp_clk on stack ports */
                    if((rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 22, 1, 1)) != GT_OK)
                        return rc;
                }

                /* disable stack_ports_dp_sync_fifo_bypass */
                rc = prvCpssDrvHwPpSetRegField(devNum,regAddr,14,1,0);
                if(rc != GT_OK)
                {
                    return rc;
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_SERDES_INTERNAL_REG_ACCESS_E:
                PRV_CPSS_DRV_ERRATA_SET_MAC(devNum,
                        PRV_CPSS_DRV_ERRATA_SERDES_INTERNAL_REGS_ACCESS_WA_E);
                break;

            case CPSS_DXCH_IMPLEMENT_WA_IPM_BRIDGE_COPY_GET_DROPPED_E:

                if(GT_FALSE == PRV_CPSS_DXCH_LION2_FAMILY_CHECK_MAC(devNum))
                {
                    /* the WA applicable only in LION2 devices*/
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }

                /* Initialize WA  */
                rc = lion2ErrataIpmBridgeCopyGetDroppedWaInit(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_NO_ALLIGNMENT_LOCK_E:
            case CPSS_DXCH_IMPLEMENT_WA_DISMATCH_IF_LINK_E:
                rc = prvCpssDxChPortLion2LinkFixWa(devNum,
                                                 (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if(rc != GT_OK)
                {
                    return rc;
                }

                break;

            case CPSS_DXCH_IMPLEMENT_WA_MC_BANDWIDTH_RESTRICTION_E:
                if (GT_FALSE != PRV_CPSS_DXCH_ERRATA_GET_MAC(
                    devNum, PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E))
                {
                    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                        info_PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E.
                            enabled = GT_TRUE;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_SLOW_TO_FAST_E:

                rc = prvCpssDxChHwPpInitWaCutThroughSlowToFast(devNum);
                if ((rc != GT_OK) && (rc != GT_NOT_APPLICABLE_DEVICE))
                {
                    return rc;
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_RXAUI_LINK_E:
                rc = prvCpssDxChPortLion2RxauiLinkFixWa(devNum,
                                               (GT_PHYSICAL_PORT_NUM)waInfoBmp);
                if(rc != GT_OK)
                {
                    return rc;
                }
                break;
            case CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_REV_A0_40G_NOT_THROUGH_TM_IS_PA_30G_E:
                PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_BOBCAT2_REV_A0_40G_NOT_THROUGH_TM_IS_PA_30G_WA_E.enabled = GT_TRUE;
                break;
            case CPSS_DXCH_IMPLEMENT_WA_WRONG_MIB_COUNTERS_LINK_DOWN_E:
                if(CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)
                {
                    if((PRV_CPSS_PORT_XLG_E == PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,waInfoBmp)) ||
                        (PRV_CPSS_PORT_XG_E == PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,waInfoBmp)))
                    {
                        GT_BOOL     linkUp;
                        GT_U32      i;
                        rc = cpssDxChPortLinkStatusGet(devNum, (GT_PHYSICAL_PORT_NUM)waInfoBmp, &linkUp);
                        if (rc != GT_OK)
                        {
                            return rc;
                        }
                        if(GT_FALSE == linkUp )
                        {
                            rc = prvCpssDxChPortMacCountersOnPortGet(devNum,(GT_PHYSICAL_PORT_NUM)waInfoBmp, GT_FALSE, NULL,
                                                                 PRV_DXCH_PORT_MAC_CNTR_READ_MODE_UPDATE_SHADOW_E);
                            if(rc != GT_OK)
                            {
                                return rc;
                            }
                            rc = prvCpssDxChPortMacCountersSpecialShadowReset(devNum,(GT_PHYSICAL_PORT_NUM)waInfoBmp);
                            if(rc != GT_OK)
                            {
                                return rc;
                            }
                            for(i = 0; i < 2; i++)
                            {
                                rc = prvCpssDxChPortMacCountersOnPortGet(devNum,(GT_PHYSICAL_PORT_NUM)waInfoBmp, GT_FALSE, NULL,
                                                                     PRV_DXCH_PORT_MAC_CNTR_READ_MODE_RESET_HW_E);
                                if(rc != GT_OK)
                                {
                                    return rc;
                                }
                            }
                        }
                    }
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_ROUTER_TCAM_RM_E:
                /* RM#30230 WA is applicable only for xCat A2 and above or xCat3 */
                if (((PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E) && (PRV_CPSS_PP_MAC(devNum)->revision >= 3)) ||
                    (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E))
                {
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamControl;
                    rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 31, 1, 1);
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                    PRV_CPSS_DXCH_PP_MAC(devNum)->errata.info_PRV_CPSS_DXCH_XCAT_ROUTER_TCAM_RM_WA_E.enabled = GT_TRUE;
                }
                else
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_PTP_TIMESTAMP_E:
                rc = prvCpssDxChPortBc2PtpTimeStampFixWa(devNum);
                if(rc != GT_OK)
                {
                    return rc;
                }
                break;
            default:
                /* unknown WA */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwPpImplementWaInit
*
* DESCRIPTION:
*       This function allow application to state which WA (workarounds) the CPSS
*       should implement.
*       NOTEs:
*       1. The function may be called several times with different needed WA.
*       2. The CPSS will implement the WA for the requested WA , even when the HW
*          not require the 'WA' anymore.
*          for example:
*                assume the xcat A1 has erratum regarding "wrong trunk id
*                source port information of packet to CPU" , and in the WA the CPSS
*                will limit application to specific trunk-IDs.
*                but if no longer have this problem , but the application
*                still request for the WA , the CPSS will continue to handle the
*                WA.
*                further more - application may ask the WA for ch3...
*       3. The function can be invoked only after cpssDxChHwPpPhase1Init().
*
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - The device number.
*       numOfWa             - number of WA needed (number of elements in
*                             waArr[] and additionalInfoBmpArr[] arrays).
*       waArr[]     - (array of) WA needed to implement
*       additionalInfoBmpArr[] - (array of) bitmap for additional WA info.
*                              The meaning of the additional info is located
*                              in the description of the specific WA. May be NULL.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum or numOfWa = 0 or bad WA value
*       GT_BAD_STATE             - the WA can't be called at this stage ,
*                                  because it's relate library already initialized.
*                                  meaning it is 'too late' to request for the WA.
*       GT_NOT_IMPLEMENTED       - the WA can't be implemented for the current device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_HW_ERROR              - on hardware error
*       GT_TIMEOUT               - on timed out retries
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpImplementWaInit
(
    IN GT_U8                        devNum,
    IN GT_U32                       numOfWa,
    IN CPSS_DXCH_IMPLEMENT_WA_ENT   waArr[],
    IN GT_U32                       additionalInfoBmpArr[]
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpImplementWaInit);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, numOfWa, waArr, additionalInfoBmpArr));

    rc = internal_cpssDxChHwPpImplementWaInit(devNum, numOfWa, waArr, additionalInfoBmpArr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, numOfWa, waArr, additionalInfoBmpArr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChPpHwImplementWaGet
*
* DESCRIPTION:
*       Gets information on whether a specific workaround was implemented
*
* APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       None.
*
* INPUTS:
*       devNum      - The device number.
*       wa          - the workaround
*
* OUTPUTS:
*       isImplemented - GT_TRUE: the workaround is implemented on the device
*                      GT_FALSE: the workaround is not implemented on the device
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum or bad WA value
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_IMPLEMENTED       - no information on whether the erratum was
*                                  implemented or not
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChPpHwImplementWaGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_DXCH_IMPLEMENT_WA_ENT  wa,
    OUT GT_BOOL                     *isImplemented
)
{
    GT_U32 regAddr, value;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    switch (wa)
    {
    case CPSS_DXCH_IMPLEMENT_WA_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_TRUNK_WRONG_SOURCE_PORT_TO_CPU_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_SDMA_PACKETS_FROM_CPU_CORRUPT_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FIFO_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_FDB_AU_FIFO_CORRUPT_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_FDB_AU_FU_FROM_NON_SOURCE_PORT_GROUP_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION_FDB_AU_FU_MESSAGES_FROM_NON_SOURCE_PORT_GROUP_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_SDMA_PKTS_FROM_CPU_STACK_PADDING_E:
        *isImplemented =
            PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                         PRV_CPSS_DXCH_XCAT_TX_CPU_CORRUPT_BUFFER_WA_E);
        break;

    case CPSS_DXCH_IMPLEMENT_WA_RESTRICTED_ADDRESS_FILTERING_E:
        *isImplemented =
            ((prvCpssDrvPpConfig[devNum]->errata.addrCheckFuncPtr == NULL) ? 0 : 1);
        break;

    case CPSS_DXCH_IMPLEMENT_WA_RGMII_EDGE_ALIGN_MODE_E:
        if(PRV_CPSS_DXCH_XCAT_FAMILY_CHECK_MAC(devNum) &&
            (! PRV_CPSS_DXCH_LION_FAMILY_CHECK_MAC(devNum)))
        {
            /* Get value from FTDLL register */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.ftdllReg;
            rc = prvCpssDrvHwPpReadRegister(devNum, regAddr, &value);
            if (rc != GT_OK)
            {
                return rc;
            }
            *isImplemented = ((value == 0) ? 1 : 0);
        }
        else
        {
            *isImplemented = 0;
        }
        break;

    case CPSS_DXCH_IMPLEMENT_WA_IP_MC_UNDER_STRESS_E:
        if( (CPSS_PP_FAMILY_CHEETAH3_E == PRV_CPSS_PP_MAC(devNum)->devFamily) &&
            (1 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.mg.metalFix) )
        {
            /* IP Multicast traffic under stress conditions may lead to device hang. */
            /* (FEr#2263) */
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->egrTxQConf.txQueueMiscCtrl;
            rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, 6, 1, &value);
            if(rc != GT_OK)
            {
                return rc;
            }
            *isImplemented = ((value == 1) ? 1 : 0);
        }
        else
        {
            *isImplemented = 0;
        }
        break;

    case CPSS_DXCH_IMPLEMENT_WA_GE_PORT_UNIDIRECT_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_GE_PORT_UNIDIRECT_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_2_5G_SGMII_LINK_UP_E:
    case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_CFG_E:
    case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_NETWORKP_CFG_E:
    case CPSS_DXCH_IMPLEMENT_WA_SGMII_2_5G_UNDER_TRAFFIC_STACKP_CFG_E:
    case CPSS_DXCH_IMPLEMENT_WA_WRONG_MIB_COUNTERS_LINK_DOWN_E:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);

    case CPSS_DXCH_IMPLEMENT_WA_SERDES_INTERNAL_REG_ACCESS_E:
        *isImplemented =
            PRV_CPSS_DRV_ERRATA_GET_MAC(devNum,
                                        PRV_CPSS_DRV_ERRATA_SERDES_INTERNAL_REGS_ACCESS_WA_E);
        break;

    case CPSS_DXCH_IMPLEMENT_WA_IPM_BRIDGE_COPY_GET_DROPPED_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_IPM_BRIDGE_COPY_GET_DROPPED_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_MC_BANDWIDTH_RESTRICTION_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_MC_BANDWIDTH_RESTRICTION_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_CUT_THROUGH_SLOW_TO_FAST_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_LION2_CUT_THROUGH_SLOW_TO_FAST_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_ROUTER_TCAM_RM_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_PRV_CPSS_DXCH_XCAT_ROUTER_TCAM_RM_WA_E.enabled;
        break;

    case CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_PTP_TIMESTAMP_E:
        *isImplemented =
            PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
            info_CPSS_DXCH_IMPLEMENT_WA_BOBCAT2_PTP_TIMESTAMP_E.enabled;
        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    return GT_OK;
}

/*******************************************************************************
* cpssDxChPpHwImplementWaGet
*
* DESCRIPTION:
*       Gets information on whether a specific workaround was implemented
*
* APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       None.
*
* INPUTS:
*       devNum      - The device number.
*       wa          - the workaround
*
* OUTPUTS:
*       isImplemented - GT_TRUE: the workaround is implemented on the device
*                      GT_FALSE: the workaround is not implemented on the device
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum or bad WA value
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_IMPLEMENTED       - no information on whether the erratum was
*                                  implemented or not
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChPpHwImplementWaGet
(
    IN  GT_U8                       devNum,
    IN  CPSS_DXCH_IMPLEMENT_WA_ENT  wa,
    OUT GT_BOOL                     *isImplemented
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChPpHwImplementWaGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, wa, isImplemented));

    rc = internal_cpssDxChPpHwImplementWaGet(devNum, wa, isImplemented);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, wa, isImplemented));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwAuDescSizeGet
*
* DESCRIPTION:
*       This function returns the size in bytes of a single Address Update
*       descriptor, for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       descSizePtr- The descrptor's size (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwAuDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(descSizePtr);

    switch(devType)
    {
        case CPSS_LION3_ALL_DEVICES_CASES_MAC:
        case CPSS_BOBCAT2_ALL_DEVICES_CASES_MAC:
            *descSizePtr = 32;
            break;
        default:
            *descSizePtr = AU_DESC_SIZE;/*16*/
            break;
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwAuDescSizeGet
*
* DESCRIPTION:
*       This function returns the size in bytes of a single Address Update
*       descriptor, for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       descSizePtr- The descrptor's size (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChHwAuDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwAuDescSizeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, descSizePtr));

    rc = internal_cpssDxChHwAuDescSizeGet(devType, descSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, descSizePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChHwRxDescSizeGet
*
* DESCRIPTION:
*       This function returns the size in bytes of a single Rx descriptor,
*       for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       descSizePtr- The descrptor's size (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwRxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(descSizePtr);

    *descSizePtr = RX_DESC_SIZE;
    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwRxDescSizeGet
*
* DESCRIPTION:
*       This function returns the size in bytes of a single Rx descriptor,
*       for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       descSizePtr- The descrptor's size (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChHwRxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwRxDescSizeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, descSizePtr));

    rc = internal_cpssDxChHwRxDescSizeGet(devType, descSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, descSizePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChHwTxDescSizeGet
*
* DESCRIPTION:
*       This function returns the size in bytes of a single Tx descriptor,
*       for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       descSizePtr- The descrptor's size (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwTxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_U32    txShortBufSize;

    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(descSizePtr);

    switch(devType)
    {
        case CPSS_LION3_ALL_DEVICES_CASES_MAC:
            txShortBufSize = TX_SHORT_BUFF_SIZE_16_CNS;
            break;
        default:
            txShortBufSize = TX_SHORT_BUFF_SIZE;
            break;
    }

    *descSizePtr = TX_DESC_SIZE + txShortBufSize + (TX_HEADER_SIZE / 2);
    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwTxDescSizeGet
*
* DESCRIPTION:
*       This function returns the size in bytes of a single Tx descriptor,
*       for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       descSizePtr- The descrptor's size (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChHwTxDescSizeGet
(
    IN  CPSS_PP_DEVICE_TYPE     devType,
    OUT GT_U32                  *descSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwTxDescSizeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, descSizePtr));

    rc = internal_cpssDxChHwTxDescSizeGet(devType, descSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, descSizePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}



/*******************************************************************************
* internal_cpssDxChHwRxBufAlignmentGet
*
* DESCRIPTION:
*       This function returns the required alignment in bytes of a RX buffer,
*       for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       byteAlignmentPtr - The buffer alignment (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwRxBufAlignmentGet
(
    IN  CPSS_PP_DEVICE_TYPE devType,
    OUT GT_U32              *byteAlignmentPtr
)
{
    /* the devType is not used yet */
    (void)devType;

    CPSS_NULL_PTR_CHECK_MAC(byteAlignmentPtr);

    *byteAlignmentPtr = 128;
    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwRxBufAlignmentGet
*
* DESCRIPTION:
*       This function returns the required alignment in bytes of a RX buffer,
*       for a given device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devType - The PP's device type to return the descriptor's size for.
*
* OUTPUTS:
*       byteAlignmentPtr - The buffer alignment (in bytes).
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChHwRxBufAlignmentGet
(
    IN  CPSS_PP_DEVICE_TYPE devType,
    OUT GT_U32              *byteAlignmentPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwRxBufAlignmentGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devType, byteAlignmentPtr));

    rc = internal_cpssDxChHwRxBufAlignmentGet(devType, byteAlignmentPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devType, byteAlignmentPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* preSoftResetRamAndDfxTreat
*
* DESCRIPTION:
*       This routine make special treatment for RAM reset and DFX registers.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2; xCat3.
*
* INPUTS:
*       devNum - device number to reset.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS preSoftResetRamAndDfxTreat
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     regsSkipInit,
    IN  GT_BOOL     tablesSkipInit
)
{
    GT_STATUS   rc;               /* return code         */
    GT_U32      addConfigRegAddr; /* address of register */

    if (regsSkipInit == GT_FALSE)
    {
        if ((PRV_CPSS_DXCH_PP_MAC(devNum)->extMemory.externalMemoryInitFlags
             & PRV_CPSS_DXCH_TM_GLUE_DRAM_INIT_DONE_MASK_CNS) == 0)
        {
            /* skip reset of DFX registers to avoid stuck of internal CPU.
               DFX registers should be reset if TM was initialized. */
            if (PRV_CPSS_SIP_5_15_CHECK_MAC(devNum))
            {
                addConfigRegAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                              DFXServerUnitsBC2SpecificRegs.DFXSkipInitializationMatrix;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                                    devNum, addConfigRegAddr, 8, 1, 0);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
            else
            {
                addConfigRegAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                                              DFXServerUnitsBC2SpecificRegs.deviceCtrl18;
                rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                    devNum, addConfigRegAddr, 26, 1, 1);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }

        }
    }

    /* WA for internal CPU and RAM init */
    if (tablesSkipInit == GT_FALSE)
    {
        /* skip RAM init during soft reset to avoid CPU and MSYS RAMs corruption */
        addConfigRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.RAMInitSkipInitializationMatrix;

        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
            devNum, addConfigRegAddr, 8, 1, 0);
        if(GT_OK != rc)
        {
            return rc;
        }

        if ((PRV_CPSS_DXCH_PP_MAC(devNum)->extMemory.externalMemoryInitFlags
             & PRV_CPSS_DXCH_TM_GLUE_DRAM_INIT_DONE_MASK_CNS) == 0)
        {
            /* skip DDR init to avoid DRAM access failure for internal CPU.
               DDR should be reset if TM was initialized.*/
            addConfigRegAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsBC2SpecificRegs.DDRSkipInitializationMatrix;
            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                devNum, addConfigRegAddr, 8, 1, 0);
            if (rc != GT_OK)
            {
                return rc;
            }
        }

        /* reset all PP related RAMs */
        rc = prvCpssDxChDiagBistAllRamSet(devNum, 0, GT_TRUE);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* softResetTriggerXcat3
*
* DESCRIPTION:
*       This routine issue soft reset for a specific pp - xCat3.
*
* APPLICABLE DEVICES:
*       xCat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum - device number to reset.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*******************************************************************************/
static GT_STATUS softResetTriggerXcat3
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;             /* return code */
    GT_U32    dfxDeviceResetControlRegAddr;   /* register address                */
    GT_U32    regAddr;                        /* register address                */
    GT_BOOL   tablesSkipInit;
    GT_U32    i;                              /* loop iterator                   */

    /* xCat3; Bobcat2; Caelum; Bobcat3 */
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
    {
        return GT_OK;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E, &tablesSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    CPSS_TBD_BOOKMARK_XCAT3
    /* WA: Skip Reset Table disable causes to CPU stuck, therefore table skip init should be enabled,
       and some common tables will be deleted manually */
    if(tablesSkipInit == GT_FALSE)
    {
        rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E, GT_TRUE);
        if(GT_OK != rc)
        {
            return rc;
        }

        /* VLAN Table */
        regAddr = 0x03a00000;
        for(i = 0; i < (4096 * 8); i++)
        {
            rc = prvCpssHwPpWriteRegister(devNum, (regAddr + i * 4), 0x0);
            if(GT_OK != rc)
            {
                return rc;
            }
        }

        /* FDB Table */
        regAddr = 0x0b400000;
        for(i = 0; i < (16384 * 4); i++)
        {
            rc = prvCpssHwPpWriteRegister(devNum, (regAddr + i * 4), 0x0);
            if(GT_OK != rc)
            {
                return rc;
            }
        }

        /* VLAN PORT Private VLAN Edge Table*/
        regAddr = 0x01000000;
        for(i = 0; i < 28; i++)
        {
            rc = prvCpssHwPpWriteRegister(devNum, regAddr + i * 0x1000, 0x0);
            if(GT_OK != rc)
            {
                return rc;
            }
        }
        /* CPU entry (offset 63) */
        rc = prvCpssHwPpWriteRegister(devNum, regAddr + 0x3f * 0x1000, 0x0);
        if(GT_OK != rc)
        {
            return rc;
        }

    }

    /***************************************************************************************************************/
    /* the following register should be configured before triggering SW reset in order to CPU will be not in reset */
    /***************************************************************************************************************/

    /* enable SKIP init for CPU */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.CPUSkipInitializationMatrix;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 1, 0);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* enable SKIP init for DFX */
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.DFXSkipInitializationMatrix;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 8, 1, 0);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* {cpu_core0_reset_sel} - set bit 21*/
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.deviceCtrl7;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 21, 1, 1);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* {cpu_core1_reset_sel} - set bit 31*/
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.deviceCtrl9;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 31, 1, 1);
    if(GT_OK != rc)
    {
        return rc;
    }

    /* {cpu_core0_ext_reset_en + cpu_core1_ext_reset_en} - set bit 0 and 1*/
    regAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.deviceCtrl0;
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(devNum, regAddr, 0, 2, 3);
    if(GT_OK != rc)
    {
        return rc;
    }

    dfxDeviceResetControlRegAddr =
        PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.deviceResetCtrl;

    /* state to the special DB that the device did HW reset */
    prvCpssPpConfigDevDbHwResetSet(devNum,GT_TRUE);


    cpssOsTimerWkAfter(1);

    /* set bits of : <MG Soft Reset Trigger> and <Table Start Init> */
    /* the <Table Start Init> = 0 is relevant only when <skip table> == false
        and means that 'tables' will be re-initialized */
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceResetControlRegAddr, 1, 1, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    cpssOsTimerWkAfter(1);

    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceResetControlRegAddr, 2, 1, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    return rc;
}


/*******************************************************************************
* softResetTriggerLion3
*
* DESCRIPTION:
*       This routine issue soft reset for a specific pp - Bobcat2; Caelum; Bobcat3.
*
* APPLICABLE DEVICES:
*        xCat3; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum - device number to reset.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*******************************************************************************/
static GT_STATUS softResetTriggerLion3
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;             /* return code */
    GT_U32    dfxDeviceResetControlRegAddr;   /* register address                */
    GT_U32    dfxDeviceControl15RegAddr;      /* register address                */
    GT_BOOL   regsSkipInit;
    GT_BOOL   tablesSkipInit;
    GT_BOOL   pexSkipInit;

    /* xCat3; Bobcat2; Caelum; Bobcat3 */
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
    {
        return GT_OK;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E, &regsSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E, &tablesSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    rc = cpssDxChHwPpSoftResetSkipParamGet(devNum, CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E, &pexSkipInit);
    if(GT_OK != rc)
    {
        return rc;
    }

    if (PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* perform special treatment for RAM reset and DFX registers */
        rc = preSoftResetRamAndDfxTreat(devNum,regsSkipInit,tablesSkipInit);
        if(GT_OK != rc)
        {
            return rc;
        }
    }

    dfxDeviceResetControlRegAddr =
        PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.deviceResetCtrl;

    /* state to the special DB that the device did HW reset */
    if(isResetDbEnabled)
    {
        prvCpssPpConfigDevDbHwResetSet(devNum,GT_TRUE);
    }

    /*  NOTE about <Table Start Init> : if at some point in the future the CPSS
        will not force '0' , then be aware of implications of
        JIRA:  BOBCAT2-506 chip requires "manual" activation of table_start_init_ & tm_start_init_ after soft reset
    */


    /* set bits of : <MG Soft Reset Trigger> and <Table Start Init> */
    /* the <Table Start Init> = 0 is relevant only when <skip table> == false
        and means that 'tables' will be re-initialized */
    rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceResetControlRegAddr, 1, 2, 0);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) &&
       (regsSkipInit == GT_TRUE) && (tablesSkipInit == GT_TRUE) && (pexSkipInit == GT_TRUE))
    {
        /* this is fix to JIRA: CPSS-1851 : Soft reset with table skip Init */

        /* Soft reset is active for 2000 core clock cycles (6uS). Waiting 1 tick should be enough */
        cpssOsTimerWkAfter(1);

        dfxDeviceControl15RegAddr = PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                          DFXServerUnitsBC2SpecificRegs.deviceCtrl15;

        rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                  devNum, dfxDeviceControl15RegAddr, 0, 1, 1);
    }

    return rc;
}


/*******************************************************************************
* internal_cpssDxChHwPpSoftResetTrigger
*
* DESCRIPTION:
*       This routine issue soft reset for a specific pp.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - device number to reset.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpSoftResetTrigger
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;             /* return code */
    GT_U32    resetRegAddr;   /* register address                */
    GT_U32    resetBitOffset;      /* bit offset or value in register */
    GT_U32    resetTriggerVal;     /* trigger value                   */

    GT_U32    regAddr;   /* register address                */
    GT_U32    portGroupId = 0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        return softResetTriggerLion3(devNum);
    }

    if(PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        return softResetTriggerXcat3(devNum);
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* xCat2 */
        resetRegAddr =
             PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->dfxUnits.server.resetControl;
        resetBitOffset  = 0;
        resetTriggerVal = 0;
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        resetRegAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                               dfxUnits.server.resetControl;
        resetBitOffset  = 1;
        resetTriggerVal = 0;
    }
    else
    {
        /* all devices exclude xCat3; xCat2; Lion2; Bobcat2; Caelum; Bobcat3 */
        resetRegAddr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
        resetBitOffset  = 16;
        resetTriggerVal = 1;
    }

    /* Special sequence for Lion only */
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION_E)
    {

          /* Set the <TxQStartInit> field to '0x1' */
          regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl4;/*0x00000364*/
          rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr, 3, 1, 0);
          if(rc != GT_OK)
          {
              return rc;
          }

          /* Set "Skip Init" bits in "Global Control Register" address 0x58
             Attention:  "SW ResetSkipPex Init" and "SW ResetSkipReg Init" must be
             set in order to have access to the registers after the SoftReset
             without PEX configuration cycle to be issued. (On Core 0 only)  */
          regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
          rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr, 21, 1, 1);
          if(rc != GT_OK)
          {
              return rc;
          }
          rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr, 24, 1, 1);
          if(rc != GT_OK)
          {
              return rc;
          }

          /* Issue SoftReset (On Core 0 only) */
          rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, resetRegAddr, resetBitOffset, 1, resetTriggerVal);
          if(rc != GT_OK)
          {
              return rc;
          }

          /* start init sequence for Lion */
          rc = hwPpLionStartInitSet(devNum);
          if(rc != GT_OK)
          {
              return rc;
          }

          /* Set the <TxQStartInit> field to '0x1' */
          regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl4;/*0x00000364*/
          rc = prvCpssDrvHwPpPortGroupSetRegField(devNum, portGroupId, regAddr, 3, 1, 1);
          return rc;
    }

    /* state to the special DB that the device did HW reset */
    prvCpssPpConfigDevDbHwResetSet(devNum,GT_TRUE);

    rc = prvCpssHwPpSetRegField(
                  devNum, resetRegAddr, resetBitOffset, 1, resetTriggerVal);

    return rc;
}

/*******************************************************************************
* cpssDxChHwPpSoftResetTrigger
*
* DESCRIPTION:
*       This routine issue soft reset for a specific pp.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - device number to reset.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Soft reset is the process in which selected entities (as configured by
*       using the cpssDxChHwPpSoftResetSkipParamSet API) are reset to their
*       default values.
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpSoftResetTrigger
(
    IN  GT_U8 devNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetTrigger);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum));

    rc = internal_cpssDxChHwPpSoftResetTrigger(devNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* softResetSkipParamSetCh3B2LinkLoss
*
* DESCRIPTION:
*       This routine configure skip parameters related to soft reset -
*       only for 'LINK LOSS' for ch3B2
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum      - device number
*       skipEnable  - GT_FALSE: Do Not Skip
*                     GT_TRUE:  Skip
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS softResetSkipParamSetCh3B2LinkLoss
(
    IN  GT_U8                           devNum,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS rc;        /* return code */
    GT_U32    regAddr;   /* register address */
    GT_U32    bitOffset; /* bit offset or value in register */
    GT_U32    i;         /* loop index */
    GT_U32    devType;   /* device type */

    bitOffset = ( GT_TRUE == skipEnable ? 1 : 0 );

    for( i = 0 ; i < 24 ; i++ )
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                macRegs.perPortRegs[i].serdesMetalFix;
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 8, 1,
                                       bitOffset);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    devType = PRV_CPSS_PP_MAC(devNum)->devType;
    switch(devType)
    {
        case PRV_CPSS_CHEETAH3_XG_PORTS_DEVICES_CASES_MAC:
            for( i = 0 ; i < 24 ; i++ )
            {
                PRV_CPSS_DXCH_SKIP_NOT_EXIST_PORT_MAC(devNum, i);

                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                    macRegs.perPortRegs[i].metalFix;
                rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 0, 1,
                                               bitOffset);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            break;
        default:
            for( i = 0 ; i < 24 ; i++ )
            {
                /* if GT_TRUE  == skipEnable write value is 0b10 (0x2). */
                /* if GT_FALSE == skipEnable write value is 0b01 (0x1). */
                PRV_CPSS_DXCH_PORT_MAC_CTRL1_REG_MAC(devNum,i,PRV_CPSS_DXCH_PORT_TYPE_MAC(devNum,i),&regAddr);

                rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, 2, 2,
                                               bitOffset+1);
                if(rc != GT_OK)
                {
                    return rc;
                }
            }
            break;
    }

    return GT_OK;
}
/*******************************************************************************
* softResetSkipParamSetXcat2
*
* DESCRIPTION:
*       This routine configure skip parameters related to soft reset.
*
* APPLICABLE DEVICES:
*        xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set
*                     see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*       skipEnable  - GT_FALSE: Do Not Skip
*                     GT_TRUE:  Skip
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS softResetSkipParamSetXcat2
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_U32    resetRegAddr;   /* register address */
    GT_U32    bitOffset; /* bit offset or value in register */
    GT_U32    hwValue;   /* HW value            */
    GT_U32    targetIdx; /* reset target index  */

    /* xCat2 */
    switch(skipType)
    {
        case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            targetIdx = 0;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            targetIdx = 3;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            targetIdx = 2;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            targetIdx = 7;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* the matrix is a pair of registers 5 sources multiple 12 targets */
    /* each register contains 6 5-bit-groups for each of 6 targets     */
    /* the management (host CPU) source index is 4                     */
    resetRegAddr = (targetIdx < 6)
        ? PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            dfxUnits.server.genSkipInitMatrix0
        : PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
            dfxUnits.server.genSkipInitMatrix1;
    bitOffset = (((targetIdx % 6) * 5) + 4);
    hwValue = ((~ BOOL2BIT_MAC(skipEnable)) & 1);

    return prvCpssDrvHwPpSetRegField(
        devNum, resetRegAddr, bitOffset, 1, hwValue);
}

/*******************************************************************************
* softResetSkipParamSetLion3
*
* DESCRIPTION:
*       This routine configure skip parameters related to soft reset.
*
* APPLICABLE DEVICES:
*        xCat3; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set
*                     see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*       skipEnable  - GT_FALSE: Do Not Skip
*                     GT_TRUE:  Skip
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS softResetSkipParamSetLion3
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_U32    resetRegAddr;     /* register address */
    GT_U32    addConfigRegAddr; /* register address for additional configuration */
    GT_U32    bitOffset;        /* bit offset or value in register */
    GT_U32    hwValue;          /* HW value            */
    GT_STATUS rc;               /* return code */

    /* xCat3; Bobcat2; Caelum; Bobcat3 */
    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
    {
        return GT_OK;
    }

    bitOffset = 8;

    /*
        0x0 = Skip init  ON; SKIP_INIT_ON
        0x1 = Skip init OFF; SKIP_INIT_OFF
    */
    hwValue = 1 - BOOL2BIT_MAC(skipEnable);


    switch(skipType)
    {
        case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            resetRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.configSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            resetRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.tableSkipInitializationMatrix;

            addConfigRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.RAMInitSkipInitializationMatrix;

            rc = prvCpssDrvHwPpResetAndInitControllerSetRegField(
                devNum, addConfigRegAddr, bitOffset, 1, hwValue);
            if(GT_OK != rc)
            {
                return rc;
            }

            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            resetRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.EEPROMSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            resetRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.SERDESSkipInitializationMatrix;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
            /*
                Behavior is un-predictable (probably the device will hang)
                if CPU try to read/write registers/tables
                of the device during the time of soft reset
                (Soft reset is active for 2000 core clock cycles (6uS). Waiting 20uS should be enough)
                Event when '<PEX Skip Init if MG Soft Reset> = SKIP INIT ON'
                (no pex reset).

                *******************************
                meaning that even when skip pex reset there is still interval of
                time that the CPU must not approach the device.
            */
            resetRegAddr =
            PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
               DFXServerUnitsBC2SpecificRegs.PCIeSkipInitializationMatrix;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    return prvCpssDrvHwPpResetAndInitControllerSetRegField(
        devNum, resetRegAddr, bitOffset, 1, hwValue);

}

/*******************************************************************************
* softResetSkipParamSetAll
*
* DESCRIPTION:
*       This routine configure skip parameters related to soft reset. - ALL /ALL_EXCLUDE_PEX
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set , one of:
*                        CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E,
*                        CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E
*       skipEnable  - GT_FALSE: Do Not Skip
*                     GT_TRUE:  Skip
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS softResetSkipParamSetAll
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS   rc;         /* return code */
    CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipIterator; /* loop iterator */
    GT_U32    num_GT_OK = 0;/* number of GT_OK that we got */

    for(skipIterator = CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E;
        skipIterator < CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E;
        skipIterator++)
    {
        if(skipType == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E &&
            skipIterator == CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E)
        {
            /* the pex always will set 'skip' */
            rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, skipIterator, GT_TRUE);
        }
        else
        {
            rc = cpssDxChHwPpSoftResetSkipParamSet(devNum, skipIterator, skipEnable);
        }
        if(rc != GT_OK)
        {
            if(rc == GT_BAD_PARAM || rc == GT_NOT_SUPPORTED)
            {
                /* assume that this specific case is not supported */
            }
            else
            {
                return rc;
            }
        }
        else
        {
            num_GT_OK++;
        }
    }

    if(num_GT_OK == 0)
    {
        /* no flag is supported so declare 'Not supported' -->
           this is Lion2 case ... until implemented */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* internal_cpssDxChHwPpSoftResetSkipParamSet
*
* DESCRIPTION:
*       This routine configure skip parameters related to soft reset.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set
*                     see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*       skipEnable  - GT_FALSE: Do Not Skip
*                     GT_TRUE:  Skip
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpSoftResetSkipParamSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_U32    resetRegAddr;   /* register address */
    GT_U32    bitOffset; /* bit offset or value in register */
    GT_U32    hwValue;   /* HW value            */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(skipType == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_E ||
       skipType == CPSS_HW_PP_RESET_SKIP_TYPE_ALL_EXCLUDE_PEX_E)
    {
        /* set 'ALL' or 'ALL_EXCLUDE_PEX' */
        return softResetSkipParamSetAll(devNum,skipType,skipEnable);
    }

    /* fix relevant only for dxCh3, revision B2*/
    if ((CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E == skipType)
        && (CPSS_PP_FAMILY_CHEETAH3_E
           == PRV_CPSS_PP_MAC(devNum)->devFamily)
        && (1 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.mg.metalFix))
    {
        return softResetSkipParamSetCh3B2LinkLoss(devNum,skipEnable);
    }
    else
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        return softResetSkipParamSetXcat2(devNum,skipType,skipEnable);
    }
    else
    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E)
    {
        /* Lion2 */
        CPSS_TBD_BOOKMARK_LION2;
        /* Need to update implementation for Lion2 */
        /* See Bugs00130006; */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }
    else
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        return softResetSkipParamSetLion3(devNum,skipType,skipEnable);
    }

    /* all devices exclude xCat2; Lion2; Bobcat2; Caelum; Bobcat3 */
    switch(skipType)
    {
        case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
            bitOffset = 21;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
            bitOffset = 22;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
            bitOffset = 23;
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
            if((PRV_CPSS_PP_MAC(devNum)->devFamily  == CPSS_PP_FAMILY_CHEETAH_E)||
               (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_CHEETAH2_E))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
            else
            {
                bitOffset = 24;
            }
            break;
        case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    resetRegAddr =
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
    hwValue = BOOL2BIT_MAC(skipEnable);

    return prvCpssDrvHwPpSetRegField(
        devNum, resetRegAddr, bitOffset, 1, hwValue);
}

/*******************************************************************************
* cpssDxChHwPpSoftResetSkipParamSet
*
* DESCRIPTION:
*       This routine configure skip parameters related to soft reset.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set
*                     see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*       skipEnable  - GT_FALSE: Do Not Skip
*                     GT_TRUE:  Skip
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpSoftResetSkipParamSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    IN  GT_BOOL                         skipEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetSkipParamSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, skipType, skipEnable));

    rc = internal_cpssDxChHwPpSoftResetSkipParamSet(devNum, skipType, skipEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, skipType, skipEnable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwPpSoftResetSkipParamGet
*
* DESCRIPTION:
*       This routine return configuration of skip parameters related to soft reset.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set
*                     see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*
* OUTPUTS:
*       skipEnablePtr   - GT_FALSE: Do Not Skip
*                         GT_TRUE:  Skip
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpSoftResetSkipParamGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    OUT GT_BOOL                         *skipEnablePtr

)
{
    GT_STATUS rc;        /* return code */
    GT_U32    bitOffset; /* bit offset in register */
    GT_U32    value;     /* register data */
    GT_U32    resetRegAddr;   /* register address */
    GT_U32    targetIdx; /* reset target index  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(skipEnablePtr);

    if ((CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E == skipType)
        && (CPSS_PP_FAMILY_CHEETAH3_E
            == PRV_CPSS_PP_MAC(devNum)->devFamily)
        && (1 == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.mg.metalFix))
        {
            rc = prvCpssDrvHwPpGetRegField(devNum,
                        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                        macRegs.perPortRegs[0].serdesMetalFix,
                        8, 1, &value);
            if( GT_OK != rc )
            {
                return rc;
            }

        *skipEnablePtr = BIT2BOOL_MAC(value);
        return GT_OK;
    }
    else if (PRV_CPSS_PP_MAC(devNum)->devFamily
             == CPSS_PP_FAMILY_DXCH_XCAT2_E)
    {
        /* xCat2 */
        switch(skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                targetIdx = 0;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                targetIdx = 3;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                targetIdx = 2;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                targetIdx = 7;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* the matrix is a pair of registers 5 sources multiple 12 targets */
        /* each register contains 6 5-bit-groups for each of 6 targets     */
        /* the management (host CPU) source index is 4                     */
        resetRegAddr = (targetIdx < 6)
            ? PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                dfxUnits.server.genSkipInitMatrix0
            : PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                dfxUnits.server.genSkipInitMatrix1;
        bitOffset = (((targetIdx % 6) * 5) + 4);
    }
    else if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE ||
             PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        /* xCat3; Bobcat2; Caelum; Bobcat3 */
        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
        {
            *skipEnablePtr = GT_TRUE;
            switch(skipType)
            {
                case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                    return GT_OK;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        }

        switch(skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                resetRegAddr =
                PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsBC2SpecificRegs.configSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                resetRegAddr =
                PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsBC2SpecificRegs.tableSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                resetRegAddr =
                PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsBC2SpecificRegs.EEPROMSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                resetRegAddr =
                PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsBC2SpecificRegs.SERDESSkipInitializationMatrix;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                resetRegAddr =
                PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                   DFXServerUnitsBC2SpecificRegs.PCIeSkipInitializationMatrix;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        bitOffset = 8;
    }
    else
    {
        switch(skipType)
        {
            case CPSS_HW_PP_RESET_SKIP_TYPE_REGISTER_E:
                bitOffset = 21;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_TABLE_E:
                bitOffset = 22;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_EEPROM_E:
                bitOffset = 23;
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_PEX_E:
                if((PRV_CPSS_PP_MAC(devNum)->devFamily  == CPSS_PP_FAMILY_CHEETAH_E)||
                   (PRV_CPSS_PP_MAC(devNum)->devFamily  == CPSS_PP_FAMILY_CHEETAH2_E))
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                }
                else
                {
                    bitOffset = 24;
                }
                break;
            case CPSS_HW_PP_RESET_SKIP_TYPE_LINK_LOSS_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

         /* all devices exclude xCat2; Lion2; Bobcat2; Caelum; Bobcat3 */
        resetRegAddr =
            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;
   }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(
                                    devNum, resetRegAddr, bitOffset, 1, &value);
    }
    else
    {
        rc =  prvCpssDrvHwPpGetRegField(
                                    devNum, resetRegAddr, bitOffset, 1, &value);
    }

    if (rc != GT_OK)
    {
        return rc;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E ||
        PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE ||
        PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {
        /* xCat2; xCat3; Bobcat2; Caelum; Bobcat3 - invert the retrieved bit */
        value = ((~ value) & 1);
    }
    *skipEnablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwPpSoftResetSkipParamGet
*
* DESCRIPTION:
*       This routine return configuration of skip parameters related to soft reset.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum      - device number
*       skipType    - the skip parameter to set
*                     see comments in CPSS_HW_PP_RESET_SKIP_TYPE_ENT.
*
* OUTPUTS:
*       skipEnablePtr   - GT_FALSE: Do Not Skip
*                         GT_TRUE:  Skip
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum, or skipType
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpSoftResetSkipParamGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_HW_PP_RESET_SKIP_TYPE_ENT  skipType,
    OUT GT_BOOL                         *skipEnablePtr

)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpSoftResetSkipParamGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, skipType, skipEnablePtr));

    rc = internal_cpssDxChHwPpSoftResetSkipParamGet(devNum, skipType, skipEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, skipType, skipEnablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwPpInitStageGet
*
* DESCRIPTION:
*       Indicates the initialization stage of the device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum       - device number to reset.
*
* OUTPUTS:
*       initStagePtr - pointer to the stage of the device
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpInitStageGet
(
    IN  GT_U8                      devNum,
    OUT CPSS_HW_PP_INIT_STAGE_ENT  *initStagePtr
)
{
    GT_STATUS rc;
    GT_U32    value;        /* value of field */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(initStagePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE ||
       PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E)
    {

        if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.dfxServer.supported == GT_FALSE)
        {
            /* we are not allowed to access the DFX registers */
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_FULLY_FUNC_E;

            return GT_OK;
        }

        rc = prvCpssDrvHwPpResetAndInitControllerGetRegField(devNum,
                        PRV_CPSS_DXCH_DEV_RESET_AND_INIT_CONTROLLER_REGS_MAC(devNum)->
                            DFXServerUnits.DFXServerRegs.serverStatus,
                        4, 2, &value);
    }
    else
    {
        rc =  prvCpssDrvHwPpGetRegField(devNum,
                       PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl,
                       17, 2, &value) ;
    }

    if(rc != GT_OK)
        return rc;

    switch(value)
    {
        case 0:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_INIT_DURING_RESET_E;
            break;
        case 1:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_EEPROM_DONE_INT_MEM_DONE_E;
            break;
        case 2:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_EEPROM_NOT_DONE_INT_MEM_DONE_E;
            break;
        case 3:
            *initStagePtr =  CPSS_HW_PP_INIT_STAGE_FULLY_FUNC_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    return rc;

}

/*******************************************************************************
* cpssDxChHwPpInitStageGet
*
* DESCRIPTION:
*       Indicates the initialization stage of the device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum       - device number to reset.
*
* OUTPUTS:
*       initStagePtr - pointer to the stage of the device
*
* RETURNS:
*       GT_OK                    - on success,
*       GT_FAIL                  - otherwise.
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpInitStageGet
(
    IN  GT_U8                      devNum,
    OUT CPSS_HW_PP_INIT_STAGE_ENT  *initStagePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpInitStageGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, initStagePtr));

    rc = internal_cpssDxChHwPpInitStageGet(devNum, initStagePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, initStagePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* prvCpssDxChCscdPortLocalDeviceNumberSet
*
* DESCRIPTION:
*       Set the <Local Device Number> for an egress Cascade Port.
*       this value act as <srcDev> field in the FORWARD DSA tag that egress the port.
*       NOTE: this value is used even when <Set Source to Local> is UNSET ,
*             for packets that ingresses without DSA tag to the device.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum        - device number
*       portNum       - port number or CPU port
*       localHwDeviceNumber - the local HW device number.
*                       (APPLICABLE RANGES: 0..0xFFF)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong value in any of the parameters
*       GT_OUT_OF_RANGE          - the value of localDeviceNumber is out of range.
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS prvCpssDxChCscdPortLocalDeviceNumberSet
(
    IN  GT_U8                               devNum,
    IN  GT_PHYSICAL_PORT_NUM                portNum,
    IN  GT_HW_DEV_NUM                       localHwDeviceNumber
)
{
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
          CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    /* <Local Device Number> */
    rc = prvCpssDxChWriteTableEntryField(devNum,
              PRV_CPSS_DXCH_LION3_TABLE_HA_PHYSICAL_PORT_2_E,
              portNum, /*global port*/
              PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
              LION3_HA_PHYSICAL_PORT_TABLE_2_FIELDS_LOCAL_DEVICE_NUMBER_E, /* field name */
              PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
              localHwDeviceNumber);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChCfgHwDevNumSet
*
* DESCRIPTION:
*       write HW device number
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum   - device number
*       hwDevNum - HW device number
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on bad device
*       GT_OUT_OF_RANGE          - on hwDevNum > 31
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChCfgHwDevNumSet
(
    IN GT_U8    devNum,
    IN GT_HW_DEV_NUM    hwDevNum
)
{
    GT_STATUS rc;
    GT_U32    regAddr;      /* register's address */
    GT_U32    portGroupId;    /* port group id    */
    GT_PHYSICAL_PORT_NUM    portNum;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(hwDevNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(sysGenGlobalInfo.supportDualDeviceId == GT_TRUE)
    {
        /* this is 'dual device system' all hwDevNum for all devices (not only those of Lion2)
            must be even (0,2,4,6...)*/
        if (hwDevNum & 1)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    /* The function must be called before DB update by new HW device number. */
    rc = prvCpssDxChTrunkHwDevNumSet(devNum, hwDevNum);
    if(rc != GT_OK)
    {
        return rc;
    }
    regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.globalControl;

    /* write to both hemisphere if exists */
    if ( (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E) &&
         (PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum) ) )
    {
        /* check that even */
        if (hwDevNum%2)
        {
            /* NOTE that we should never get here because the 'phase1Init' already
               checked that the lion2 is in system of supportDualDeviceId == GT_TRUE
               and in start of current function we already checked validity of 'must be even number'

               BUT we keep this check for the completeness of logic.
               */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* set on all port groups in hemisphere 0 the hwDevNum */
        for (portGroupId=0; portGroupId < PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
              portGroupId++)
        {
            /* skip non active port groups */
            if((PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp & (1 << portGroupId)) == 0)
            {
                continue;
            }

            rc = prvCpssDrvHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,4,5,hwDevNum);
            if (rc != GT_OK)
            {
                return rc;
            }

        }

        /* set on all port groups in hemisphere 1 the hwDevNum+1 */
        for (portGroupId=PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
              portGroupId <PRV_CPSS_LION2_PORT_GROUPS_NUM_CNS; portGroupId++)
        {
            /* skip non active port groups */
            if((PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp & (1 << portGroupId)) == 0)
            {
                continue;
            }

            rc = prvCpssDrvHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,4,5,hwDevNum+1);
            if (rc != GT_OK)
            {
                return rc;
            }

        }

        /* unmark the old HW dev number to default single mode */
        rc = cpssDxChCscdDbRemoteHwDevNumModeSet(PRV_CPSS_HW_DEV_NUM_MAC(devNum),
                                                 CPSS_GEN_CFG_HW_DEV_NUM_MODE_SINGLE_E);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* mark the new HW dev as daul device in the DB */
        rc = cpssDxChCscdDbRemoteHwDevNumModeSet(hwDevNum,
                                                 CPSS_GEN_CFG_HW_DEV_NUM_MODE_DUAL_E);
        if (rc != GT_OK)
        {
            return rc;
        }

        /* save HW devNum to the DB */
        PRV_CPSS_HW_DEV_NUM_MAC(devNum) = hwDevNum;

        return GT_OK;
    }

    /* allow HW write to the device Device_ID within a Prestera chipset*/
    if (dxChFastBootSkipOwnDeviceInit == GT_FALSE)
    {
        /* Set all 5 or 10 bits of "ownDevNum" in Global Control register */
        rc = prvCpssDrvHwPpSetRegField(devNum, regAddr,
                                       4,PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum,
                                       hwDevNum);
        if(rc != GT_OK)
        {
            return rc;
        }
    }


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /*
            set all the egress physical ports with the 'own device'.
            This config relate to cascade ports and the <srcDev> in the FORWARD DSA tag.

        */

        for( portNum = 0 ;
             portNum < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) ;
             portNum ++ )
        {
            rc = prvCpssDxChCscdPortLocalDeviceNumberSet(devNum,portNum,hwDevNum);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    /* save HW devNum to the DB */
    PRV_CPSS_HW_DEV_NUM_MAC(devNum) = hwDevNum;

    return rc;
}

/*******************************************************************************
* cpssDxChCfgHwDevNumSet
*
* DESCRIPTION:
*       write HW device number
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum   - device number
*       hwDevNum - HW device number
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on bad device
*       GT_OUT_OF_RANGE          - on hwDevNum > 31
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChCfgHwDevNumSet
(
    IN GT_U8    devNum,
    IN GT_HW_DEV_NUM    hwDevNum
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChCfgHwDevNumSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, hwDevNum));

    rc = internal_cpssDxChCfgHwDevNumSet(devNum, hwDevNum);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, hwDevNum));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChCfgHwDevNumGet
*
* DESCRIPTION:
*       Read HW device number
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum   - device number
*
* OUTPUTS:
*       hwDevNumPtr - Pointer to HW device number
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on bad device
*       GT_BAD_PTR               - one of the parameters in NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*        None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChCfgHwDevNumGet
(
    IN GT_U8    devNum,
    OUT GT_HW_DEV_NUM   *hwDevNumPtr
)
{
    GT_U32    regVal; /* register field value */
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(hwDevNumPtr);

    /* Get 5 or 10 bits "ownDevNum" from Global Control register */
    rc = prvCpssDrvHwPpGetRegField(devNum, PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->
                                   globalRegs.globalControl,
                                   4, PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).hwDevNum,
                                   &regVal);
    if(rc != GT_OK)
    {
        return rc;
    }

    *hwDevNumPtr = regVal;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChCfgHwDevNumGet
*
* DESCRIPTION:
*       Read HW device number
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum   - device number
*
* OUTPUTS:
*       hwDevNumPtr - Pointer to HW device number
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on bad device
*       GT_BAD_PTR               - one of the parameters in NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*        None.
*
*******************************************************************************/
GT_STATUS cpssDxChCfgHwDevNumGet
(
    IN GT_U8    devNum,
    OUT GT_HW_DEV_NUM   *hwDevNumPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChCfgHwDevNumGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, hwDevNumPtr));

    rc = internal_cpssDxChCfgHwDevNumGet(devNum, hwDevNumPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, hwDevNumPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwCoreClockGet
*
* DESCRIPTION:
*       This function returns the core clock value from cpss DB and from HW.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum         - The Pp's device number.
*
* OUTPUTS:
*       coreClkDbPtr    - Pp's core clock from cpss DB (MHz)
*       coreClkHwPtr    - Pp's core clock read from HW (MHz) or zero
*                         if PLL configuration as sampled at reset could
*                         not be mapped to core clock value.
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwCoreClockGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *coreClkDbPtr,
    OUT GT_U32  *coreClkHwPtr
)
{
    GT_STATUS rc;
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(coreClkDbPtr);
    CPSS_NULL_PTR_CHECK_MAC(coreClkHwPtr);

    *coreClkDbPtr = PRV_CPSS_PP_MAC(devNum)->coreClock;
    rc = hwPpAutoDetectCoreClock(devNum,coreClkHwPtr);
    if (rc == GT_BAD_STATE)
    {
        *coreClkHwPtr = 0;
        rc = GT_OK;
    }
    return rc;
}

/*******************************************************************************
* cpssDxChHwCoreClockGet
*
* DESCRIPTION:
*       This function returns the core clock value from cpss DB and from HW.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum         - The Pp's device number.
*
* OUTPUTS:
*       coreClkDbPtr    - Pp's core clock from cpss DB (MHz)
*       coreClkHwPtr    - Pp's core clock read from HW (MHz) or zero
*                         if PLL configuration as sampled at reset could
*                         not be mapped to core clock value.
* RETURNS:
*       GT_OK                    - on success,
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChHwCoreClockGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *coreClkDbPtr,
    OUT GT_U32  *coreClkHwPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwCoreClockGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, coreClkDbPtr, coreClkHwPtr));

    rc = internal_cpssDxChHwCoreClockGet(devNum, coreClkDbPtr, coreClkHwPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, coreClkDbPtr, coreClkHwPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwInterruptCoalescingSet
*
* DESCRIPTION:
*       Configures the interrupt coalescing parameters and enable\disable the
*       functionality.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*       enable  - GT_TRUE: interrupt coalescing is enabled
*                 GT_FALSE: interrupt coalescing is disabled
*       period  - Minimal IDLE period between two consecutive interrupts.
*                 The units of this input parameter is in nSec, the
*                 resolution is in 320 nSec (the HW resolution for the
*                 interrupt coalescing period is 0.32uSec). In case interrupt
*                 coalescing is enabled (enable == GT_TRUE)
*                 (APPLICABLE RANGES: 320..5242560).
*                 Otherwise (enable == GT_FALSE), ignored.
*       linkChangeOverride  - GT_TRUE: A link change in one of the ports
*                             results interrupt regardless of the (coalescing)
*                             period.
*                             GT_FALSE: A link change in one of the ports
*                             does not results interrupt immediately but
*                             according to the (coalescing) period.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_HW_ERROR              - on hardware error
*       GT_OUT_OF_RANGE          - parameter out of range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwInterruptCoalescingSet
(
    IN GT_U8    devNum,
    IN GT_BOOL  enable,
    IN GT_U32   period,
    IN GT_BOOL  linkChangeOverride
)
{
    GT_U32 regAddr;   /* register's address */
    GT_U32 regData;   /* register's data */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if( enable == GT_TRUE )
    {
        if( period < MIN_INTERRUPT_COALESCING_PERIOD_CNS ||
            period > MAX_INTERRUPT_COALESCING_PERIOD_CNS )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }
        regData = period/MIN_INTERRUPT_COALESCING_PERIOD_CNS;
    }
    else /* enable == GT_FALSE */
    {
        regData = 0;
    }

    U32_SET_FIELD_MAC(regData, 16, 1, ((linkChangeOverride == GT_TRUE) ? 0 : 1));

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.interruptCoalescing;

    return prvCpssDrvHwPpWriteRegBitMask(devNum, regAddr, 0x13FFF, regData);
}

/*******************************************************************************
* cpssDxChHwInterruptCoalescingSet
*
* DESCRIPTION:
*       Configures the interrupt coalescing parameters and enable\disable the
*       functionality.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*       enable  - GT_TRUE: interrupt coalescing is enabled
*                 GT_FALSE: interrupt coalescing is disabled
*       period  - Minimal IDLE period between two consecutive interrupts.
*                 The units of this input parameter is in nSec, the
*                 resolution is in 320 nSec (the HW resolution for the
*                 interrupt coalescing period is 0.32uSec). In case interrupt
*                 coalescing is enabled (enable == GT_TRUE)
*                 (APPLICABLE RANGES: 320..5242560).
*                 Otherwise (enable == GT_FALSE), ignored.
*       linkChangeOverride  - GT_TRUE: A link change in one of the ports
*                             results interrupt regardless of the (coalescing)
*                             period.
*                             GT_FALSE: A link change in one of the ports
*                             does not results interrupt immediately but
*                             according to the (coalescing) period.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_HW_ERROR              - on hardware error
*       GT_OUT_OF_RANGE          - parameter out of range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChHwInterruptCoalescingSet
(
    IN GT_U8    devNum,
    IN GT_BOOL  enable,
    IN GT_U32   period,
    IN GT_BOOL  linkChangeOverride
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwInterruptCoalescingSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable, period, linkChangeOverride));

    rc = internal_cpssDxChHwInterruptCoalescingSet(devNum, enable, period, linkChangeOverride);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable, period, linkChangeOverride));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwInterruptCoalescingGet
*
* DESCRIPTION:
*       Gets the interrupt coalescing configuration parameters.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*
* OUTPUTS:
*       enablePtr  - (pointer to) GT_TRUE: interrupt coalescing is enabled
*                                 GT_FALSE: interrupt coalescing is disabled
*       periodPtr  - (pointer to) Minimal IDLE period between two consecutive
*                    interrupts. The units are in nSec with resolution of
*                    320nSec (due to HW resolution) and is relevant only in
*                    case interrupt coalescing is enabled (*enablePtr == GT_TRUE).
*                    (APPLICABLE RANGES: 320..5242560).
*       linkChangeOverridePtr  - (pointer to)
*                                GT_TRUE: A link change in one of the ports
*                                results interrupt regardless of the (coalescing)
*                                period.
*                                GT_FALSE: A link change in one of the ports
*                                does not results interrupt immediately but
*                                according to the (coalescing) period.
*
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       The HW resolution for the interrupt coalescing period is 0.32uSec.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwInterruptCoalescingGet
(
    IN GT_U8        devNum,
    OUT GT_BOOL     *enablePtr,
    OUT GT_U32      *periodPtr,
    OUT GT_BOOL     *linkChangeOverridePtr
)
{
    GT_U32 regAddr;   /* register's address */
    GT_U32 regData;   /* register's data */
    GT_STATUS rc;     /* return code */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    CPSS_NULL_PTR_CHECK_MAC(periodPtr);
    CPSS_NULL_PTR_CHECK_MAC(linkChangeOverridePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.interruptCoalescing;

    rc = prvCpssDrvHwPpReadRegBitMask(devNum, regAddr, 0x13FFF, &regData);
    if( rc != GT_OK )
        return rc;

    *periodPtr = (GT_U32)(U32_GET_FIELD_MAC(regData, 0, 14) * MIN_INTERRUPT_COALESCING_PERIOD_CNS);

    *enablePtr = (*periodPtr == 0 ) ? GT_FALSE : GT_TRUE ;

    *linkChangeOverridePtr =
        (U32_GET_FIELD_MAC(regData, 16, 1) == 0) ? GT_TRUE : GT_FALSE ;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChHwInterruptCoalescingGet
*
* DESCRIPTION:
*       Gets the interrupt coalescing configuration parameters.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*
* OUTPUTS:
*       enablePtr  - (pointer to) GT_TRUE: interrupt coalescing is enabled
*                                 GT_FALSE: interrupt coalescing is disabled
*       periodPtr  - (pointer to) Minimal IDLE period between two consecutive
*                    interrupts. The units are in nSec with resolution of
*                    320nSec (due to HW resolution) and is relevant only in
*                    case interrupt coalescing is enabled (*enablePtr == GT_TRUE).
*                    (APPLICABLE RANGES: 320..5242560).
*       linkChangeOverridePtr  - (pointer to)
*                                GT_TRUE: A link change in one of the ports
*                                results interrupt regardless of the (coalescing)
*                                period.
*                                GT_FALSE: A link change in one of the ports
*                                does not results interrupt immediately but
*                                according to the (coalescing) period.
*
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       The HW resolution for the interrupt coalescing period is 0.32uSec.
*
*******************************************************************************/
GT_STATUS cpssDxChHwInterruptCoalescingGet
(
    IN GT_U8        devNum,
    OUT GT_BOOL     *enablePtr,
    OUT GT_U32      *periodPtr,
    OUT GT_BOOL     *linkChangeOverridePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwInterruptCoalescingGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr, periodPtr, linkChangeOverridePtr));

    rc = internal_cpssDxChHwInterruptCoalescingGet(devNum, enablePtr, periodPtr, linkChangeOverridePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr, periodPtr, linkChangeOverridePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* prvCpssDxChHwDropModeToHwValueAndPacketCommandConvert
*
* DESCRIPTION:
*       convert from  'drop mode' to : packet command and to HW value
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*       dropMode - drop mode
* OUTPUTS:
*       packetCommandPtr  - (pointer to) packet command (can be NULL --> ignored)
*       fieldValuePtr     - (pointer to) HW field value (can be NULL --> ignored)
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwDropModeToHwValueAndPacketCommandConvert
(
    IN GT_U8        devNum,
    IN CPSS_DROP_MODE_TYPE_ENT dropMode,
    OUT CPSS_PACKET_CMD_ENT *packetCommandPtr,
    OUT GT_U32              *fieldValuePtr
)
{
    CPSS_PACKET_CMD_ENT packetCommand; /*packet command */
    GT_U32            fieldValue;/*field value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    switch(dropMode)
    {
        case CPSS_DROP_MODE_HARD_E:
            packetCommand = CPSS_PACKET_CMD_DROP_HARD_E;
            break;
        case CPSS_DROP_MODE_SOFT_E:
            packetCommand = CPSS_PACKET_CMD_DROP_SOFT_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* convert packet command to HW value */
        PRV_CPSS_CONVERT_PACKET_CMD_TO_HW_VAL_MAC(fieldValue,packetCommand);
    }
    else
    {
        /* convert drop mode to HW value */
        fieldValue = (dropMode == CPSS_DROP_MODE_HARD_E) ? 1 /* hard */ : 0/* soft*/;
    }

    if(packetCommandPtr)
    {
        *packetCommandPtr = packetCommand;
    }

    if(fieldValuePtr)
    {
        *fieldValuePtr = fieldValue;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwHwValueToDropModeAndPacketCommandConvert
*
* DESCRIPTION:
*       convert from HW value : to 'drop mode' and to packet command
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - device number
*       fieldValue     - HW field value
* OUTPUTS:
*       packetCommandPtr  - (pointer to) packet command (can be NULL --> ignored)
*       dropModePtr       - (pointer to) drop mode (can be NULL --> ignored)
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwHwValueToDropModeAndPacketCommandConvert
(
    IN GT_U8        devNum,
    IN GT_U32       fieldValue,
    OUT CPSS_PACKET_CMD_ENT     *packetCommandPtr,
    OUT CPSS_DROP_MODE_TYPE_ENT *dropModePtr
)
{
    CPSS_PACKET_CMD_ENT packetCommand;/* packet command */
    CPSS_DROP_MODE_TYPE_ENT dropMode; /* drop mode      */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_MAC(devNum) == GT_TRUE)
    {
        /* convert HW value to packet command */
        PRV_CPSS_CONVERT_HW_VAL_TO_PACKET_CMD_MAC(packetCommand,fieldValue);

        if(packetCommand == CPSS_PACKET_CMD_DROP_HARD_E)
        {
            dropMode = CPSS_DROP_MODE_HARD_E;
        }
        else if(packetCommand == CPSS_PACKET_CMD_DROP_SOFT_E)
        {
            dropMode = CPSS_DROP_MODE_SOFT_E;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        /* convert HW value to drop mode */
        dropMode = (fieldValue == 1) ?
                CPSS_DROP_MODE_HARD_E :
                CPSS_DROP_MODE_SOFT_E;

        if(fieldValue == 1)
        {
            dropMode = CPSS_DROP_MODE_HARD_E;
            packetCommand = CPSS_PACKET_CMD_DROP_HARD_E;
        }
        else if(fieldValue == 0)
        {
            dropMode = CPSS_DROP_MODE_SOFT_E;
            packetCommand = CPSS_PACKET_CMD_DROP_SOFT_E;
        }
        else
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    if(packetCommandPtr)
    {
        *packetCommandPtr = packetCommand;
    }

    if(dropModePtr)
    {
        *dropModePtr = dropMode;
    }

    return GT_OK;
}


/*******************************************************************************
* prvCpssDxChHwPpPortToGopConvert
*
* DESCRIPTION:
*    Private (internal) function converts Port number to Group Of Ports number
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum       - device number
*       phyPortNum   - physical port number
*
* OUTPUTS:
*       portGroupPtr - (pointer to) Port Group Number
*                       for not multi port group devices
*                       CPSS_PORT_GROUP_UNAWARE_MODE_CNS
*       gopNumPtr    - (pointer to) Group of Ports Number
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device number
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwPpPortToGopConvert
(
    IN  GT_U8                        devNum,
    IN  GT_PHYSICAL_PORT_NUM         phyPortNum,
    OUT GT_U32                       *portGroupPtr,
    OUT GT_U32                       *gopNumPtr
)
{
    GT_PHYSICAL_PORT_NUM   localPort; /* local port for multi port group devices */

    *portGroupPtr = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, phyPortNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum, phyPortNum);

    switch (PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            /* Bobcat2 unity has 9 GOPs - 4 serdes in each.       */
            /* There are several possible HW configurations       */
            /* for different port speeds but the range of port    */
            /* numbers for each GOP is single for all of them.    */
            /* For example GOP0 can contain                       */
            /* QSGMI ports 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15  */
            /* or SGMI ports 0,4,8,12.                            */
            /* These are the port ranges in GOPs:                 */
            /* GOP0 port0  - port15                               */
            /* GOP1 port16 - port31                               */
            /* GOP2 port32 - port47                               */
            /* GOP3 port48 - port51                               */
            /* GOP4 port52 - port55                               */
            /* GOP5 port56 - port59                               */
            /* GOP6 port60 - port63                               */
            /* GOP7 port64 - port67                               */
            /* GOP8 port68 - port71                               */
            *gopNumPtr =
                ((localPort < 48)
                    ? (localPort / 16)
                    : (3 + ((localPort - 48) / 4)));
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
            *gopNumPtr = (localPort)/4;
            break;
        default: CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
    }
    return GT_OK;
}

/*******************************************************************************
* egfShtFieldInfoGet
*
* DESCRIPTION:
*       get info about a field to the EGF_SHT table/register that represent the
*           physical port or the eport.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - the device number
*       fieldType - the field type
*       accessPhysicalPort - GT_TRUE : indication if to access to the physical ports registers
*                            GT_FALSE : access to the ePort table
*
* OUTPUTS:
*       regAddrPtrPtr - (pointer to) (pointer to) registers addresses
*       startBitPtr - (pointer to) start bit index
*       numBitsPtr - (pointer to) number of bits for the field
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS   egfShtFieldInfoGet
(
    IN GT_U8                    devNum,
    IN PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ENT  fieldType,
    IN GT_BOOL                  accessPhysicalPort,
    IN GT_U32                   **regAddrPtrPtr,
    IN GT_U32                   *startBitPtr,
    IN GT_U32                   *numBitsPtr
)
{
    GT_U32  *regAddrPtr;/*pointer to register address*/
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  startBit;/*start bit to set */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    numBits = 1;

    if(accessPhysicalPort == GT_FALSE)
    {
        switch(fieldType)
        {
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_E:
                startBit = 7;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_VLAN_FILTER_E:
                startBit = 4;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_UC_SRC_ID_FILTER_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per physical port */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MC_LOCAL_ENABLE_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per physical port */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IGNORE_PHY_SRC_MC_FILTER_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per physical port */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_MODE_E:
                startBit = 8;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ODD_ONLY_SRC_ID_FILTER_ENABLE_E:
                startBit = 9;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ROUTED_FORWARD_RESTRICTED_E:
                startBit = 2;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IPMC_ROUTED_FILTER_ENABLE_E:
                startBit = 3;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_FROM_CPU_FORWARD_RESTRICTED_E:
                startBit = 0;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_BRIDGED_FORWARD_RESTRICTED_E:
                startBit = 1;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_PORT_ISOLATION_MODE_E:
                /*2 bits per port*/
                numBits = 2;
                startBit = 5;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_EPORT_EVLAN_FILTER_ENABLE_E:
                startBit = 10;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MESH_ID_E:
                /*4 bits per port*/
                numBits = 4;
                startBit = 11;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EPORT_ASSOCIATED_VID1_E:
                /* 12 bits per port */
                numBits = 12;
                startBit = 16;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_DROP_ON_EPORT_VID1_MISMATCH_E:
                startBit = 15;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        regAddrPtr = NULL;/* not relevant */
    }
    else /*(accessPhysicalPort == GT_TRUE)*/
    {
        switch(fieldType)
        {
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportStpState[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_VLAN_FILTER_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportEvlanFilteringEnable[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_UC_SRC_ID_FILTER_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.UCSrcIDFilterEn[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MC_LOCAL_ENABLE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.MCLocalEn[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IGNORE_PHY_SRC_MC_FILTER_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.ignorePhySrcMcFilterEn[0]/*Reg Offset*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_STP_STATE_MODE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportStpStateMode[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ODD_ONLY_SRC_ID_FILTER_ENABLE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportOddOnlySrcIdFilterEnable[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ROUTED_FORWARD_RESTRICTED_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportRoutedForwardRestricted[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_IPMC_ROUTED_FILTER_ENABLE_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportIPMCRoutedFilterEn[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_FROM_CPU_FORWARD_RESTRICTED_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportFromCPUForwardRestricted[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_BRIDGED_FORWARD_RESTRICTED_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportBridgedForwardRestricted[0]/*Port div 32*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_PORT_ISOLATION_MODE_E:
                /*2 bits per port*/
                numBits = 2;
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportPortIsolationMode[0]/*Port div 16*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_MESH_ID_E:
                numBits = 4;
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.ePortMeshId[0]/*Port div 8*/;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EGRESS_EPORT_EVLAN_FILTER_ENABLE_E:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);/* only per EPort */
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_EPORT_ASSOCIATED_VID1_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.eportVid1[0]/*Port div 2*/;
                numBits = 12;
                break;
            case PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_DROP_ON_EPORT_VID1_MISMATCH_E:
                regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.dropOnEportVid1MismatchEn[0]/*Port div 32*/;
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        startBit = 0;/*will be calculated at the caller */
    }

    *regAddrPtrPtr = regAddrPtr;

    *startBitPtr = startBit;
    *numBitsPtr = numBits;

    return GT_OK;

}

/*******************************************************************************
* prvCpssEgfShtCalcStartBit
*
* DESCRIPTION:
*       Calculate an offset (in bits) of a data inside a vector of 32bit words
*
*       |------------32 bits-------------|--------------32 bits-----------|...
*       |<data0><data1>...<dataN><unused>|<dataN + 1><dataN + 2>..<unused>|...
*
* INPUTS:
*       index   - an index of a data (is starts from 0)
*       dataLen - the length of the data in bits (can't exceed 32 bits!)
*
* OUTPUTS:
*       None
*
* RETURNS:
*       an offset (first bit number) of the data
*
* COMMENTS:
*       the dataLen can't be greater than 32
*
*******************************************************************************/
static GT_U32 prvCpssEgfShtCalcStartBit
(
    IN GT_PORT_NUM index,
    IN GT_U32      dataLen
)
{
    GT_U32 gapLen;          /* unused bits count at the end of 32bit word */
    GT_U32 numGaps;         /* total number of gaps */
    GT_U32 offset;

    offset = index * dataLen;
    gapLen = 32 % dataLen;
    if (gapLen != 0)
    {
        numGaps = index / (32 / dataLen);
        offset += gapLen * numGaps;
    }
    return offset;
}

/*******************************************************************************
* prvCpssDxChHwEgfShtFieldSet
*
* DESCRIPTION:
*       Write a field to the EGF_SHT table/register that represent the
*           physical port and/or the eport.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - the device number
*       portNum - the port number (physical port and/or the eport)
*       fieldType - the field type
*       accessPhysicalPort - indication if to access to the physical ports registers
*                   relevant only for the portNum < 256
*       accessEPort  - indication if to access to the EPort table
*       value - the data write to the register and/or table
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS   prvCpssDxChHwEgfShtFieldSet
(
    IN GT_U8                    devNum,
    IN GT_PORT_NUM              portNum,
    IN PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ENT  fieldType,
    IN GT_BOOL                  accessPhysicalPort,
    IN GT_BOOL                  accessEPort,
    IN GT_U32                   value
)
{
    GT_STATUS  rc;
    GT_U32    *regAddrPtr;      /* (pointer to) register address */
    GT_U32     numBits;         /*number of bits to set*/
    GT_U32     startBit;        /*start bit to set */
    GT_BOOL    didWrite = GT_FALSE; /*indication if we did write before finish the function */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if(accessEPort == GT_TRUE)
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_FALSE,/*accessPhysicalPort*/
            &regAddrPtr,/* not used */
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(value > BIT_MASK_MAC(numBits))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssDxChWriteTableEntryField(devNum,
                   PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_SHT_EGRESS_EPORT_E,
                   portNum,
                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                   startBit, /* start bit */
                   numBits,  /* num of bits */
                   value);
        if(rc != GT_OK)
        {
            return rc;
        }

        didWrite = GT_TRUE;
    }

    if( (accessPhysicalPort == GT_TRUE) &&
        (portNum < PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum)) )
    {
        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_TRUE,/*accessPhysicalPort*/
            &regAddrPtr,
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(regAddrPtr == NULL)
        {
            /*should not happen*/
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }

        if(value > BIT_MASK_MAC(numBits))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        }

        startBit = prvCpssEgfShtCalcStartBit(portNum, numBits);

        rc = prvCpssHwPpSetRegField(devNum,
                 regAddrPtr[OFFSET_TO_WORD_MAC(startBit)],
                 OFFSET_TO_BIT_MAC(startBit) ,
                 numBits,
                 value);
        if(rc != GT_OK)
        {
            return rc;
        }

        didWrite = GT_TRUE;
    }

    if(didWrite == GT_FALSE)
    {
        /* no write access to table / register was done ! */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwEgfShtFieldGet
*
* DESCRIPTION:
*       Read a field to the EGF_SHT table/register that represent the
*           physical port or the eport.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - the device number
*       portNum - the port number (physical port or the eport)
*       fieldType - the field type
*       accessPhysicalPort - GT_TRUE : indication if to access to the physical ports registers
*                               relevant only for the portNum < 256
*                            GT_FALSE : access to the ePort table
*
* OUTPUTS:
*       valuePtr - (pointer to)the data read from the register or table
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS   prvCpssDxChHwEgfShtFieldGet
(
    IN GT_U8                    devNum,
    IN GT_PORT_NUM              portNum,
    IN PRV_CPSS_DXCH_HW_EGF_SHT_FIELD_ENT  fieldType,
    IN GT_BOOL                  accessPhysicalPort,
    OUT GT_U32                   *valuePtr
)
{
    GT_STATUS  rc;
    GT_U32    *regAddrPtr;      /* (pointer to) register address */
    GT_U32     numBits;         /*number of bits to set*/
    GT_U32     startBit;        /*start bit to set */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(valuePtr);

    if( (accessPhysicalPort == GT_FALSE) ||
        (portNum >= PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum)) )
    {
        PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_FALSE,/*accessPhysicalPort*/
            &regAddrPtr,/* not used */
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        rc = prvCpssDxChReadTableEntryField(devNum,
                   PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_SHT_EGRESS_EPORT_E,
                   portNum,
                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                   startBit, /* start bit */
                   numBits,  /* num of bits */
                   valuePtr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else /*(accessPhysicalPort == GT_TRUE && (portNum < 256))*/
    {
        PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

        rc = egfShtFieldInfoGet(devNum,fieldType,
            GT_TRUE,/*accessPhysicalPort*/
            &regAddrPtr,
            &startBit,
            &numBits);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(regAddrPtr == NULL)
        {
            /*should not happen*/
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }

        startBit = prvCpssEgfShtCalcStartBit(portNum, numBits);

        rc = prvCpssHwPpGetRegField(devNum,
                 regAddrPtr[OFFSET_TO_WORD_MAC(startBit)],
                 OFFSET_TO_BIT_MAC(startBit) ,
                 numBits,
                 valuePtr);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}

/*******************************************************************************
* egfEftFieldInfoGet
*
* DESCRIPTION:
*       get info about a field to the EGF_EFT register that represent the
*           physical port .
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - the device number
*       fieldType - the field type
*
* OUTPUTS:
*       regAddrPtrPtr - (pointer to) (pointer to) registers addresses
*       numBitsPtr - (pointer to) number of bits for the field
*       numBitsOffsetBetweenPortsPtr - (pointer to) number of bits between 2 consecutive ports
*       numPortsInRegisterPtr - (pointer to) number of ports in register
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS   egfEftFieldInfoGet
(
    IN GT_U8                    devNum,
    IN PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_ENT  fieldType,
    IN GT_U32                   **regAddrPtrPtr,
    IN GT_U32                   *numBitsPtr,
    IN GT_U32                   *numBitsOffsetBetweenPortsPtr,
    IN GT_U32                   *numPortsInRegisterPtr
)
{
    GT_U32  *regAddrPtr;/*pointer to register address*/
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  numBitsOffsetBetweenPorts;/*number of bits between 2 consecutive ports */
    GT_U32  numPortsInRegister;/*number of ports in register*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    numBits = 1;
    numBitsOffsetBetweenPorts = 0xFFFFFFFF;/*indication that was not set yet */
    numPortsInRegister = AUTO_CALC_FIELD_CNS;/*indication that need auto calculation */

    switch(fieldType)
    {
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_MC_FIFO_ATTRIBUTION_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.portToMcFIFOAttributionReg[0]/*reg_offset*/;
            numBits = 2;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_MC_FIFO_PORT_TO_HEMISPHERE_MAP_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).MCFIFO.MCFIFOConfigs.portToHemisphereMapReg[0]/*reg offset*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_FC_TRIGGER_BY_CN_FRAME_ON_PORT_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.enFCTriggerByCNFrameOnPort[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_CN_FRAME_TX_ON_PORT_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.enCNFrameTxOnPort[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_UNREGED_BC_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.unregedBCFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_UNKNOWN_UC_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.unknownUCFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_UNREGED_MC_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.unregedMCFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_OAM_LOOPBACK_FILTER_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.OAMLoopbackFilterEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_VIRTUAL_2_PHYSICAL_PORT_REMAP_E:
            if(PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.virtual2PhysicalPortRemap[0]/*offset*/;
            numBits = PRV_CPSS_DXCH_PP_HW_INFO_FLEX_FIELD_NUM_BITS_SUPPORTED_MAC(devNum).phyPort;
            numBitsOffsetBetweenPorts =  MAX(numBits,8);
            numPortsInRegister = numPortsInRegister;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_EGR_FILTER_PHYSICAL_PORT_LINK_STATUS_MASK_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).egrFilterConfigs.physicalPortLinkStatusMask[0]/*reg offset*/;
            numBits = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 1 : 2;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_ADDR_CONSTRUCT_PROFILE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.devMapTableAddrConstructProfile[0]/*profile_num*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_LOCAL_SRC_PORT_MAP_OWN_DEV_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.localSrcPortMapOwnDevEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_LOCAL_TRG_PORT_MAP_OWN_DEV_ENABLE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.localTrgPortMapOwnDevEn[0]/*Port div 32*/;
            break;
        case PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_DEV_MAP_TABLE_PORT_ADDR_CONSTRUCT_MODE_ADDRESS_PROFILE_E:
            regAddrPtr = &PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).deviceMapConfigs.portAddrConstructMode[0]/*local physical source port*/;
            numBits = 3;
            numPortsInRegister =  PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 8 : 1;

            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    *regAddrPtrPtr = regAddrPtr;
    *numBitsPtr = numBits;
    if(numBitsOffsetBetweenPorts != 0xFFFFFFFF)
    {
        *numBitsOffsetBetweenPortsPtr = numBitsOffsetBetweenPorts;
    }
    else
    {
        /*by default this equal the numBits */
        *numBitsOffsetBetweenPortsPtr = numBits;
    }

    if(numPortsInRegister == AUTO_CALC_FIELD_CNS)
    {
        /* auto calc */
        numPortsInRegister = 32 / numBits;
    }

    *numPortsInRegisterPtr = numPortsInRegister;


    return GT_OK;

}

/*******************************************************************************
* prvCpssDxChHwEgfEftFieldSet
*
* DESCRIPTION:
*       Write a field to the EGF_EFT register that represent the
*           physical port.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - the device number
*       portNum - the port number (physical port)
*       fieldType - the field type
*       value - the data write to the register
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS   prvCpssDxChHwEgfEftFieldSet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_ENT  fieldType,
    IN GT_U32                   value
)
{
    GT_STATUS   rc;
    GT_U32  *regAddrPtr;/* (pointer to) register address */
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  numBitsOffsetBetweenPorts;/*number of bits between 2 consecutive ports */
    GT_U32  numPortsInRegister;/*number of ports in register*/
    GT_U32  wordIndex;/*index in registers array*/
    GT_U32  bitIndex;/*index in the register*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    rc = egfEftFieldInfoGet(devNum,fieldType,
        &regAddrPtr,
        &numBits,
        &numBitsOffsetBetweenPorts,
        &numPortsInRegister);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(regAddrPtr == NULL)
    {
        /*should not happen*/
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    if(value > BIT_MASK_MAC(numBits))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    wordIndex = (portNum / numPortsInRegister);
    bitIndex  = (portNum % numPortsInRegister) * numBitsOffsetBetweenPorts;

    rc = prvCpssHwPpSetRegField(devNum,
             regAddrPtr[wordIndex],
             bitIndex ,
             numBits,
             value);

    return rc;
}

/*******************************************************************************
* prvCpssDxChHwEgfEftFieldGet
*
* DESCRIPTION:
*       Read a field from the EGF_EFT register that represent the
*           physical port.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum  - the device number
*       portNum - the port number (physical port)
*       fieldType - the field type
*
* OUTPUTS:
*       valuePtr - (pointer to)the data read from the register
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS   prvCpssDxChHwEgfEftFieldGet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN PRV_CPSS_DXCH_HW_EGF_EFT_FIELD_ENT  fieldType,
    OUT GT_U32                   *valuePtr
)
{
    GT_STATUS   rc;
    GT_U32  *regAddrPtr;/* (pointer to) register address */
    GT_U32  numBits;/*number of bits to set*/
    GT_U32  numBitsOffsetBetweenPorts;/*number of bits between 2 consecutive ports */
    GT_U32  numPortsInRegister;/*number of ports in register*/
    GT_U32  wordIndex;/*index in registers array*/
    GT_U32  bitIndex;/*index in the register*/

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(valuePtr);

    PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

    rc = egfEftFieldInfoGet(devNum,fieldType,
        &regAddrPtr,
        &numBits,
        &numBitsOffsetBetweenPorts,
        &numPortsInRegister);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(regAddrPtr == NULL)
    {
        /*should not happen*/
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
    }

    wordIndex = (portNum / numPortsInRegister);
    bitIndex  = (portNum % numPortsInRegister) * numBitsOffsetBetweenPorts;

    rc = prvCpssHwPpGetRegField(devNum,
             regAddrPtr[wordIndex],
             bitIndex ,
             numBits,
             valuePtr);

    return rc;
}

/* function to check EGF_SHT 'bmp of ports' support
    and get special behavior for each one
*/
static GT_STATUS egfShtPortsBmpTableSupportGet
(
    IN GT_U8               devNum,
    IN PRV_CPSS_DXCH_TABLE_ENT tableType,
    OUT GT_U32 *prvMcRelayPortsBmp_neededPtr,
    OUT GT_BOOL *checkPhysicalPortPtr
)
{
    GT_U32 prvMcRelayPortsBmp_needed = 0;
    GT_BOOL checkPhysicalPort   = GT_FALSE;

    switch(tableType)
    {
        case PRV_CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L2_E:
        case PRV_CPSS_DXCH_LION_TABLE_PORT_ISOLATION_L3_E:
            prvMcRelayPortsBmp_needed = 1;
            break;
        case PRV_CPSS_DXCH_LION_TABLE_TXQ_SOURCE_ID_MEMBERS_E:
            checkPhysicalPort = GT_TRUE;
            break;
        case PRV_CPSS_DXCH_LION_TABLE_TXQ_NON_TRUNK_MEMBERS_E:
        case PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E:
        case PRV_CPSS_DXCH_LION_TABLE_TXQ_DESIGNATED_PORT_E  :
            break;
        case PRV_CPSS_DXCH_TABLE_MULTICAST_E                 :
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                /* complex CPU port issues that not changed from original code */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
            break;
        case PRV_CPSS_DXCH_LION_TABLE_STG_EGRESS_E           :
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                /* the egress STP is 2 bits per port (not 1) */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(prvMcRelayPortsBmp_neededPtr)
    {
        *prvMcRelayPortsBmp_neededPtr = prvMcRelayPortsBmp_needed;
    }

    if(checkPhysicalPortPtr)
    {
        *checkPhysicalPortPtr = checkPhysicalPort;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwEgfShtPortsBmpTableEntryWrite
*
* DESCRIPTION:
*       Write a whole entry to the table. - for 'bmp of ports' - EGF_SHT tables
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - the device number
*       tableType - the specific table name
*       entryIndex   - index in the table
*       portsMembersPtr - (pointer to) the bmp of ports that will be written to
*                       the table.
*       isCpuMember_supported - indication if to use 'isCpuMember'
*       isCpuMember     - indication to add the CPU port to the BMP of ports
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwEgfShtPortsBmpTableEntryWrite
(
    IN GT_U8               devNum,
    IN PRV_CPSS_DXCH_TABLE_ENT tableType,
    IN GT_U32               tableIndex,
    IN CPSS_PORTS_BMP_STC  *portsMembersPtr,
    IN GT_BOOL              isCpuMember_supported,
    IN GT_BOOL              isCpuMember
)
{
    GT_U32      hwValueArr[EGF_SHT_MAX_PORTS_BMP_NUM_CNS];/* 16 words to support 512 ports */
    GT_STATUS   rc;         /* return value*/
    GT_U32      ii;          /* iterator */
    GT_U32      iiMax;       /* max iterator value */
    GT_U32      prvMcRelayPortsBmp_needed;/*do we need to add the relay ports */
    GT_U32      prvMcRelayPortsBmp; /* special port <12+16*n> bitmap */
    GT_U32      portGroupId;/* port group Id */
    GT_U32      wordIndexInBmp;/* word index in hwValueArr[]*/

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    rc = egfShtPortsBmpTableSupportGet(devNum,tableType,&prvMcRelayPortsBmp_needed,NULL);
    if(rc != GT_OK)
    {
        return rc;
    }


    iiMax = 4;/*support 128 ports */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no relay port issues */
        prvMcRelayPortsBmp = 0;
        iiMax = MAX(8,(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts/32));
    }
    else
    if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum))
    {
        /* port <12 + 16*n> is used for MC relay to adjacent hemisphere */
        prvMcRelayPortsBmp = PRV_MC_RELAY_PORTS_BMP_CNS;
    }
    else
    {
        prvMcRelayPortsBmp = 0;
    }

    if(prvMcRelayPortsBmp_needed == 0)
    {
        /* THE RELAY PORTS BMP NOT NEEDED*/
        prvMcRelayPortsBmp = 0;
    }


    for(ii = 0 ; ii < iiMax ; ii++)
    {
        hwValueArr[ii] =  portsMembersPtr->ports[ii] | prvMcRelayPortsBmp;
    }

    if(isCpuMember_supported == GT_TRUE)
    {
        if(BOOL2BIT_MAC(isCpuMember))
        {
            /*emulate CPU port as bit 63 */
            U32_SET_FIELD_IN_ENTRY_MAC(hwValueArr,63,1,1);
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no hemispheres issues , all port groups get the same value */
        rc = prvCpssDxChWriteTableEntry(devNum,
                                    tableType,
                                    tableIndex,
                                    &hwValueArr[0]);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        iiMax = PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum);

        /* loop on all TXQ units */
        for (ii = 0; ii < iiMax; ii++)
        {
            /* each hemisphere get it's relevant section of the ports */
            portGroupId    = ii*PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
            wordIndexInBmp = 2 * ii;/* 64 ports are in 2 words */

            rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,
                                        tableType,
                                        tableIndex,
                                        &hwValueArr[wordIndexInBmp]);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwEgfShtPortsBmpTableEntryRead
*
* DESCRIPTION:
*       Read a whole entry of the table. - for 'bmp of ports' - EGF_SHT tables
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - the device number
*       tableType - the specific table name
*       entryIndex   - index in the table
*       isCpuMember_supported - indication if to use 'isCpuMemberPtr'
* OUTPUTS:
*       portsMembersPtr - (pointer to) the bmp of ports that will be written to
*                       the table.
*       isCpuMemberPtr  - (pointer to) indication to add the CPU port to the BMP of ports
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwEgfShtPortsBmpTableEntryRead
(
    IN GT_U8               devNum,
    IN PRV_CPSS_DXCH_TABLE_ENT tableType,
    IN GT_U32               tableIndex,
    OUT CPSS_PORTS_BMP_STC  *portsMembersPtr,
    IN GT_BOOL              isCpuMember_supported,
    OUT GT_BOOL              *isCpuMemberPtr
)
{
    GT_U32      hwValueArr[EGF_SHT_MAX_PORTS_BMP_NUM_CNS];/* 16 words to support 512 ports */
    GT_STATUS   rc;         /* return value*/
    GT_U32      ii;          /* iterator */
    GT_U32      iiMax;       /* max iterator value */
    GT_U32      prvMcRelayPortsBmp_needed;/*do we need to add the relay ports */
    GT_U32      prvMcRelayPortsBmp; /* special port <12+16*n> bitmap */
    GT_U32      portGroupId;/* port group Id */
    GT_U32      wordIndexInBmp;/* word index in hwValueArr[]*/
    GT_U32      tmpValue;

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    rc = egfShtPortsBmpTableSupportGet(devNum,tableType,&prvMcRelayPortsBmp_needed,NULL);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no hemispheres issues , all port groups get the same value */
        rc = prvCpssDxChReadTableEntry(devNum,
                        tableType,
                        tableIndex,
                        &hwValueArr[0]);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        iiMax = PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_MAC(devNum);

        /* loop on all TXQ units */
        for (ii = 0; ii < iiMax; ii++)
        {
            /* each hemisphere get it's relevant section of the ports */
            portGroupId = ii*PRV_CPSS_DXCH_PORT_GROUPS_NUM_IN_HEMISPHERE_CNS;
            wordIndexInBmp = 2 * ii;/* 64 ports are in steps of 2 words */

            rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,
                            tableType,
                            tableIndex,
                            &hwValueArr[wordIndexInBmp]);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* no relay port issues */
        prvMcRelayPortsBmp = 0;
        /* support minimum 256 ports */
        iiMax = MAX(8,(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts/32));
    }
    else
    if(PRV_CPSS_DXCH_PP_HW_INFO_TXQ_UNITS_NUM_2_MAC(devNum))
    {
        /* port <12 + 16*n> is used for MC relay to adjacent hemisphere */
        prvMcRelayPortsBmp = PRV_MC_RELAY_PORTS_BMP_CNS;
        iiMax = 4;/*support 128 ports */
    }
    else /* single hemisphere */
    {
        prvMcRelayPortsBmp = 0;
        iiMax = 2;/* have only 64 ports to use --
                    also remove the issue of 'parity bit' in word 2 !!! */
    }

    if(prvMcRelayPortsBmp_needed == 0)
    {
        /* THE RELAY PORTS BMP NOT NEEDED*/
        prvMcRelayPortsBmp = 0;
    }

    for(ii = 0 ; ii < iiMax ; ii++)
    {
        portsMembersPtr->ports[ii] = hwValueArr[ii]  & (~prvMcRelayPortsBmp);
    }

    for(/*continue*/ ; ii < CPSS_MAX_PORTS_BMP_NUM_CNS ; ii++)
    {
        /* reset the other words */
        portsMembersPtr->ports[ii] = 0;
    }

    if(isCpuMember_supported)
    {
        /* get the CPU port as bit in BMP */
        U32_GET_FIELD_IN_ENTRY_MAC(portsMembersPtr->ports,63,1,tmpValue);
        *isCpuMemberPtr = BIT2BOOL_MAC(tmpValue);

        /* reset the CPU port as bit in BMP */
        U32_SET_FIELD_IN_ENTRY_MAC(portsMembersPtr->ports,63,1,0);
    }

    return GT_OK;
}


/*******************************************************************************
* prvCpssDxChHwEgfShtPortsBmpTableEntrySetPort
*
* DESCRIPTION:
*       set (enable/disable) single port (bit index) in entry to the table. - for 'bmp of ports' - EGF_SHT tables
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - the device number
*       tableType - the specific table name
*       entryIndex   - index in the table
*       portNum - the port number
*       enable - enable/disable the port in the entry
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwEgfShtPortsBmpTableEntrySetPort
(
    IN GT_U8               devNum,
    IN PRV_CPSS_DXCH_TABLE_ENT tableType,
    IN GT_U32               tableIndex,
    IN GT_U32               portNum,
    IN GT_BOOL              enable
)
{
    GT_STATUS   rc;         /* return value*/
    GT_U32      portGroupId;/* port group Id */
    GT_U32      data;
    GT_BOOL     checkPhysicalPort;/*indication to check physical port / cpu port */

    if(0 == PRV_CPSS_DXCH_PP_HW_INFO_TXQ_REV_1_OR_ABOVE_MAC(devNum))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    data = BOOL2BIT_MAC(enable);

    rc = egfShtPortsBmpTableSupportGet(devNum,tableType,NULL,&checkPhysicalPort);
    if(rc != GT_OK)
    {
        return rc;
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        PRV_CPSS_DXCH_PHY_PORT_NUM_CHECK_MAC(devNum,portNum);

        /* all port groups get the same value */
        portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    }
    else
    {
        if(checkPhysicalPort == GT_TRUE)
        {
            PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum,portNum);
        }

        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum,portNum);
        portNum = PRV_CPSS_DXCH_GLOBAL_TO_HEM_LOCAL_PORT(devNum,portNum);

        /* check port */
        if(portNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_PHY_PORT_MAC(devNum))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    rc = prvCpssDxChPortGroupWriteTableEntryField(devNum, portGroupId,
                                    tableType,
                                    tableIndex,
                                    PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                    portNum,
                                    1,
                                    data);

    return rc;
}


/*******************************************************************************
* prvCpssDxChHwHaTunnelStartArpNatTableEntryWrite
*
* DESCRIPTION:
*       Write a whole entry to the table. HA memory of 'TunnelStart/ARP/NAT(for NAT capable devices)'
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond.
*
* INPUTS:
*       devNum  - the device number
*       portGroupId - the port group Id , to support multi-port-group devices that need to access
*                specific port group
*       entryType - entry type (arp/TS/TS_double)
*       tableIndex   - index in the table.
*                       the ratio is 4 ARP per 1 TS ('regular')
*                       so for 1K TS the indexes are:
*                           for ARP : (APPLICABLE RANGES: 0,1,2,3,4..(4K-1))
*                           for TS  : (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                           for TS_double : (APPLICABLE RANGES: 0,2,4,6,8..(1K-2))
*                           for NAT: (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                       NOTE: the 'double' TS must use only 'even' indexes (0,2,4,6,...)
*
*       entryValuePtr - (pointer to) the data that will be written to the table
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwHaTunnelStartArpNatTableEntryWrite
(
    IN GT_U8                                        devNum,
    IN GT_U32                                       portGroupId,
    IN PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ENT   entryType,
    IN GT_U32                                       tableIndex,
    IN GT_U32                                       *entryValuePtr
)
{
    GT_STATUS   rc;
    GT_U32      readMemoryArr[12];/* 12 words supports the 384 bits for 'double' TS */
    PRV_CPSS_DXCH_TABLE_ENT  tableType = PRV_CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E;
    GT_U32      readBeforeWrite;/* indication if need to read before the write */
    GT_U32      memoryLineIndex;/* index into the actual memory*/
    GT_U32      *writeMemoryPtr;/* pointer to the actual array that hold data to write */
    GT_U32      actualStartBitInMemoryLine;/* the bit index of the data in the memory line */
    GT_U32      numberOfBitsInEntry;/*number of bits in the entry*/
    GT_U32      currentNumBitsToUpdate;/*current number of bits to update */
    GT_U32      currentStartBitToUpdate;/*current start bit to update */
    GT_U32      wordIndex;/*index in entryValuePtr*/

    switch(entryType)
    {
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ARP_E:
            readBeforeWrite = 1;/* not full memory line*/
            numberOfBitsInEntry = 48;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 3;/* /8 */
                actualStartBitInMemoryLine = (tableIndex & 7) * numberOfBitsInEntry;
            }
            else
            {
                memoryLineIndex = tableIndex >> 2;/* /4 */
                actualStartBitInMemoryLine = (tableIndex & 3) * numberOfBitsInEntry;
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_REGULAR_E:
            numberOfBitsInEntry = 192;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 1;/* /2 */
                readBeforeWrite = 1;/* not full memory line*/
                actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            }
            else
            {
                memoryLineIndex = tableIndex;
                readBeforeWrite = 0;/* full memory line */
                actualStartBitInMemoryLine = 0;/*start at bit 0*/
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_DOUBLE_E:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }

            if(tableIndex & 1)
            {
                /* the 'double TS' must start only at 'even' entries */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            numberOfBitsInEntry = 384;

            /* the 'double' TS index was given by the application with the same
               indexing method as 'regular' TS*/

            memoryLineIndex = tableIndex >> 1;/* /2 */
            readBeforeWrite = 0;/* full memory line */
            actualStartBitInMemoryLine = 0;/*start at bit 0*/
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_NAT_E:
            numberOfBitsInEntry = 192;
            memoryLineIndex = tableIndex >> 1;/* /2 */
            readBeforeWrite = 1;/* not full memory line*/
            actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(readBeforeWrite)
    {
        /* read the entry */
        rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,tableType,memoryLineIndex,readMemoryArr);
        if(rc != GT_OK)
        {
            return rc;
        }

        currentNumBitsToUpdate = numberOfBitsInEntry;
        currentStartBitToUpdate = actualStartBitInMemoryLine;

        for(currentNumBitsToUpdate = numberOfBitsInEntry ,
            currentStartBitToUpdate = actualStartBitInMemoryLine,
            wordIndex = 0;

            currentNumBitsToUpdate > 32 ;

            currentNumBitsToUpdate -= 32,
            currentStartBitToUpdate += 32,
            wordIndex++)
        {
            /* update the next word from the entry */
            U32_SET_FIELD_IN_ENTRY_MAC(readMemoryArr,
                currentStartBitToUpdate,
                32,
                entryValuePtr[wordIndex]);
        }

        /* update the last word from the entry */
        U32_SET_FIELD_IN_ENTRY_MAC(readMemoryArr,
                currentStartBitToUpdate,
                currentNumBitsToUpdate,
                entryValuePtr[wordIndex]);


        writeMemoryPtr = readMemoryArr;
    }
    else
    {
        writeMemoryPtr = entryValuePtr;
    }

    /* write the entry */
    rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,tableType,memoryLineIndex,writeMemoryPtr);

    return rc;
}


/*******************************************************************************
* prvCpssDxChHwHaTunnelStartArpNatTableEntryRead
*
* DESCRIPTION:
*       Read a whole entry from the table. HA memory of 'TunnelStart/ARP/NAT(for NAT capable devices)'
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond.
*
* INPUTS:
*       devNum  - the device number
*       portGroupId - the port group Id , to support multi-port-group devices that need to access
*                specific port group
*       entryType - entry type (arp/TS/TS_double)
*       tableIndex   - index in the table.
*                       the ratio is 4 ARP per 1 TS ('regular')
*                       so for 1K TS the indexes are:
*                           for ARP : (APPLICABLE RANGES: 0,1,2,3,4..(4K-1))
*                           for TS  : (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                           for TS_double : (APPLICABLE RANGES: 0,2,4,6,8..(1K-2))
*                           for NAT: (APPLICABLE RANGES: 0,1,2,3,4..(1K-1))
*                       NOTE: the 'double' TS must use only 'even' indexes (0,2,4,6,...)
*
* OUTPUTS:
*       entryValuePtr - (pointer to) the data that will be read from the table
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on failure.
*       GT_OUT_OF_RANGE          - parameter not in valid range
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwHaTunnelStartArpNatTableEntryRead
(
    IN GT_U8                                        devNum,
    IN GT_U32                                       portGroupId,
    IN PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ENT   entryType,
    IN GT_U32                                       tableIndex,
    OUT GT_U32                                      *entryValuePtr
)
{
    GT_STATUS   rc;
    GT_U32      readMemoryArr[12];/* 12 words supports the 384 bits for 'double' TS */
    PRV_CPSS_DXCH_TABLE_ENT  tableType = PRV_CPSS_DXCH2_TABLE_TUNNEL_START_CONFIG_E;
    GT_U32      memoryLineIndex;/* index into the actual memory*/
    GT_U32      actualStartBitInMemoryLine;/* the bit index of the data in the memory line */
    GT_U32      numberOfBitsInEntry;/*number of bits in the entry*/
    GT_U32      currentNumBitsToUpdate;/*current number of bits to update */
    GT_U32      currentStartBitToUpdate;/*current start bit to update */
    GT_U32      wordIndex;/*index in entryValuePtr*/

    switch(entryType)
    {
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_ARP_E:
            numberOfBitsInEntry = 48;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 3;/* /8 */
                actualStartBitInMemoryLine = (tableIndex & 7) * numberOfBitsInEntry;
            }
            else
            {
                memoryLineIndex = tableIndex >> 2;/* /4 */
                actualStartBitInMemoryLine = (tableIndex & 3) * numberOfBitsInEntry;
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_REGULAR_E:
            numberOfBitsInEntry = 192;

            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                memoryLineIndex = tableIndex >> 1;/* /2 */
                actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            }
            else
            {
                memoryLineIndex = tableIndex;
                actualStartBitInMemoryLine = 0;/*start at bit 0*/
            }
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_TUNNEL_START_DOUBLE_E:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
            }

            if(tableIndex & 1)
            {
                /* the 'double TS' must start only at 'even' entries */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }

            numberOfBitsInEntry = 384;

            /* the 'double' TS index was given by the application with the same
               indexing method as 'regular' TS*/

            memoryLineIndex = tableIndex >> 1;/* /2 */
            actualStartBitInMemoryLine = 0;/*start at bit 0*/
            break;
        case PRV_CPSS_DXCH_HA_TS_ARP_NAT_ENTRY_TYPE_NAT_E:
            numberOfBitsInEntry = 192;
            memoryLineIndex = tableIndex >> 1;/* /2 */
            actualStartBitInMemoryLine = (tableIndex & 1) * numberOfBitsInEntry;/*start at bit 0 or 192 */
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* read the entry */
    rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,tableType,memoryLineIndex,readMemoryArr);
    if(rc != GT_OK)
    {
        return rc;
    }

    currentNumBitsToUpdate = numberOfBitsInEntry;
    currentStartBitToUpdate = actualStartBitInMemoryLine;

    for(    currentNumBitsToUpdate = numberOfBitsInEntry ,
            currentStartBitToUpdate = actualStartBitInMemoryLine,
            wordIndex = 0;

        currentNumBitsToUpdate > 32 ;

            currentNumBitsToUpdate -= 32,
            currentStartBitToUpdate += 32,
            wordIndex++)
    {
        /* get the next word for the entry */
        U32_GET_FIELD_IN_ENTRY_MAC(readMemoryArr,
            currentStartBitToUpdate,
            32,
            entryValuePtr[wordIndex]);
    }

    /* get the last word for the entry */
    U32_GET_FIELD_IN_ENTRY_MAC(readMemoryArr,
            currentStartBitToUpdate,
            currentNumBitsToUpdate,
            entryValuePtr[wordIndex]);


    return GT_OK;
}

/*******************************************************************************
* internal_cpssDxChHwInitLion2GeBackwardCompatibility
*
* DESCRIPTION:
*       Init parameters of serdes initialization for 1.25G frequncy accordingly to
*       HWS version 43. Proposed for Lion2 B0 only.
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       None
*
* OUTPUTS:
*       None
*
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Must be call before cpssDxChHwPpPhase1Init.
*
*******************************************************************************/
static GT_VOID internal_cpssDxChHwInitLion2GeBackwardCompatibility
(
    GT_VOID
)
{
    /* this function supposed to run too early to check device validity */
    hwsChange1GSpeedCfgV43();

    return;
}

/*******************************************************************************
* cpssDxChHwInitLion2GeBackwardCompatibility
*
* DESCRIPTION:
*       Init parameters of serdes initialization for 1.25G frequncy accordingly to
*       HWS version 43. Proposed for Lion2 B0 only.
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       None
*
* OUTPUTS:
*       None
*
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad device
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Must be call before cpssDxChHwPpPhase1Init.
*
*******************************************************************************/
GT_VOID cpssDxChHwInitLion2GeBackwardCompatibility
(
    GT_VOID
)
{
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwInitLion2GeBackwardCompatibility);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId));

    internal_cpssDxChHwInitLion2GeBackwardCompatibility();

    CPSS_API_UNLOCK_MAC(0,0);
}

/*******************************************************************************
* internal_cpssDxChHwPpAddressDecodeWindowConfigSet
*
* DESCRIPTION:
*       This function perfroms the address decoding window configuration.
*       If a window is enabled and an address driven by one the PP's units hit the window,
*       the window's configuration applied on this address access.
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum             - The PP's device number.
*       windowNumber   - window number (APPLICABLE RANGES: 0..5).
*       windowConfigPtr  - window's configuration.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success, or
*       GT_FAIL otherwise.
*       GT_HW_ERROR             - on hardware error
*       GT_BAD_PARAM            - wrong devNum, window size or window base address
*       GT_NOT_SUPPORTED    - if this feature not supported by the device.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpAddressDecodeWindowConfigSet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    IN  CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
   GT_STATUS rc;        /* return code */
   GT_U32    regAddr;   /* register address */
   GT_U32    regData;   /* register data */
   GT_U32    offset;    /* data offset within register */

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_LION_E |
        CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);
   CPSS_NULL_PTR_CHECK_MAC(windowConfigPtr);

   if(windowNumber>5)
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
   }

   if(windowConfigPtr->enableWindow == GT_TRUE)
   {
     /* Validate window size is a power of 2 */
     if((windowConfigPtr->windowSize ==0) || (windowConfigPtr->windowSize > _64K) || /* can't be 0 or above 64K */
        (((windowConfigPtr->windowSize-1) & (windowConfigPtr->windowSize)) !=0 )) /* Power of 2 - only one bit set */
     {
       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

     /* Validate window base address is in resolution of window size.  */
     if(windowConfigPtr->baseAddress % windowConfigPtr->windowSize)
     {
       CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

     /* Disable window before changing settings. */
     if( CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
         offset = 0;
     }
     else /* xCat & xCat2 */
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
         offset = windowNumber;
     }

     rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, offset, 1, 1);
     if (rc != GT_OK)
     {
         return rc;
     }

     /* Target Unit PCI, Memory access */
     regData = 0x804;
     if( CPSS_PP_FAMILY_DXCH_XCAT3_E != PRV_CPSS_PP_MAC(devNum)->devFamily )
     {
         regData |= 0xE000;
     }

     regData |= windowConfigPtr->baseAddress&0xFFFF0000; /* Bits 0-15 are 0 */

     /* Set window attribute */
     regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddress[windowNumber];
     rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, regData);
     if (rc != GT_OK)
     {
       return rc;
     }

     /* Set window size */
     /* This field must be programmed from LSB to MSB as sequence of 1s followed by sequence of 0s.
             The size of the window is (windowConfigPtr->windowSiz + 1) * 64K.
             e.g. configure value of 0x003F specifies 64x64k = 4 MB*/
     regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.windowSize[windowNumber];
     rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, (windowConfigPtr->windowSize-1)<<16);
     if (rc != GT_OK)
     {
       return rc;
     }

     /* Set high address remap value. */
     if(windowNumber < 4)
     {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.highAddressRemap[windowNumber];
       rc = prvCpssDrvHwPpWriteRegister(devNum, regAddr, windowConfigPtr->remapAddress);
       if (rc != GT_OK)
       {
         return rc;
       }
     }

     /* Set window Access Protect mode - full access read and write */
     if( CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
         offset = 1;
     }
     else /* xCat & xCat2 */
     {
         regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.accessProtect;
         offset = 2*windowNumber;
     }

     rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, offset, 2, 0x3);
     if (rc != GT_OK)
     {
       return rc;
     }
   }

   /* Window enable only after validating and setting all other configuration. */
   regData = (windowConfigPtr->enableWindow)? 0:1;
   if( CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
       offset = 0;
   }
   else /* xCat & xCat2 */
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
       offset = windowNumber;
   }

   rc = prvCpssDrvHwPpSetRegField(devNum, regAddr, offset, 1, regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   return GT_OK;
}

/*******************************************************************************
* cpssDxChHwPpAddressDecodeWindowConfigSet
*
* DESCRIPTION:
*       This function perfroms the address decoding window configuration.
*       If a window is enabled and an address driven by one the PP's units hit the window,
*       the window's configuration applied on this address access.
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum             - The PP's device number.
*       windowNumber   - window number (APPLICABLE RANGES: 0..5).
*       windowConfigPtr  - window's configuration.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success, or
*       GT_FAIL otherwise.
*       GT_HW_ERROR             - on hardware error
*       GT_BAD_PARAM            - wrong devNum, window size or window base address
*       GT_NOT_SUPPORTED    - if this feature not supported by the device.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpAddressDecodeWindowConfigSet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    IN  CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpAddressDecodeWindowConfigSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, windowNumber, windowConfigPtr));

    rc = internal_cpssDxChHwPpAddressDecodeWindowConfigSet(devNum, windowNumber, windowConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, windowNumber, windowConfigPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChHwPpAddressDecodeWindowConfigGet
*
* DESCRIPTION:
*       This function returns the address decoding window configuration.
*       If a window is enabled and an address driven by one the PP's units hit the window,
*       the window's configuration applied on this address access.
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum             - The PP's device number.
*       windowNumber   - window number (APPLICABLE RANGES: 0..5).
*
* OUTPUTS:
*       windowConfigPtr - window's configuration.
*
* RETURNS:
*       GT_OK on success, or
*       GT_FAIL otherwise.
*       GT_HW_ERROR             - on hardware error
*       GT_BAD_PARAM            - wrong devNum, window size or window base address
*       GT_BAD_STATE           - get illegal value from HW.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpAddressDecodeWindowConfigGet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    OUT CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
   GT_STATUS rc;            /* return code */
   GT_U32    regAddr;       /* register address */
   GT_U32    regData;       /* register data */
   GT_U32    offset;        /* data offset within register */
   GT_U32    attributes;    /* unit attributes*/

   PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
   PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
       CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_LION_E |
       CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);
   CPSS_NULL_PTR_CHECK_MAC(windowConfigPtr);

   if(windowNumber>5)
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
   }

   /* Window enable */
   if( CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
       offset = 0;
   }
   else /* xCat & xCat2 */
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[0];
       offset = windowNumber;
   }

   rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, offset, 1, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   windowConfigPtr->enableWindow = (regData == 0) ? GT_TRUE : GT_FALSE;


   /* Get window attributes, base address and target id */
   regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddress[windowNumber];
   rc = prvCpssDrvHwPpReadRegister(devNum, regAddr, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   attributes = regData & 0xFFFF;
   if((windowConfigPtr->enableWindow == GT_TRUE) &&
      ((CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily && attributes != 0x804) ||
       (CPSS_PP_FAMILY_DXCH_XCAT3_E != PRV_CPSS_PP_MAC(devNum)->devFamily && attributes != 0xE804)))
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
   }

   windowConfigPtr->baseAddress = regData & 0xFFFF0000; /* get bits 16-31. */


   /* Get window size */
   /* This field must be programmed from LSB to MSB as sequence of 1s followed by sequence of 0s.
           The size of the window is (windowConfigPtr->windowSiz + 1) * 64K.
           e.g. configure value of 0x003F specifies 64x64k = 4 MB*/
   regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.windowSize[windowNumber];
   rc = prvCpssDrvHwPpReadRegister(devNum, regAddr, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }
   windowConfigPtr->windowSize = (regData >> 16) + 1;


   /* Get high address remap value. */
   if(windowNumber < 4)
   {
     regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.highAddressRemap[windowNumber];
     rc = prvCpssDrvHwPpReadRegister(devNum, regAddr, &(windowConfigPtr->remapAddress));
     if (rc != GT_OK)
     {
       return rc;
     }
   }

   /* Get window Access Protect mode */
   if( CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.baseAddressEnable[windowNumber];
       offset = 1;
   }
   else /* xCat & xCat2 */
   {
       regAddr = PRV_CPSS_DXCH_PP_MAC(devNum)->regsAddr.globalRegs.addressDecoding.accessProtect;
       offset = 2*windowNumber;
   }

   rc = prvCpssDrvHwPpGetRegField(devNum, regAddr, offset, 2, &regData);
   if (rc != GT_OK)
   {
       return rc;
   }

   if((windowConfigPtr->enableWindow == GT_TRUE) && (regData != 3))
   {
     CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
   }

   return GT_OK;
}

/*******************************************************************************
* cpssDxChHwPpAddressDecodeWindowConfigGet
*
* DESCRIPTION:
*       This function returns the address decoding window configuration.
*       If a window is enabled and an address driven by one the PP's units hit the window,
*       the window's configuration applied on this address access.
*
* APPLICABLE DEVICES:
*        xCat; xCat3; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum             - The PP's device number.
*       windowNumber   - window number (APPLICABLE RANGES: 0..5).
*
* OUTPUTS:
*       windowConfigPtr - window's configuration.
*
* RETURNS:
*       GT_OK on success, or
*       GT_FAIL otherwise.
*       GT_HW_ERROR             - on hardware error
*       GT_BAD_PARAM            - wrong devNum, window size or window base address
*       GT_BAD_STATE           - get illegal value from HW.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChHwPpAddressDecodeWindowConfigGet
(
    IN  GT_U8                                     devNum,
    IN  GT_U32                                    windowNumber,
    OUT CPSS_DXCH_ADDR_DECODE_WINDOW_CONFIG_STC  *windowConfigPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChHwPpAddressDecodeWindowConfigGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, windowNumber, windowConfigPtr));

    rc = internal_cpssDxChHwPpAddressDecodeWindowConfigGet(devNum, windowNumber, windowConfigPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, windowNumber, windowConfigPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


#ifdef DEBUG_OPENED
/*******************************************************************************
* prvCpssDxChPrintFineTuningDebugInfo
*
* DESCRIPTION:
*       DxCh prints information about Packet processor , fine tuning values
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - PP's device number .
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK           - on success
*       GT_BAD_PARAM    - invalid devNum
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChPrintFineTuningDebugInfo
(
    IN GT_U8                    devNum
)
{
    PRV_CPSS_DXCH_PP_CONFIG_FINE_TUNING_STC *fineTuningPtr;
    PRV_CPSS_DXCH_PP_HW_INFO_STC            *ppHwInfoPtr;
    PRV_CPSS_GEN_PP_CONFIG_STC *devInfoPtr = PRV_CPSS_PP_MAC(devNum);
    PRV_CPSS_DXCH_PP_CONFIG_STC *dxChDevInfoPtr = PRV_CPSS_DXCH_PP_MAC(devNum);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    fineTuningPtr = &dxChDevInfoPtr->fineTuning;
    ppHwInfoPtr = &dxChDevInfoPtr->hwInfo;

    DUMP_PRINT_MAC((" devNum = [%d] \n",devInfoPtr->devNum));
    DUMP_PRINT_MAC((" devType = [0x%8.8x] \n",devInfoPtr->devType));
    DUMP_PRINT_MAC((" revision = [%d] \n",devInfoPtr->revision));
    DUMP_PRINT_MAC((" devFamily = [%s] \n",
        devInfoPtr->devFamily == CPSS_PP_FAMILY_CHEETAH_E   ? " CPSS_PP_FAMILY_CHEETAH_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_CHEETAH2_E  ? " CPSS_PP_FAMILY_CHEETAH2_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_CHEETAH3_E  ? " CPSS_PP_FAMILY_CHEETAH3_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT_E  ? " CPSS_PP_FAMILY_DXCH_XCAT_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT3_E  ? " CPSS_PP_FAMILY_DXCH_XCAT3_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION_E  ? " CPSS_PP_FAMILY_DXCH_LION_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_XCAT2_E  ? " CPSS_PP_FAMILY_DXCH_XCAT2_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_LION2_E  ? " CPSS_PP_FAMILY_DXCH_LION2_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT2_E  ? " CPSS_PP_FAMILY_DXCH_BOBCAT2_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_BOBCAT3_E  ? " CPSS_PP_FAMILY_DXCH_BOBCAT3_E ":
        devInfoPtr->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E  ? " CPSS_PP_FAMILY_DXCH_ALDRIN_E ":
        " unknown "
    ));

    /************************/
    /* fine tuning - tables */
    /************************/

        /* bridge section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.fdb                     )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.vidxNum                 )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.stgNum                  )
        ));
        /* router and TTI TCAM section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.router )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.tunnelTerm )
        ));
        /* tunnel section*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.tunnelStart )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.routerArp )
        ));
        /* ip section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.routerNextHop           )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.ecmpQos                 )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.mllPairs                )
        ));
        /* PCL section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.policyTcamRaws          )
        ));
        /* CNC section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.cncBlocks               )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.cncBlockNumEntries      )
        ));
        /* Policer Section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.policersNum             )
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.egressPolicersNum       )
        ));
        /* trunk Section */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.trunksNum               )
        ));
        /* Transmit Descriptors */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.transmitDescr           )
        ));
        /* Buffer Memory */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.bufferMemory            )
        ));
        /*  Transmit Queues */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.txQueuesNum             )
        ));
        /*  LPM RAM */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.lpmRam                  )
        ));

    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->tableSize.bpePointToPointEChannels)
        ));

    /*********************************/
    /* fine tuning - feature support */
    /*********************************/

        /* TR101 Feature support */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.tr101Supported)
        ));
        /* VLAN translation support */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.vlanTranslationSupported)
        ));
        /* Policer Ingress second stage support flag */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.iplrSecondStageSupported)
        ));
        /* trunk CRC hash support flag */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.trunkCrcHashSupported)
        ));

        /* TM support flag */
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(fineTuningPtr->featureInfo.TmSupported)
        ));


    /***************/
    /* other info  */
    /***************/

        /*policer 0 - Memory size per stage*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(dxChDevInfoPtr->policer.memSize[0])
        ));
        /*policer 1 - Memory size per stage*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(dxChDevInfoPtr->policer.memSize[1])
        ));
        /*policer 2 - Memory size per stage*/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(dxChDevInfoPtr->policer.memSize[2])
        ));


    /************/
    /* HW info  */
    /************/
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->l2i.supportIngressRateLimiter)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->cnc.cncBlocks)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->cnc.cncBlockNumEntries)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->txq.revision)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->ha.cpuPortBitIndex)
        ));
    DUMP_PRINT_MAC((" [%s] = [%d] \n",
        NAME_AND_VALUE_MAC(ppHwInfoPtr->mg.metalFix)
        ));
    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChPrintErrataNamesDebugInfo
*
* DESCRIPTION:
*       DxCh prints information about which errata WA implemented for the device
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - PP's device number .
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK           - on success
*       GT_BAD_PARAM    - invalid devNum
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS prvCpssDxChPrintErrataNamesDebugInfo
(
    IN GT_U8                    devNum
)
{
    GT_U32  ii;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    DUMP_PRINT_MAC(("cpssDxChPrintErrataNamesInfo : the errata,RM WA for the device \n"));

    for(ii = 0 ; ii < PRV_CPSS_DXCH_ERRATA_MAX_NUM_E; ii++)
    {
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,ii))
        {
            if(errataNames[ii] == NULL)
            {
                DUMP_PRINT_MAC((" index %d is unknown \n" ,ii));
            }
            else
            {
                DUMP_PRINT_MAC((" %s \n" , errataNames[ii]));
            }
        }
    }

    return GT_OK;
}

#endif /*DEBUG_OPENED*/

/*******************************************************************************
* prvCpssDxChHwPpSdmaCpuPortReservedIndexGet
*
* DESCRIPTION:
*       get the index that is reserved for the CPU port for 'link status' filtering.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum             - The PP's device number.
*
* OUTPUTS:
*       indexPtr - pointer to the index
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwPpSdmaCpuPortReservedIndexGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *indexPtr
)
{
    if(!PRV_CPSS_SIP_5_20_CHECK_MAC(devNum))
    {
        /* use the 'last' physical port as the SDMA CPU port */
        *indexPtr = PRV_CPSS_DXCH_MAX_PHY_PORT_NUMBER_MAC(devNum) - 1;
    }
    else
    {
        /* there is no mapping in the EGF from 'virtual port' to 'physical port' */
        *indexPtr = CPSS_CPU_PORT_NUM_CNS;/*63*/
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwPpGopGlobalMacPortNumToLocalMacPortInPipeConvert
*
* DESCRIPTION:
*       convert the global GOP MAC port number in device to local GOP MAC port
*       in the pipe , and the pipeId.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum             - The PP's device number.
*       globalMacPortNum   - the MAC global port number.
* OUTPUTS:
*       pipeIndexPtr - (pointer to) the pipe Index of the MAC port
*       localMacPortNumPtr - (pointer to) the MAC local port number
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwPpGopGlobalMacPortNumToLocalMacPortInPipeConvert
(
    IN  GT_U8   devNum,
    IN  GT_U32  globalMacPortNum,
    OUT GT_U32  *pipeIndexPtr,
    OUT GT_U32  *localMacPortNumPtr
)
{
    GT_U32  pipeIndex;
    GT_U32 firstPort;
    GT_U32 numOfPort;

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiPipe.numOfPipes < 2)
    {
        /* no convert needed */
        if(pipeIndexPtr)
        {
            *pipeIndexPtr = 0;
        }
        if(localMacPortNumPtr)
        {
            *localMacPortNumPtr = globalMacPortNum;
        }
        return GT_OK;
    }

    /*
        NOTE: for bobcat3 :
        global MAC ports 0..35  are 'pipe 0' local ports 0..35
        global MAC ports 36..71 are 'pipe 1' local ports 0..35

        currently there is NO representation of :
            'pipe 0' local ports 36
            'pipe 1' local ports 36
    */


    pipeIndex = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiPipe.numOfPipes - 1;
    do
    {
        firstPort = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiPipe.pipeInfo[pipeIndex].gop_info.gopFirstPort;
        numOfPort = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiPipe.pipeInfo[pipeIndex].gop_info.gopNumOfPorts;

        /* calculate pipe index */
        if((globalMacPortNum >= firstPort) &&
           ((globalMacPortNum - firstPort) < numOfPort))
        {
            /* the port is in this pipe */
            break;
        }

    }while(--pipeIndex);

    firstPort = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiPipe.pipeInfo[pipeIndex].gop_info.gopFirstPort;
    numOfPort = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiPipe.pipeInfo[pipeIndex].gop_info.gopNumOfPorts;

    if(pipeIndex == 0 &&
        ((globalMacPortNum < firstPort) ||
         ((globalMacPortNum - firstPort) >= numOfPort)))
    {
        /* ERROR in the logic (or missing logic) */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* portIndex is local port number in the pipe */
    if(localMacPortNumPtr)
    {
        *localMacPortNumPtr = globalMacPortNum - firstPort;
    }
    if(pipeIndexPtr)
    {
        *pipeIndexPtr = pipeIndex;
    }

    return GT_OK;
}


/*******************************************************************************
* prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert
*
* DESCRIPTION:
*       convert the global DMA number in device to local DMA number
*       in the DataPath (DP), and the Data Path Id.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum              - The PP's device number.
*       globalDmaNum        - the DMA global number.
* OUTPUTS:
*       dpIndexPtr          - (pointer to) the Data Path (DP) Index
*       localDmaNumPtr      - (pointer to) the DMA local number
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwPpDmaGlobalNumToLocalNumInDpConvert
(
    IN  GT_U8   devNum,
    IN  GT_U32  globalDmaNum,
    OUT GT_U32  *dpIndexPtr,
    OUT GT_U32  *localDmaNumPtr
)
{
    GT_U32 dpIndex;   /* Data Path index */
    GT_U32 firstDma;  /* first global DMA in specific DP */
    GT_U32 numOfDmas; /* number of global DMA in specific DP */
    const GT_U32 *localDmaMapArr; /* local DMAs in specific DP, NULL in cases 1:1 mapping */

    if(! PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.supportRelativePortNum)
    {
        /* no convert needed */
        if(dpIndexPtr)
        {
            *dpIndexPtr = 0;
        }
        if(localDmaNumPtr)
        {
            *localDmaNumPtr = globalDmaNum;
        }
        return GT_OK;
    }

    /*
        NOTE: for bobcat3 :
        global DMA IDs 0..11   are 'DP 0' local dma 0..11
        global DMA IDs 12..23  are 'DP 1' local dma 0..11
        global DMA IDs 24..35  are 'DP 2' local dma 0..11
        global DMA IDs 36..47  are 'DP 3' local dma 0..11
        global DMA IDs 48..59  are 'DP 4' local dma 0..11
        global DMA IDs 60..71  are 'DP 5' local dma 0..11
        global DMA ID  72      is  'DP 0' local dma 12

        currently there is NO representation of :
            'DP 1' local dma 12
            'DP 2' local dma 12
            'DP 3' local dma 12
            'DP 4' local dma 12
            'DP 5' local dma 12

        Aldrin has 3 DPs with local DMAs:
        DP0 - 56..59, 64..71  -> mapped to global ports 0..11
        DP1 - 56..59, 64..71  -> mapped to global ports 12..23
        DP2 - 56..59, 64..67, 62, 72 -> mapped to global ports 24..32, 72 (CPU)
    */

    if(PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.cpuPortInfo.dmaNumber == globalDmaNum)
    {
        /* CPU SDMA port is DP 2 in Aldrin */
        dpIndex = (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)? 2 : 0;

        /* portIndex is local port number in the pipe */
        if(localDmaNumPtr)
        {
            *localDmaNumPtr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].cpuPortDmaNum;
        }

        if(dpIndexPtr)
        {
            *dpIndexPtr = dpIndex;
        }
        return GT_OK;
    }

    dpIndex = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.maxDp - 1;

    do
    {
        firstDma = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathFirstPort;
        numOfDmas = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts;
        /* calculate pipe index */
        if((globalDmaNum >= firstDma) &&
           ((globalDmaNum - firstDma) < numOfDmas))
        {
            /* the port is in this pipe */
            break;
        }

        if(dpIndex == 0)
        {
            /* ERROR in the logic (or missing logic) */
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }

    }while(--dpIndex);

    firstDma = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathFirstPort;
    numOfDmas = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts;
    localDmaMapArr = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].localDmaMapArr;

    if(dpIndex == 0 &&
        ((globalDmaNum < firstDma) ||
         ((globalDmaNum - firstDma) >= numOfDmas)))
    {
        /* ERROR in the logic (or missing logic) */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* portIndex is local port number in the pipe */
    if(localDmaNumPtr)
    {
        if (localDmaMapArr)
        {
            *localDmaNumPtr = localDmaMapArr[globalDmaNum - firstDma];
        }
        else
        {
            *localDmaNumPtr = globalDmaNum - firstDma;
        }
    }

    if(dpIndexPtr)
    {
        *dpIndexPtr = dpIndex;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert
*
* DESCRIPTION:
*       convert the local DMA number in the DataPath (DP), to global DMA number
*       in the device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum              - The PP's device number.
*       dpIndex             - the Data Path (DP) Index
*       localDmaNum         - the DMA local number
* OUTPUTS:
*       globalDmaNumPtr     - (pointer to) the DMA global number.
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS prvCpssDxChHwPpDmaLocalNumInDpToGlobalNumConvert
(
    IN  GT_U8   devNum,
    IN  GT_U32  dpIndex,
    IN  GT_U32  localDmaNum,
    OUT GT_U32  *globalDmaNumPtr
)
{
    GT_U32 firstDma;
    GT_U32 numOfDmas;

    if(! PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.supportRelativePortNum)
    {
        /* no convert needed */
        *globalDmaNumPtr = localDmaNum;
        return GT_OK;
    }

    if (PRV_CPSS_PP_MAC(devNum)->devFamily == CPSS_PP_FAMILY_DXCH_ALDRIN_E)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_IMPLEMENTED, LOG_ERROR_NO_MSG);
    }
    else
    {
        firstDma = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathFirstPort;
        numOfDmas = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.multiDataPath.info[dpIndex].dataPathNumOfPorts;

        if(localDmaNum >= numOfDmas)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        *globalDmaNumPtr = firstDma + localDmaNum;
    }

    return GT_OK;
}
/*******************************************************************************
* prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit
*
* DESCRIPTION:
*       init the CPU code table mapping to CPU physical port that represent the CPU code.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum              - The PP's device number.
*       dpIndex             - the Data Path (DP) Index
*       localDmaNum         - the DMA local number
* OUTPUTS:
*       globalDmaNumPtr     - (pointer to) the DMA global number.
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwEgfEftCpuCodeMapToCpuPortInit
(
    IN  GT_U8   devNum
)
{
    GT_STATUS rc;
    GT_U32  ii;
    GT_U32  numPortsInRegister = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 2 : 4;
    GT_U32  numBitsPerPort = PRV_CPSS_SIP_5_20_CHECK_MAC(devNum) ? 9 : 8;
    GT_U32  numOfRegisters = 256 / numPortsInRegister;/*256 CPU codes*/
    GT_U32  value = CPSS_CPU_PORT_NUM_CNS;

    /* build value of the registers */
    for(ii  = 1 ; ii < numPortsInRegister ; ii++)
    {
        value |= CPSS_CPU_PORT_NUM_CNS/*0x3f*/ << (ii*numBitsPerPort);
    }

    /* Set CPU Port Mapping Of Register default value  */
    for(ii = 0; ii < numOfRegisters; ii++)
    {
        rc = prvCpssHwPpWriteRegister(devNum,
              PRV_DXCH_REG1_UNIT_EGF_EFT_MAC(devNum).global.cpuPortMapOfReg[ii],
              value);
        if(rc != GT_OK)
        {
            return rc;
        }
    }

    return GT_OK;
}


/*******************************************************************************
* prvCpssDxChHwEgfQagTcDpMapperByIndexSet
*
* DESCRIPTION:
*       (sip5_20) set the EGF QAG 'TC,DP' mapping table , in specific index.
*
* APPLICABLE DEVICES:
*        Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum.
*
* INPUTS:
*       devNum              - The PP's device number.
*       index               - index into the table
*                       (APPLICABLE RANGES: 0..(4K-1))
*            {NW-TC (3 bits)
*            NW-DP (2 bits)
*            Command (2 bits)
*            Cast (1 bit)
*            Target Port TC Profile (2 bits),
*            Source Port TC Profile (2 bits)}
*
*       newTxqDp - the DP to assign in the TXQ
*       newTxqTc - the TC to assign in the TXQ
*                       (APPLICABLE RANGES: 0..7)
*       newTxqPfcTc - the PFC TC to assign in the TXQ
*                       (APPLICABLE RANGES: 0..7)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperByIndexSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  index,
    IN  CPSS_DP_LEVEL_ENT  newTxqDp,
    IN  GT_U32  newTxqTc,
    IN  GT_U32  newTxqPfcTc
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  value;/* hw value for the entry */
    GT_U32  hw_newTxqDp;/* hw value for <newTxqDp> */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_XCAT3_E | CPSS_CAELUM_E);

    PRV_CPSS_DXCH3_COS_DP_CONVERT_MAC(newTxqDp,hw_newTxqDp);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(newTxqTc);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(newTxqPfcTc);

    value = hw_newTxqDp |
            newTxqTc << 2 |
            newTxqPfcTc << 5;

    rc = prvCpssDxChWriteTableEntry(devNum,
        PRV_CPSS_DXCH_BOBCAT3_TABLE_EGF_QAG_TC_DP_MAPPER_E,
        index, &value);

    return rc;
}

/*******************************************************************************
* prvCpssDxChHwEgfQagTcDpMapperByParamsSet
*
* DESCRIPTION:
*       (sip5_20) set the EGF QAG 'TC,DP' mapping table , according to parameters.
*
* APPLICABLE DEVICES:
*        Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum.
*
* INPUTS:
*       devNum              - The PP's device number.
************ next parameters are part of the key , which define the 'index' to the table ***
*
*       origTc              - orig TC (traffic class).
*                       (APPLICABLE RANGES: 0..7)
*       origDp              - orig DP (Drop precedence).
*       packetCommand       - packet command (on of CPSS_DXCH_NET_DSA_CMD_ENT)
*       isSingleDestination - GT_TRUE - single destination
*                             GT_FALSE - multi-destination
*       targetPortTcProfile - Target Port TC Profile
*                       (APPLICABLE RANGES: 0..3)
*       sourcePortTcProfile - Source Port TC Profile
*                       (APPLICABLE RANGES: 0..3)
*
************ next parameters are part of the 'data' to set according to the key ***
*
*       newTxqDp - the DP to assign in the TXQ
*       newTxqTc - the TC to assign in the TXQ
*                       (APPLICABLE RANGES: 0..7)
*       newTxqPfcTc - the PFC TC to assign in the TXQ
*                       (APPLICABLE RANGES: 0..7)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperByParamsSet
(
    IN  GT_U8   devNum,
    /* key */
    IN  GT_U32  origTc,
    IN  CPSS_DP_LEVEL_ENT   origDp,
    IN  CPSS_DXCH_NET_DSA_CMD_ENT  packetCommand,
    IN  GT_BOOL   isSingleDestination,
    IN  GT_U32  targetPortTcProfile,
    IN  GT_U32  sourcePortTcProfile,
    /* data */
    IN  GT_U32  newTxqDp,
    IN  GT_U32  newTxqTc,
    IN  GT_U32  newTxqPfcTc
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  index;
    GT_U32  hw_origDp;/* hw value for <origDp> */
    GT_U32  hw_packetCommand;/* hw value for <packetCommand> */
    GT_U32  hw_isSingleDestination = BOOL2BIT_MAC(isSingleDestination);/* hw value for <isSingleDestination> */

    /* check 'key' parameters */
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(origTc);
    PRV_CPSS_DXCH3_COS_DP_CONVERT_MAC(origDp,hw_origDp);

    switch (packetCommand)
    {
        case CPSS_DXCH_NET_DSA_CMD_TO_CPU_E:
            hw_packetCommand = 0;
            break;
        case CPSS_DXCH_NET_DSA_CMD_FROM_CPU_E:
            hw_packetCommand = 1;
            break;
        case CPSS_DXCH_NET_DSA_CMD_TO_ANALYZER_E:
            hw_packetCommand = 2;
            break;
        case CPSS_DXCH_NET_DSA_CMD_FORWARD_E:
            hw_packetCommand = 3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(targetPortTcProfile >= BIT_2)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(sourcePortTcProfile >= BIT_2)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* build the index
*            {NW-TC (3 bits)
*            NW-DP (2 bits)
*            Command (2 bits)
*            Cast (1 bit)
*            Target Port TC Profile (2 bits),
*            Source Port TC Profile (2 bits)}
    */

    index = origTc << 9 |
            hw_origDp << 7 |
            hw_packetCommand << 5 |
            hw_isSingleDestination << 4 |
            targetPortTcProfile << 2 |
            sourcePortTcProfile ;

    rc = prvCpssDxChHwEgfQagTcDpMapperByIndexSet(devNum,
            index,newTxqDp,newTxqTc,newTxqPfcTc);

    return rc;
}

/*******************************************************************************
* prvCpssDxChHwEgfQagTcDpMapper1To1Set
*
* DESCRIPTION:
*       (sip5_20) set the EGF QAG 'TC,DP' mapping table as '1:1' for specific TC,DP.
*       in terms of {orgTc,orifDp} to {newTc,newDp}.
*
* APPLICABLE DEVICES:
*        Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum.
*
* INPUTS:
*       devNum              - The PP's device number.
*       tc              - orig TC (traffic class).
*                       (APPLICABLE RANGES: 0..7)
*       dp              - orig DP (Drop precedence).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapper1To1Set
(
    IN  GT_U8   devNum,
    IN  GT_U32  tc,
    IN  CPSS_DP_LEVEL_ENT   dp
)
{
    GT_STATUS   rc; /* return code */
    CPSS_DXCH_NET_DSA_CMD_ENT  packetCommand;
    GT_BOOL   isSingleDestination;
    GT_U32  targetPortTcProfile;
    GT_U32  sourcePortTcProfile;

    for(packetCommand = CPSS_DXCH_NET_DSA_CMD_TO_CPU_E ;
        packetCommand <= CPSS_DXCH_NET_DSA_CMD_FORWARD_E ;
        packetCommand++)
    {
        for(isSingleDestination = GT_FALSE ;
            isSingleDestination <= GT_TRUE ;
            isSingleDestination++)
        {
            for(targetPortTcProfile = 0 ;
                targetPortTcProfile < BIT_2;
                targetPortTcProfile++)
            {
                for(sourcePortTcProfile = 0 ;
                    sourcePortTcProfile < BIT_2;
                    sourcePortTcProfile++)
                {
                    rc = prvCpssDxChHwEgfQagTcDpMapperByParamsSet(devNum,
                        tc ,/*origTc*/
                        dp ,/*origDp*/
                        packetCommand,
                        isSingleDestination,
                        targetPortTcProfile,
                        sourcePortTcProfile,

                        dp,/*newTxqDp*/
                        tc,/*newTxqTc*/
                        tc /*newTxqPfcTc*/
                        );
                    if(rc != GT_OK)
                    {
                        return rc;
                    }
                }/*loop on sourcePortTcProfile*/
            }/*loop on targetPortTcProfile*/
        }/*loop on isSingleDestination*/
    }/*loop on packetCommand*/

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwEgfQagTcDpMapperInit
*
* DESCRIPTION:
*       (sip5_20) set the EGF QAG 'TC,DP' mapping table as '1:1' for all the {tc,dp}.
*
* APPLICABLE DEVICES:
*        Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum.
*
* INPUTS:
*       devNum              - The PP's device number.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK on success
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS prvCpssDxChHwEgfQagTcDpMapperInit
(
    IN  GT_U8   devNum
)
{
    GT_STATUS   rc; /* return code */
    GT_U32  tc;
    CPSS_DP_LEVEL_ENT   dp;

    for(tc = 0 ;tc < CPSS_TC_RANGE_CNS ; tc++)
    {
        for(dp = CPSS_DP_GREEN_E ; dp <= CPSS_DP_RED_E ; dp++)
        {
            rc = prvCpssDxChHwEgfQagTcDpMapper1To1Set(devNum,tc,dp);
            if(rc != GT_OK)
            {
                return rc;
            }
        }/*loop on dp*/
    }/*loop on tc*/

    return GT_OK;

}


/*******************************************************************************
* internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet
*
* DESCRIPTION:
*       Set the number of physical ports that the device should support.
*       In Bobcat3 there is tradeoff between number of physical ports and some tables
*       that hold all physical ports 'per entry'
*       So Bobcat3 can support 256 physical ports like Bobcat2  :
*           8K vlans , 4K STG , 4K trunks , 4K SST-ID
*       Or Bobcat3 can support 512 physical ports :
*           4K vlans, 2K STG , 2K trunks ,  2K SST-ID , single device (8bit port-id in eDSA)
*           NOTE: Next tables keep 256 ports only !!!   :
*              L2 Port Isolation , L3 Port Isolation
*
* APPLICABLE DEVICES:
*        Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; Lion; Lion2; xCat; xCat3; xCat2; Bobcat2; Caelum.
*
* INPUTS:
*       devNum           - The PP's device number.
*       maxPhysicalPorts - the max number of 'physical ports' that the device need to support.
*                          value 0 means 'default'
*           (APPLICABLE VALUES: Bobcat3: 0,256,512)
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong parameters
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChHwPpMaxNumOfPhyPortsToUseSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  maxPhysicalPorts
)
{
    GT_STATUS rc;
    GT_U32  value_distributorGeneralConfigs;/* value to register distributorGeneralConfigs */
    GT_U32  value_SHTGlobalConfigs;         /* value to register SHTGlobalConfigs */
    GT_U32  value_bridgeGlobalConfig0;      /* value to register bridgeGlobalConfig0 */
    GT_U32  regAddr,regOffset,regValue;
    GT_U32  isHalfTable;
    GT_U32  multipleValue=1,dividerValue=1;
    GT_U32  ii;
    static PRV_CPSS_DXCH_TABLE_ENT affectedTables[] = {
        /*L2i*/
        PRV_CPSS_DXCH_LION_TABLE_STG_INGRESS_E,
        PRV_CPSS_DXCH_LION3_TABLE_INGRESS_BRIDGE_PORT_MEMBERS_E,
        /*QAG*/
        PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_QAG_EGRESS_VLAN_E,
        /*SHT*/
        PRV_CPSS_DXCH_LION3_TABLE_EGRESS_EGF_SHT_NON_TRUNK_MEMBERS2_E,
        PRV_CPSS_DXCH_LION_TABLE_STG_EGRESS_E,
        PRV_CPSS_DXCH_LION_TABLE_VLAN_EGRESS_E,
        PRV_CPSS_DXCH_LION_TABLE_TXQ_SOURCE_ID_MEMBERS_E,

        /* must be last */
        PRV_CPSS_DXCH_TABLE_LAST_E
    };

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
          CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E |
          CPSS_BOBCAT2_E | CPSS_CAELUM_E);

    if(maxPhysicalPorts == 0)
    {
        /* default : half table */
        maxPhysicalPorts = PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts / 2;
    }

    if(maxPhysicalPorts == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts)
    {   /* BC3:512 ports */
        isHalfTable = 1;  /* half table */
    }
    else
    if((maxPhysicalPorts*2) == PRV_CPSS_DXCH_PP_MAC(devNum)->hwInfo.maxPhysicalPorts)
    {
        /* BC3:256 ports */
        isHalfTable = 0;  /* full table */
    }
    else
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM,
            "value[%d] not supported for this device",maxPhysicalPorts);
    }

    if(isHalfTable)
    {
        /* half table */
        value_distributorGeneralConfigs = 1;
        value_SHTGlobalConfigs = 1;
        value_bridgeGlobalConfig0 = 0;

        if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort != maxPhysicalPorts)
        {
            /* we change mode from 'full' to 'half' */
            dividerValue = 2;
            CPSS_LOG_INFORMATION_MAC("we change mode from 'full' to 'half' table mode \n");
        }
        else
        {
            CPSS_LOG_INFORMATION_MAC("we keep 'half' table mode \n");
        }
    }
    else
    {
        /* full table */
        value_distributorGeneralConfigs = 0;
        value_SHTGlobalConfigs = 0;
        value_bridgeGlobalConfig0 = 1;

        if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort != 0 &&
           PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort != maxPhysicalPorts)
        {
            /* we change mode from 'half' to 'full' */
            multipleValue = 2;
            CPSS_LOG_INFORMATION_MAC("we change mode from 'half' to 'full' table mode \n");
        }
        else
        {
            CPSS_LOG_INFORMATION_MAC("we keep 'full' table mode \n");
        }
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid == 0)
    {
        /* init values */
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VID_MAC(devNum);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId == 0)
    {
        /* init values */
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId = 1 + PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum);
    }


#define UPDATE_VALUE_MAC(value,multiple,divide) \
    value = ((value) * (multiple)) / (divide)

    /* set new values to table sizes */
    PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).phyPort  = maxPhysicalPorts;
    UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid       ,multipleValue,dividerValue);
    UPDATE_VALUE_MAC(PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId     ,multipleValue,dividerValue);

    CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
        "Vlans",
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).vid);

    CPSS_LOG_INFORMATION_MAC("Table [%s] new num of entries [%d] \n",
        "Src-id",
        PRV_CPSS_DXCH_PP_HW_INFO_LIMITED_RESOURCES_FIELD_MAC(devNum).sstId);

    /*<Table Access Mode>*/
    regAddr = PRV_DXCH_REG1_UNIT_EGF_QAG_MAC(devNum).distributor.distributorGeneralConfigs;
    regOffset = 15;
    regValue = value_distributorGeneralConfigs;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, 1, regValue);
    if(rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    /*<Table Access Mode>*/
    regAddr = PRV_DXCH_REG1_UNIT_EGF_SHT_MAC(devNum).global.SHTGlobalConfigs;
    regOffset = 8;
    regValue = value_SHTGlobalConfigs;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, 1, regValue);
    if(rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    /* <HalfPhyPortTables> */
    regAddr = PRV_DXCH_REG1_UNIT_L2I_MAC(devNum).bridgeEngineConfig.bridgeGlobalConfig0;
    regOffset = 26;
    regValue = value_bridgeGlobalConfig0;
    rc = prvCpssHwPpSetRegField(devNum, regAddr, regOffset, 1, regValue);
    if(rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(rc, LOG_ERROR_NO_MSG);
    }

    ii = 0;
    while(affectedTables[ii] < PRV_CPSS_DXCH_TABLE_LAST_E)
    {
        if(isHalfTable)
        {
            PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_SET_MAC(devNum,affectedTables[ii]);
        }
        else
        {
            PRV_CPSS_DXCH_BMP_OF_TABLES_IN_HALF_SIZE_MODE_CLEAR_MAC(devNum,affectedTables[ii]);
        }
        ii++;
    }

    return GT_OK;
}

/*******************************************************************************
* prvCpssDxChHwInitNumOfSerdesGet
*
* DESCRIPTION:
*       Get number of SERDES lanes in device.
*       Function returns number of SERDES in port group for Lion and Lion2
*
* APPLICABLE DEVICES:
*       xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3.
*
* INPUTS:
*       devNum          - physical device number
*
* OUTPUTS:
*       None
*
* RETURNS:
*       0 - for not applicable device
*       Number of number of SERDES lanes in device or port group
*
* COMMENTS:
*
*******************************************************************************/
GT_U32 prvCpssDxChHwInitNumOfSerdesGet
(
    IN GT_U8 devNum
)
{
    GT_U32      lanesNumInDev; /* number of SERDES lanes */

    switch(PRV_CPSS_PP_MAC(devNum)->devFamily)
    {
        case CPSS_PP_FAMILY_DXCH_XCAT_E:
            lanesNumInDev = PRV_CPSS_XCAT_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            lanesNumInDev = PRV_CPSS_XCAT3_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_LION_E:
            lanesNumInDev = PRV_CPSS_LION_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            lanesNumInDev = PRV_CPSS_LION2_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_BOBCAT3_E:
        case CPSS_PP_FAMILY_DXCH_BOBCAT2_E:
            lanesNumInDev = PRV_CPSS_BOBCAT2_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_ALDRIN_E:
            lanesNumInDev = PRV_CPSS_ALDRIN_SERDES_NUM_CNS;
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            lanesNumInDev = PRV_CPSS_XCAT2_SERDES_NUM_CNS;
            break;
        default:
            lanesNumInDev = 0;
            break;
    }

    return lanesNumInDev;
}


