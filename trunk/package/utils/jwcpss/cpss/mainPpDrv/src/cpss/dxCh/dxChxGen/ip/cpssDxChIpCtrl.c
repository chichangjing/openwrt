/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
* cpssDxChIpCtrl.c
*
* DESCRIPTION:
*       the CPSS DXCH Ip HW control registers APIs
*
* FILE REVISION NUMBER:
*       $Revision: 98 $
*******************************************************************************/
#define CPSS_LOG_IN_MODULE_ENABLE

#include <stdlib.h>

#include <cpss/generic/cpssTypes.h>
#include <cpss/generic/cpssCommonDefs.h>
#include <cpss/dxCh/dxChxGen/ip/cpssDxChIpTypes.h>
#include <cpss/dxCh/dxChxGen/ip/cpssDxChIpCtrl.h>
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
#include <cpss/generic/bridge/private/prvCpssBrgVlanTypes.h>
#include <cpss/dxCh/dxChxGen/cos/private/prvCpssDxChCoS.h>
#include <cpss/dxCh/dxChxGen/ip/private/prvCpssDxChIpLog.h>

#define CHEETAH_MAX_MAC_QOS_ENTRIES_CNS   128

#define NUMBER_OF_EXCEPTION_DATABASES_CNS   5

/* check that the Qos profile Entry is in the valid range.*/
#define PRV_CPSS_DXCH_QOS2MT_ENTRY_CHECK_MAC(devNum,qosProfile)  \
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum))      \
    {                                                            \
        if (qosProfile >= _1K)                                   \
        {                                                        \
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);                                 \
        }                                                        \
    }                                                            \
    else                                                         \
    if (qosProfile >= CHEETAH_MAX_MAC_QOS_ENTRIES_CNS )          \
    {                                                            \
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);                                     \
    }


/* max num of global mac sa entries */
#define PRV_CPSS_MAC_SA_MAX_NUM_CNS 255

/* check route mac sa index */
#define PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(index)    \
    if(index > PRV_CPSS_MAC_SA_MAX_NUM_CNS)   \
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, "index[%d] more than [%d]", \
            index,PRV_CPSS_MAC_SA_MAX_NUM_CNS)

/* Struct to hold exception command data */
typedef struct CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STCT
{
    CPSS_DXCH_IP_EXCEPTION_TYPE_ENT excptType;
    CPSS_IP_PROTOCOL_STACK_ENT      protocolStack;
    CPSS_PACKET_CMD_ENT             cmd;
    GT_U8                           registerIndex;
    GT_U32                          offset;
    GT_U32                          length;
    GT_U32                          value;
} CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC;
/*******************************************************************************/
/* static array that holds registers, offsets and values for each         */
/* exception and each command supported; the structure is:                */
/* <family type> <exception> <protocol> <cmd> <registerIndex> <offset> <length> <value> */

/* exceptions entries that apply only to DxCh devices */
static CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxChOnlyExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_ROUTE_E,            5,16,1,0},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      5,16,1,1},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_ROUTE_E,            5,17,1,0},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      5,17,1,1},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            5,20,1,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      5,20,1,1},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            5,21,1,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      5,21,1,1},
    /* IPv4 Unicast TLL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_ROUTE_E,            5,18,1,0},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      5,18,1,1},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_ROUTE_E,            5,19,1,0},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      5,19,1,1}
};

/* exceptions entries that apply only to DxCh Devices supporting
   Policy based routing using PCL action as next hop */
static CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxChPbrOnlyExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_ROUTE_E,            6,16,1,0},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,16,1,1},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_ROUTE_E,            6,17,1,0},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,17,1,1},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            6,20,1,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,20,1,1},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            6,21,1,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,21,1,1},
    /* IPv4 Unicast TTL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_ROUTE_E,            6,18,1,0},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,18,1,1},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_ROUTE_E,            6,19,1,0},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      6,19,1,1}
};


/* exceptions entries that apply to DxCh2 and above devices */
static CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxCh2AndAboveExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,15,3,4},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,15,3,4},
    /* IPv4 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_E ,          0,12,3,6},
    /* IPv6 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_E,           1,12,3,6},
    /* IPv4 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,27,3,4},
    /* IPv6 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,27,3,4},
    /* IPv4 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E,           0,24,3,6},
    /* IPv6 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E,           1,24,3,6},
    /* IPv4 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,0,3,4},
    /* IPv6 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,0,3,4},
    /* IPv4 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E ,          2,3,3,6},
    /* IPv6 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E ,          3,3,3,6},
    /* IPv4 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,3,1,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_NONE_E,             4,3,1,0},
    /* IPv6 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,1,1,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_NONE_E,             4,1,1,0},
    /* IPv6 Unicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,3,3,4},
    /* IPv6 Multicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E ,          1,0,3,6},
    /* IPv4 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,4,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_NONE_E,             4,4,1,0},
    /* IPv6 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,2,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_NONE_E,             4,2,1,0},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,9,3,4},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,9,3,4},
    /* IPv4 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,6,3,6},
    /* IPv6 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_E,           1,6,3,6},
    /* IPv6 Unicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,20,3,0},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,20,3,1},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,20,3,2},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,20,3,3},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,20,3,4},
    /* IPv6 Multicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,17,3,0},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,17,3,1},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,17,3,2},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,17,3,3},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,17,3,4},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,17,3,5},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_E,           3,17,3,6},
    /* IPv4 Unicast TLL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_HARD_E,        0,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        0,21,3,4},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_HARD_E,        1,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        1,21,3,4},
    /* IPv4 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_HARD_E,        2,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        2,9,3,4},
    /* IPv6 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_HARD_E,        3,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        3,9,3,4},
    /* IPv4 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_HARD_E,        2,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        2,13,3,4},
    /* IPv6 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_HARD_E,        3,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        3,13,3,4}
};

/* exceptions entries that apply only to DxCh2 devices */
static CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxCh2OnlyExceptions[] =
{
    /* IPv4 Unicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        0,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        0,3,3,4},
    /* IPv4 Multicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E ,          0,0,3,6},
};
/* exceptions entries that apply to DxCh3 and above devices */
static CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC dxCh3AndAboveExceptions[] =
{
    /* IPv4 Unicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,3,3,4},
    /* IPv4 Multicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,0,3,6},
    /* IPv4 Unicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,19,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,19,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,19,3,4},
    /* IPv4 Multicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,16,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,16,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,16,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,16,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E ,          2,16,3,6},
};

 /* exceptions entries that apply to Bobcat2, Caelum, Bobcat3 devices */
static CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC eArchExceptions[] =
{
    /* IPv4 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,15,3,4},
    /* IPv6 Unicast Header Error command */
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,15,3,2},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,15,3,3},
    {CPSS_DXCH_IP_EXCP_UC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,15,3,4},
    /* IPv4 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_HARD_E,        0,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        0,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV4_E,          CPSS_PACKET_CMD_BRIDGE_E ,          0,12,3,6},
    /* IPv6 Multicast Header Error command */
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,12,3,2},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_HARD_E,        1,12,3,3},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_DROP_SOFT_E,        1,12,3,4},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,12,3,5},
    {CPSS_DXCH_IP_EXCP_MC_HDR_ERROR_E,CPSS_IP_PROTOCOL_IPV6_E,          CPSS_PACKET_CMD_BRIDGE_E,           1,12,3,6},
    /* IPv4 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,27,3,4},
    /* IPv6 Unicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,27,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,27,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,27,3,4},
    /* IPv4 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        0,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        0,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E,           0,24,3,6},
    /* IPv6 Multicast Illegal Address command */
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,24,3,2},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        1,24,3,3},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        1,24,3,4},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,24,3,5},
    {CPSS_DXCH_IP_EXCP_MC_ILLEGAL_ADDRESS_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E,           1,24,3,6},
    /* IPv4 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,0,3,4},
    /* IPv6 UC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,0,3,4},
    /* IPv4 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_HARD_E,        2,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        2,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV4_E,    CPSS_PACKET_CMD_BRIDGE_E ,          2,3,3,6},
    /* IPv6 MC DIP/DA Mismatch exception command */
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,3,3,2},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_HARD_E,        3,3,3,3},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_DROP_SOFT_E,        3,3,3,4},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,3,3,5},
    {CPSS_DXCH_IP_EXCP_MC_DIP_DA_MISMATCH_E,CPSS_IP_PROTOCOL_IPV6_E,    CPSS_PACKET_CMD_BRIDGE_E ,          3,3,3,6},
    /* IPv4 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_E,            4,21,3,0},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 4,21,3,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      4,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        4,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,21,3,4},
    /* IPv6 Unicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_ROUTE_E,            4,0,3,0},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 4,0,3,1},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      4,0,3,2},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        4,0,3,3},
    {CPSS_DXCH_IP_EXCP_UC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        4,0,3,4},
    /* IPv6 Unicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,3,3,4},
    /* IPv6 Multicast MTU Exceeded command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_HARD_E,        1,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        1,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E ,          1,0,3,6},
    /* IPv4 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,4,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_NONE_E,             4,4,1,0},
    /* IPv6 Multicast all-zero SIP exception command */
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_BRIDGE_E,           4,3,1,1},
    {CPSS_DXCH_IP_EXCP_MC_ALL_ZERO_SIP_E,CPSS_IP_PROTOCOL_IPV6_E,       CPSS_PACKET_CMD_NONE_E,             4,3,1,0},
    /* IPv4 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,9,3,4},
    /* IPv6 Unicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,9,3,0},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,9,3,1},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,9,3,4},
    /* IPv4 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_E,            0,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 0,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,6,3,6},
    /* IPv6 Multicast Options/Hop-by-Hop Exception command */
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_E,            1,6,3,0},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 1,6,3,1},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,6,3,2},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_HARD_E,        1,6,3,3},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        1,6,3,4},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,1,6,3,5},
    {CPSS_DXCH_IP_EXCP_MC_OPTION_HOP_BY_HOP_E,CPSS_IP_PROTOCOL_IPV6_E,  CPSS_PACKET_CMD_BRIDGE_E,           1,6,3,6},
    /* IPv6 Unicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,20,3,0},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,20,3,1},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,20,3,2},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,20,3,3},
    {CPSS_DXCH_IP_EXCP_UC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,20,3,4},
    /* IPv6 Multicast non-Hop-by-hop extension exception command */
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_E,            3,17,3,0},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E, 3,17,3,1},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,17,3,2},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_HARD_E,        3,17,3,3},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_DROP_SOFT_E,        3,17,3,4},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,3,17,3,5},
    {CPSS_DXCH_IP_EXCP_MC_NON_HOP_BY_HOP_EXT_E,CPSS_IP_PROTOCOL_IPV6_E, CPSS_PACKET_CMD_BRIDGE_E,           3,17,3,6},
    /* IPv4 Unicast TLL Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_HARD_E,        0,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV4_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        0,21,3,4},
    /* IPv6 Unicast Hop Limit (TTL) Exceeded command */
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_TRAP_TO_CPU_E,      1,21,3,2},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_HARD_E,        1,21,3,3},
    {CPSS_DXCH_IP_EXCP_UC_TTL_EXCEED_E,CPSS_IP_PROTOCOL_IPV6_E,         CPSS_PACKET_CMD_DROP_SOFT_E,        1,21,3,4},
    /* IPv4 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_HARD_E,        2,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        2,9,3,4},
    /* IPv6 Unicast RPF Fail command */
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,9,3,2},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_HARD_E,        3,9,3,3},
    {CPSS_DXCH_IP_EXCP_UC_RPF_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,           CPSS_PACKET_CMD_DROP_SOFT_E,        3,9,3,4},
    /* IPv4 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_HARD_E,        2,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV4_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        2,13,3,4},
    /* IPv6 SIP/SA Fail command */
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_TRAP_TO_CPU_E,      3,13,3,2},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_HARD_E,        3,13,3,3},
    {CPSS_DXCH_IP_EXCP_UC_SIP_SA_FAIL_E,CPSS_IP_PROTOCOL_IPV6_E,        CPSS_PACKET_CMD_DROP_SOFT_E,        3,13,3,4},
    /* IPv4 Unicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,3,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,3,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,3,3,4},
    /* IPv4 Multicast MTU Exceeded for non "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_TRAP_TO_CPU_E,      0,0,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_HARD_E,        0,0,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_DROP_SOFT_E,        0,0,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,0,0,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_NON_DF_E,CPSS_IP_PROTOCOL_IPV4_E,  CPSS_PACKET_CMD_BRIDGE_E ,          0,0,3,6},
    /* IPv4 Unicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,19,3,2},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,19,3,3},
    {CPSS_DXCH_IP_EXCP_UC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,19,3,4},
    /* IPv4 Multicast MTU Exceeded for "don't fragment" (DF) packets command */
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_TRAP_TO_CPU_E,      2,16,3,2},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_HARD_E,        2,16,3,3},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_DROP_SOFT_E,        2,16,3,4},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,2,16,3,5},
    {CPSS_DXCH_IP_EXCP_MC_MTU_EXCEEDED_FOR_DF_E,CPSS_IP_PROTOCOL_IPV4_E,       CPSS_PACKET_CMD_BRIDGE_E ,          2,16,3,6}
};

extern GT_STATUS prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1
(
    IN  GT_U8                                 devNum,
    IN  GT_PHYSICAL_PORT_NUM                  portNum,
    IN  GT_BOOL                               usePerTc,
    IN  CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   *shaperConfigPtr,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN  GT_U32                                tokenBucketRate,
    OUT GT_BOOL                               *slowRateEnPtr,
    OUT GT_U32                                *tbUpdateRatioPtr,
    OUT GT_U32                                *tokensPtr
);

extern GT_STATUS prvDxChPortTxCalcShaperTokenBucketRate_rev1
(
    IN    GT_U8                   devNum,
    IN    GT_PHYSICAL_PORT_NUM    portNum,
    IN    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC *shaperConfigPtr,
    IN    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT     shaperMode,
    IN    GT_BOOL                 slowRateEn,
    IN    GT_U32                  tbUpdateRatio,
    IN    GT_U32                  tokenRefillValue,
    OUT   GT_U32                 *tokenBucketRatePtr

);

/*******************************************************************************
* internal_cpssDxChIpSpecialRouterTriggerEnable
*
* DESCRIPTION:
*       Sets the special router trigger enable modes for packets with bridge
*       command other then FORWARD or MIRROR.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum              - the device number
*       bridgeExceptionCmd  - the bridge exception command the packet arrived to
*                             the router with.
*       enableRouterTrigger - enable /disable router trigger.
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpSpecialRouterTriggerEnable
(
    IN GT_U8                           devNum,
    IN CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    IN GT_BOOL                         enableRouterTrigger
)
{
    GT_U32    regAddr;              /* register address                   */

    GT_STATUS rc;                   /* return code                        */
    GT_U32      value;      /* value to write */
    GT_U32      offset;     /* offset in the register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }


    /* all bridgeExceptionCmd refer to the same register but in different offsets */
    /* find offset according to brgExcpCmd */


    switch (bridgeExceptionCmd)
    {
    case CPSS_DXCH_IP_BRG_UC_IPV4_TRAP_EXCP_CMD_E:
        offset = 26;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_TRAP_EXCP_CMD_E:
        offset = 24;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 22;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 20;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_TRAP_EXCP_CMD_E:
        offset = 25;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_TRAP_EXCP_CMD_E:
        offset = 23;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 21;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 19;
        break;
    case CPSS_DXCH_IP_BRG_ARP_TRAP_EXCP_CMD_E:
        offset = 28;
        break;
    case CPSS_DXCH_IP_BRG_ARP_SOFT_DROP_EXCP_CMD_E:
        offset = 27;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* write enable value at the calculated offset */
    value = (enableRouterTrigger == GT_TRUE) ? 1:0;
    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,1,value);

    return rc;

}

/*******************************************************************************
* cpssDxChIpSpecialRouterTriggerEnable
*
* DESCRIPTION:
*       Sets the special router trigger enable modes for packets with bridge
*       command other then FORWARD or MIRROR.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum              - the device number
*       bridgeExceptionCmd  - the bridge exception command the packet arrived to
*                             the router with.
*       enableRouterTrigger - enable /disable router trigger.
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpSpecialRouterTriggerEnable
(
    IN GT_U8                           devNum,
    IN CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    IN GT_BOOL                         enableRouterTrigger
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSpecialRouterTriggerEnable);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeExceptionCmd, enableRouterTrigger));

    rc = internal_cpssDxChIpSpecialRouterTriggerEnable(devNum, bridgeExceptionCmd, enableRouterTrigger);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeExceptionCmd, enableRouterTrigger));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpSpecialRouterTriggerEnableGet
*
* DESCRIPTION:
*       Gets the special router trigger enable modes for packets with bridge
*       command other then FORWARD or MIRROR.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum              - the device number
*       bridgeExceptionCmd  - the bridge exception command the packet arrived to
*                             the router with.
*
* OUTPUTS:
*       enableRouterTriggerPtr - router trigger state (enable/disable).
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpSpecialRouterTriggerEnableGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    OUT GT_BOOL                         *enableRouterTriggerPtr
)
{
    GT_U32    regAddr;        /* register address */

    GT_STATUS rc;             /* return code */
    GT_U32      hwValue;      /* hw value */
    GT_U32      offset;       /* offset in the register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(enableRouterTriggerPtr);


    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }


    /* all bridgeExceptionCmd refer to the same register but in different offsets */
    /* find offset according to brgExcpCmd */

    switch (bridgeExceptionCmd)
    {
    case CPSS_DXCH_IP_BRG_UC_IPV4_TRAP_EXCP_CMD_E:
        offset = 26;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_TRAP_EXCP_CMD_E:
        offset = 24;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 22;
        break;
    case CPSS_DXCH_IP_BRG_UC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 20;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_TRAP_EXCP_CMD_E:
        offset = 25;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_TRAP_EXCP_CMD_E:
        offset = 23;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV4_SOFT_DROP_EXCP_CMD_E:
        offset = 21;
        break;
    case CPSS_DXCH_IP_BRG_MC_IPV6_SOFT_DROP_EXCP_CMD_E:
        offset = 19;
        break;
    case CPSS_DXCH_IP_BRG_ARP_TRAP_EXCP_CMD_E:
        offset = 28;
        break;
    case CPSS_DXCH_IP_BRG_ARP_SOFT_DROP_EXCP_CMD_E:
        offset = 27;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* read enable value at the calculated offset */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,1,&hwValue);

    *enableRouterTriggerPtr = (0 == hwValue) ? GT_FALSE : GT_TRUE;

    return rc;
}

/*******************************************************************************
* cpssDxChIpSpecialRouterTriggerEnableGet
*
* DESCRIPTION:
*       Gets the special router trigger enable modes for packets with bridge
*       command other then FORWARD or MIRROR.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum              - the device number
*       bridgeExceptionCmd  - the bridge exception command the packet arrived to
*                             the router with.
*
* OUTPUTS:
*       enableRouterTriggerPtr - router trigger state (enable/disable).
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - wrong devNum or bridgeExceptionCmd
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpSpecialRouterTriggerEnableGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_DXCH_IP_BRG_EXCP_CMD_ENT   bridgeExceptionCmd,
    OUT GT_BOOL                         *enableRouterTriggerPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSpecialRouterTriggerEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeExceptionCmd, enableRouterTriggerPtr));

    rc = internal_cpssDxChIpSpecialRouterTriggerEnableGet(devNum, bridgeExceptionCmd, enableRouterTriggerPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeExceptionCmd, enableRouterTriggerPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* prvCpssDxChIpExceptionDBIndexGet
*
* DESCRIPTION:
*       initialize databases to scan according to device family type.
*
* APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum  - the device number
*
* OUTPUTS:
*       databaseArr[] - array to hold the databases to scan
*       databaseSizePtr - size of the database
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*******************************************************************************/
static GT_STATUS prvCpssDxChIpExceptionDBIndexGet
(
    IN GT_U8                                    devNum,
    OUT CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC   *databaseArr[],
    OUT GT_U32                                   *databaseSizePtr
)
{
    GT_U32      i;            /* counters */

  /* initialize databases to scan according to device family type */
    for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
        databaseArr[i] = NULL;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        databaseArr[0] = eArchExceptions;
        databaseSizePtr[0] = sizeof(eArchExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
    }
    else
    {
        switch (PRV_CPSS_PP_MAC(devNum)->devFamily)
        {
        case CPSS_PP_FAMILY_CHEETAH_E:
            databaseArr[0] = dxChOnlyExceptions;
            databaseSizePtr[0] = sizeof(dxChOnlyExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            break;
        case CPSS_PP_FAMILY_CHEETAH2_E:
            databaseArr[0] = dxCh2AndAboveExceptions;
            databaseSizePtr[0] = sizeof(dxCh2AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            databaseArr[1] = dxCh2OnlyExceptions;
            databaseSizePtr[1] = sizeof(dxCh2OnlyExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            break;
        case CPSS_PP_FAMILY_CHEETAH3_E:
            /* explicity fallthrough */
        case CPSS_PP_FAMILY_DXCH_LION_E:
        case CPSS_PP_FAMILY_DXCH_LION2_E:
            databaseArr[0] = dxCh2AndAboveExceptions;
            databaseSizePtr[0] = sizeof(dxCh2AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            databaseArr[1] = dxCh3AndAboveExceptions;
            databaseSizePtr[1] = sizeof(dxCh3AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT2_E:
            databaseArr[0] = dxChPbrOnlyExceptions;
            databaseSizePtr[0] = sizeof(dxChPbrOnlyExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            break;
        case CPSS_PP_FAMILY_DXCH_XCAT_E:
        case CPSS_PP_FAMILY_DXCH_XCAT3_E:
            if (PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode == CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E)
            {
                databaseArr[0] = dxChPbrOnlyExceptions;
                databaseSizePtr[0] = sizeof(dxChPbrOnlyExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            }
            else
            {
                databaseArr[0] = dxCh2AndAboveExceptions;
                databaseSizePtr[0] = sizeof(dxCh2AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
                databaseArr[1] = dxCh3AndAboveExceptions;
                databaseSizePtr[1] = sizeof(dxCh3AndAboveExceptions) / sizeof(CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC);
            }
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }
    }
    return GT_OK;
}

/*******************************************************************************
* internal_cpssDxChIpExceptionCommandSet
*
* DESCRIPTION:
*       set a specific exception command.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       None.
*
* INPUTS:
*       devNum        - the device number
*       exceptionType  - the exception type
*       protocolStack - whether to set for ipv4/v6 or both
*       command       - the command, for availble commands see
*                       CPSS_DXCH_IP_EXCEPTION_TYPE_ENT.
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpExceptionCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN CPSS_PACKET_CMD_ENT              command
)
{
    GT_STATUS   rc;             /* function return code */
    GT_U32      regAddr;        /* address of register to write to */
    GT_BOOL     ipv4EntryFound; /* ipv4 matching row was found */
    GT_U32      ipv6EntryFound; /* ipv6 matching row was found */
    GT_U32      i,j;            /* counters */



    /* array to hold the databases to scan */
    CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC *database[NUMBER_OF_EXCEPTION_DATABASES_CNS];
    /* size of the database  */
    GT_U32 databaseSize[NUMBER_OF_EXCEPTION_DATABASES_CNS];

    /* check parameters; note that the exception types */
    /* are checked while scanning the databases        */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_IPV4V6_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc=prvCpssDxChIpExceptionDBIndexGet(devNum,database,databaseSize);
    if (rc != GT_OK)
        return rc;

    /* before start search for matching lines, mark that ipv4 matching */
    /* exception and ipv6 matching exception were not found yet        */
    ipv4EntryFound = GT_FALSE;
    ipv6EntryFound = GT_FALSE;

    /* search the databases for matching lines, remember 7 elements in each row*/
    for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
    {
        /* skip empty databases */
        if (database[i] == NULL)
            continue;

        /* now scan the current databse entries */
        for (j = 0 ; j < databaseSize[i]; j++)
        {
            /* check that excpType and cmd match */
            if ((exceptionType != database[i][j].excptType) || (command != database[i][j].cmd))
                continue;

            /* check if protocolStack doesn't match */
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV6_E))
                continue;
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E))
                continue;

            /* a match was found, find register address from register index */
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
                    break;
                case 5:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ctrlReg0;
                    break;
                case 6:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }

            /* write value to the register */
            rc = prvCpssHwPpSetRegField(devNum,regAddr,database[i][j].offset,
                                           database[i][j].length,database[i][j].value);
            if (rc != GT_OK)
                return rc;

            /* set index of protocol that was updated */
            if (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E)
                ipv4EntryFound = GT_TRUE;
            else /* meaning database[i][j].protocolStack == GT_IP_PROTOCOL_IPV6 */
                ipv6EntryFound = GT_TRUE;
        }
    }

    /* if no matching line was found, return with error */
    if ((ipv4EntryFound == GT_FALSE) && (ipv6EntryFound == GT_FALSE))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpExceptionCommandSet
*
* DESCRIPTION:
*       set a specific exception command.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       None.
*
* INPUTS:
*       devNum        - the device number
*       exceptionType  - the exception type
*       protocolStack - whether to set for ipv4/v6 or both
*       command       - the command, for availble commands see
*                       CPSS_DXCH_IP_EXCEPTION_TYPE_ENT.
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpExceptionCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN CPSS_PACKET_CMD_ENT              command
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpExceptionCommandSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, exceptionType, protocolStack, command));

    rc = internal_cpssDxChIpExceptionCommandSet(devNum, exceptionType, protocolStack, command);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, exceptionType, protocolStack, command));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpExceptionCommandGet
*
* DESCRIPTION:
*       get a specific exception command.
*
* APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       None.
*
* INPUTS:
*       devNum        - the device number
*       exceptionType  - the exception type
*       protocolStack - whether to get for ipv4/v6
*
* OUTPUTS:
*       exceptionCmdPtr       - the command, for availble commands see
*                       CPSS_DXCH_IP_EXCEPTION_TYPE_ENT
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_STATE             - on invalid hardware value read
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpExceptionCommandGet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT CPSS_PACKET_CMD_ENT             *exceptionCmdPtr
)
{
    GT_STATUS   rc;             /* function return code */
    GT_U32      regAddr;        /* address of register to write to */
    GT_U32      i,j;            /* counters */
    GT_U32      value=0;        /* value to read                    */

    /* array to hold the databases to scan */
    CPSS_DXCH_IP_EXCPTION_CMD_REG_INFO_STC *database[NUMBER_OF_EXCEPTION_DATABASES_CNS];
    /* size of the database  */
    GT_U32 databaseSize[NUMBER_OF_EXCEPTION_DATABASES_CNS];

    /* check parameters; note that the exception types */
    /* are checked while scanning the databases        */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(exceptionCmdPtr);

    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_IPV4V6_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc=prvCpssDxChIpExceptionDBIndexGet(devNum,database,databaseSize);
    if (rc != GT_OK)
        return rc;

    /* search the databases for matching lines, remember 7 elements in each row*/
    for (i = 0 ; i < NUMBER_OF_EXCEPTION_DATABASES_CNS ; i++)
    {
        /* skip empty databases */
        if (database[i] == NULL)
            continue;


        /* now scan the current databse entries */
        for (j = 0 ; j < databaseSize[i]; j++)
        {
            /* check that excpType and cmd match */
            if (exceptionType != database[i][j].excptType)
                continue;

            /* check if protocolStack doesn't match */
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV6_E))
                continue;
            if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) &&
                (database[i][j].protocolStack == CPSS_IP_PROTOCOL_IPV4_E))
                continue;

            /* a match was found, find register address from register index */
            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6GlobalCtrl.IPv6CtrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }
            else
            {
                switch (database[i][j].registerIndex)
                {
                case 0:
                   regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
                    break;
                case 1:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg0;
                    break;
                case 2:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg1;
                    break;
                case 3:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ctrlReg1;
                    break;
                case 4:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
                    break;
                case 5:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ctrlReg0;
                    break;
                case 6:
                    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }
            }

            /* read value from the register */
            rc = prvCpssHwPpGetRegField(devNum,regAddr,database[i][j].offset,
                                           database[i][j].length,&value);
            if (rc != GT_OK)
                return rc;

            /* break out of the loop after reading the register */
            break;
        }

        /* if end of table reached - then                           */
        /* illegal parameter or illegal combination of parameters   */
        if (j == databaseSize[i] && i == NUMBER_OF_EXCEPTION_DATABASES_CNS)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* scan table lines that match to current set of <excp><stack><type> */
        /* to see if the command read from hardware match any of those lines */
        for (; j < databaseSize[i]; j++)
        {
            /* check that excpType match */
            if (exceptionType != database[i][j].excptType)
                break;

            /* check if protocolStack match */
            if (protocolStack != database[i][j].protocolStack)
                break;

            /* check if command value is valid and return appropriate enum if does */
            if (database[i][j].value == value)
            {
                *exceptionCmdPtr = database[i][j].cmd;
                return GT_OK;
            }
         }

    }
    /* if end of table reached - then                           */
    /* illegal parameter or illegal combination of parameters   */
    if (i == NUMBER_OF_EXCEPTION_DATABASES_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* no matching command found for read value */
    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);

}

/*******************************************************************************
* cpssDxChIpExceptionCommandGet
*
* DESCRIPTION:
*       get a specific exception command.
*
* APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       None.
*
* INPUTS:
*       devNum        - the device number
*       exceptionType  - the exception type
*       protocolStack - whether to get for ipv4/v6
*
* OUTPUTS:
*       exceptionCmdPtr       - the command, for availble commands see
*                       CPSS_DXCH_IP_EXCEPTION_TYPE_ENT
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_STATE             - on invalid hardware value read
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpExceptionCommandGet
(
    IN GT_U8                            devNum,
    IN CPSS_DXCH_IP_EXCEPTION_TYPE_ENT  exceptionType,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT CPSS_PACKET_CMD_ENT             *exceptionCmdPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpExceptionCommandGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, exceptionType, protocolStack, exceptionCmdPtr));

    rc = internal_cpssDxChIpExceptionCommandGet(devNum, exceptionType, protocolStack, exceptionCmdPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, exceptionType, protocolStack, exceptionCmdPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpHeaderErrorMaskSet
*
* DESCRIPTION:
*       Mask or unmask an IP header error.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum              - the device number
*       ipHeaderErrorType   - the IP header error type
*       protocolStack       - whether to mask/unmask the error for IPv4 or IPv6
*       prefixType          - whether to mask/unmask the error for unicast or
*                             multicast
*       mask                - GT_TRUE: mask the error
*                             GT_FALSE: unmask the error
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpHeaderErrorMaskSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_IP_HEADER_ERROR_ENT        ipHeaderErrorType,
    IN CPSS_IP_PROTOCOL_STACK_ENT           protocolStack,
    IN CPSS_UNICAST_MULTICAST_ENT           prefixType,
    IN GT_BOOL                              mask
)
{
    GT_U32      regAddr;
    GT_U32      offset;
    GT_U32      value;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
          CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if ((prefixType != CPSS_UNICAST_E) && (prefixType != CPSS_MULTICAST_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_CHECKSUM_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 0 : 1);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 2 : 3);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 4 : 5);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 6 : 7);
                    break;

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_IP_PROTOCOL_IPV6_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 8 : 9);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 10 : 11);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 12 : 13);
                    break;

                /* Checksum does not exist in IPv6 */
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).preRouteExceptionMasks;
    value = BOOL2BIT_MAC(mask);

    return prvCpssHwPpSetRegField(devNum, regAddr, offset, 1, value);
}

/*******************************************************************************
* cpssDxChIpHeaderErrorMaskSet
*
* DESCRIPTION:
*       Mask or unmask an IP header error.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum              - the device number
*       ipHeaderErrorType   - the IP header error type
*       protocolStack       - whether to mask/unmask the error for IPv4 or IPv6
*       prefixType          - whether to mask/unmask the error for unicast or
*                             multicast
*       mask                - GT_TRUE: mask the error
*                             GT_FALSE: unmask the error
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*******************************************************************************/
GT_STATUS cpssDxChIpHeaderErrorMaskSet
(
    IN GT_U8                                devNum,
    IN CPSS_DXCH_IP_HEADER_ERROR_ENT        ipHeaderErrorType,
    IN CPSS_IP_PROTOCOL_STACK_ENT           protocolStack,
    IN CPSS_UNICAST_MULTICAST_ENT           prefixType,
    IN GT_BOOL                              mask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpHeaderErrorMaskSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipHeaderErrorType, protocolStack, prefixType, mask));

    rc = internal_cpssDxChIpHeaderErrorMaskSet(devNum, ipHeaderErrorType, protocolStack, prefixType, mask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipHeaderErrorType, protocolStack, prefixType, mask));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpHeaderErrorMaskGet
*
* DESCRIPTION:
*       Get the masking status of an IP header error.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum              - the device number
*       ipHeaderErrorType   - the IP header error type
*       protocolStack       - whether to check the masking status for IPv4 or IPv6
*       prefixType          - whether to check the masking status for unicast or
*                             multicast
*
* OUTPUTS:
*       maskPtr             - GT_TRUE: mask the error
*                             GT_FALSE: unmask the error
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpHeaderErrorMaskGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_IP_HEADER_ERROR_ENT       ipHeaderErrorType,
    IN  CPSS_IP_PROTOCOL_STACK_ENT          protocolStack,
    IN  CPSS_UNICAST_MULTICAST_ENT          prefixType,
    OUT GT_BOOL                             *maskPtr
)
{
    GT_U32      regAddr;
    GT_U32      offset;
    GT_U32      value;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
          CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(maskPtr);

    if ((prefixType != CPSS_UNICAST_E) && (prefixType != CPSS_MULTICAST_E))
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_CHECKSUM_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 0 : 1);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 2 : 3);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 4 : 5);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 6 : 7);
                    break;

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        case CPSS_IP_PROTOCOL_IPV6_E:
            switch (ipHeaderErrorType)
            {
                case CPSS_DXCH_IP_HEADER_ERROR_VERSION_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 8 : 9);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_LENGTH_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 10 : 11);
                    break;

                case CPSS_DXCH_IP_HEADER_ERROR_SIP_DIP_ENT:
                    offset = ((prefixType == CPSS_UNICAST_E) ? 12 : 13);
                    break;

                /* Checksum does not exist in IPv6 */
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            break;

        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_DXCH_REG1_UNIT_TTI_MAC(devNum).preRouteExceptionMasks;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &value);
    if (rc == GT_OK)
    {
        *maskPtr = BIT2BOOL_MAC(value);
    }
    return rc;
}

/*******************************************************************************
* cpssDxChIpHeaderErrorMaskGet
*
* DESCRIPTION:
*       Get the masking status of an IP header error.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum              - the device number
*       ipHeaderErrorType   - the IP header error type
*       protocolStack       - whether to check the masking status for IPv4 or IPv6
*       prefixType          - whether to check the masking status for unicast or
*                             multicast
*
* OUTPUTS:
*       maskPtr             - GT_TRUE: mask the error
*                             GT_FALSE: unmask the error
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       If the error is masked, then an IPv4/6 UC/MC header exception will not
*       be triggered for the relevant header error.
*
*******************************************************************************/
GT_STATUS cpssDxChIpHeaderErrorMaskGet
(
    IN  GT_U8                               devNum,
    IN  CPSS_DXCH_IP_HEADER_ERROR_ENT       ipHeaderErrorType,
    IN  CPSS_IP_PROTOCOL_STACK_ENT          protocolStack,
    IN  CPSS_UNICAST_MULTICAST_ENT          prefixType,
    OUT GT_BOOL                             *maskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpHeaderErrorMaskGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ipHeaderErrorType, protocolStack, prefixType, maskPtr));

    rc = internal_cpssDxChIpHeaderErrorMaskGet(devNum, ipHeaderErrorType, protocolStack, prefixType, maskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ipHeaderErrorType, protocolStack, prefixType, maskPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpUcRouteAgingModeSet
*
* DESCRIPTION:
*      Sets the global route aging modes.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       refreshEnable - Enables the global routing activity refresh mechanism
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpUcRouteAgingModeSet
(
    IN  GT_U8    devNum,
    IN  GT_BOOL  refreshEnable
)
{

    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    value;                /* value to write                     */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }


    /* update refreshEnable value */
    value = (refreshEnable == GT_TRUE) ? 1:0;
    rc = prvCpssHwPpSetRegField(devNum,regAddr,0,1,value);

    return rc;
}

/*******************************************************************************
* cpssDxChIpUcRouteAgingModeSet
*
* DESCRIPTION:
*      Sets the global route aging modes.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       refreshEnable - Enables the global routing activity refresh mechanism
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpUcRouteAgingModeSet
(
    IN  GT_U8    devNum,
    IN  GT_BOOL  refreshEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRouteAgingModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, refreshEnable));

    rc = internal_cpssDxChIpUcRouteAgingModeSet(devNum, refreshEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, refreshEnable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpUcRouteAgingModeGet
*
* DESCRIPTION:
*      Gets the global route aging modes.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*
* OUTPUTS:
*       refreshEnablePtr - Enables the global routing activity refresh mechanism
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpUcRouteAgingModeGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *refreshEnablePtr
)
{
    GT_U32    regAddr;              /* register address */
    GT_STATUS rc = GT_OK;           /* return code */
    GT_U32    hwValue;              /* hw value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(refreshEnablePtr);

    /* Get address of register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }

    /* get refreshEnable value */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,0,1,&hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    *refreshEnablePtr = (0 == hwValue) ? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpUcRouteAgingModeGet
*
* DESCRIPTION:
*      Gets the global route aging modes.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*
* OUTPUTS:
*       refreshEnablePtr - Enables the global routing activity refresh mechanism
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpUcRouteAgingModeGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *refreshEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRouteAgingModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, refreshEnablePtr));

    rc = internal_cpssDxChIpUcRouteAgingModeGet(devNum, refreshEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, refreshEnablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterSourceIdSet
*
* DESCRIPTION:
*      set the router source id assignmnet.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       ucMcSet       - whether to set it for unicast packets or multicast.
*       sourceId      - the assigned source id.
*       sourceIdMask  - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    return cpssDxChIpPortGroupRouterSourceIdSet(devNum,
                                                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                ucMcSet, sourceId, sourceIdMask);
}

/*******************************************************************************
* cpssDxChIpRouterSourceIdSet
*
* DESCRIPTION:
*      set the router source id assignmnet.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       ucMcSet       - whether to set it for unicast packets or multicast.
*       sourceId      - the assigned source id.
*       sourceIdMask  - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucMcSet, sourceId, sourceIdMask));

    rc = internal_cpssDxChIpRouterSourceIdSet(devNum, ucMcSet, sourceId, sourceIdMask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucMcSet, sourceId, sourceIdMask));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterSourceIdGet
*
* DESCRIPTION:
*      get the router source id.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       ucMcSet       - whether to set it for unicast packets or multicast.
*
* OUTPUTS:
*       sourceIdPtr     - the assigned source id.
*       sourceIdMaskPtr - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    return cpssDxChIpPortGroupRouterSourceIdGet(devNum,
                                                CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                ucMcSet, sourceIdPtr, sourceIdMaskPtr);
}

/*******************************************************************************
* cpssDxChIpRouterSourceIdGet
*
* DESCRIPTION:
*      get the router source id.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       ucMcSet       - whether to set it for unicast packets or multicast.
*
* OUTPUTS:
*       sourceIdPtr     - the assigned source id.
*       sourceIdMaskPtr - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucMcSet, sourceIdPtr, sourceIdMaskPtr));

    rc = internal_cpssDxChIpRouterSourceIdGet(devNum, ucMcSet, sourceIdPtr, sourceIdMaskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucMcSet, sourceIdPtr, sourceIdMaskPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupRouterSourceIdSet
*
* DESCRIPTION:
*      set the router source id assignmnet.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
*       ucMcSet       - whether to set it for unicast packets or multicast.
*       sourceId      - the assigned source id.
*       sourceIdMask  - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP               portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    offset;       /* register offset   */
    GT_U32    portGroupId;  /* the port group Id            */
    GT_U32    numOfBits;    /* number of bits to write to register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (sourceId > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_SRC_ID_MAC(devNum))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE &&
        CPSS_IP_MULTICAST_E == ucMcSet &&
        sourceIdMask >= BIT_12)
    {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    offset = 0; /* prevent compilation warning */
    if( CPSS_IP_UNICAST_E == ucMcSet )
    {
        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
            offset = 8;
            numOfBits = 12;
        }
        else
        {
            if( CPSS_PP_FAMILY_CHEETAH_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ctrlReg0;
                offset = 0;
            }
            else if ( (CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                      (((CPSS_PP_FAMILY_DXCH_XCAT_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                        (CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)) &&
                        (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                            PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode)) )
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
                offset = 0;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
                offset = 1;
            }
            numOfBits = 5;
        }

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
        {
            rc = prvCpssHwPpPortGroupSetRegField(
                devNum, portGroupId, regAddr,
                offset, numOfBits, sourceId);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
    }
    else if ( CPSS_IP_MULTICAST_E == ucMcSet )
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            offset = 12;
            numOfBits = 12;
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLMCSourceID;
        }
        else if( CPSS_PP_FAMILY_CHEETAH_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        else if ( (CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                  (((CPSS_PP_FAMILY_DXCH_XCAT_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                    (CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)) &&
                    (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                        PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode)) )
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
            numOfBits = 5;
        }

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
        {
            rc = prvCpssHwPpPortGroupSetRegField(
                devNum, portGroupId, regAddr,
                offset, numOfBits, sourceId);
            if (rc != GT_OK)
            {
                return rc;
            }

            if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                /* set the value for the 'mask' bits 0..11 */
                rc = prvCpssHwPpPortGroupSetRegField(
                    devNum, portGroupId, regAddr,
                    0, numOfBits, sourceIdMask);
                if (rc != GT_OK)
                {
                    return rc;
                }
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(
            devNum, portGroupsBmp, portGroupId)
    }
    else
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    return GT_OK;

}

/*******************************************************************************
* cpssDxChIpPortGroupRouterSourceIdSet
*
* DESCRIPTION:
*      set the router source id assignmnet.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
*       ucMcSet       - whether to set it for unicast packets or multicast.
*       sourceId      - the assigned source id.
*       sourceIdMask  - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupRouterSourceIdSet
(
    IN  GT_U8                           devNum,
    IN GT_PORT_GROUPS_BMP               portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    IN  GT_U32                          sourceId,
    IN  GT_U32                          sourceIdMask
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterSourceIdSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ucMcSet, sourceId, sourceIdMask));

    rc = internal_cpssDxChIpPortGroupRouterSourceIdSet(devNum, portGroupsBmp, ucMcSet, sourceId, sourceIdMask);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ucMcSet, sourceId, sourceIdMask));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupRouterSourceIdGet
*
* DESCRIPTION:
*      get the router source id assignmnet.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
*       ucMcSet       - whether to set it for unicast packets or multicast.
*
* OUTPUTS:
*       sourceIdPtr     - the assigned source id.
*       sourceIdMaskPtr - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    offset;       /* register offset   */
    GT_U32    portGroupId;  /* the port group Id            */
    GT_U32    numOfBits;    /* number of bits to read from register */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    CPSS_NULL_PTR_CHECK_MAC(sourceIdPtr);
    CPSS_NULL_PTR_CHECK_MAC(sourceIdMaskPtr);

    /* Get the first active port group id */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(devNum, portGroupsBmp,
                                                        portGroupId);

    offset = 0; /* prevent compilation warning */
    if( CPSS_IP_UNICAST_E == ucMcSet )
    {
        if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
            offset = 8;
            numOfBits = 12;
        }
        else
        {
            if( CPSS_PP_FAMILY_CHEETAH_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ctrlReg0;
            }
            else if ( (CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                      (((CPSS_PP_FAMILY_DXCH_XCAT_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                        (CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)) &&
                        (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                            PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode)) )
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ucRoutingEngineConfigurationReg;
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
                offset = 1;
            }
            numOfBits = 5;
        }

        rc = prvCpssHwPpPortGroupGetRegField(
            devNum, portGroupId, regAddr,
            offset, numOfBits, sourceIdPtr);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else if ( CPSS_IP_MULTICAST_E == ucMcSet )
    {

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /* assumption : the value for the 'mask' bits 0..11 was already set by application / cpssInit */
            offset = 12;
            numOfBits = 12;
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLMCSourceID;
        }
        else
        {
            if( CPSS_PP_FAMILY_CHEETAH_E == PRV_CPSS_PP_MAC(devNum)->devFamily )
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            else if ( (CPSS_PP_FAMILY_DXCH_XCAT2_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                      (((CPSS_PP_FAMILY_DXCH_XCAT_E == PRV_CPSS_PP_MAC(devNum)->devFamily) ||
                        (CPSS_PP_FAMILY_DXCH_XCAT3_E == PRV_CPSS_PP_MAC(devNum)->devFamily)) &&
                        (CPSS_DXCH_POLICY_BASED_ROUTING_ONLY_E ==
                            PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.ip.routingMode)) )
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            else
            {
                regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
            }

            numOfBits = 5;
        }

        rc = prvCpssHwPpPortGroupGetRegField(
            devNum, portGroupId, regAddr,
            offset, numOfBits, sourceIdPtr);
        if (rc != GT_OK)
        {
            return rc;
        }

        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            /* get the value for the 'mask' bits 0..11 */
            rc = prvCpssHwPpPortGroupGetRegField(
                devNum, portGroupId, regAddr,
                0, numOfBits, sourceIdMaskPtr);
            if (rc != GT_OK)
            {
                return rc;
            }
        }
    }
    else
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpPortGroupRouterSourceIdGet
*
* DESCRIPTION:
*      get the router source id assignmnet.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
*       ucMcSet       - whether to set it for unicast packets or multicast.
*
* OUTPUTS:
*       sourceIdPtr     - the assigned source id.
*       sourceIdMaskPtr - the assigned source id mask,
*                       relevant for ucMcSet CPSS_IP_MULTICAST_E.
*                       (APPLICABLE DEVICES: Bobcat2; Caelum; Bobcat3)
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupRouterSourceIdGet
(
    IN  GT_U8                           devNum,
    IN  GT_PORT_GROUPS_BMP              portGroupsBmp,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT   ucMcSet,
    OUT GT_U32                          *sourceIdPtr,
    OUT GT_U32                          *sourceIdMaskPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterSourceIdGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, ucMcSet, sourceIdPtr, sourceIdMaskPtr));

    rc = internal_cpssDxChIpPortGroupRouterSourceIdGet(devNum, portGroupsBmp, ucMcSet, sourceIdPtr, sourceIdMaskPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, ucMcSet, sourceIdPtr, sourceIdMaskPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterSourceIdOverrideEnableSet
*
* DESCRIPTION:
*     Enable/Disable overriding of source id by routing engine.
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum   - the device number
*       enable   - GT_TRUE  - enable override
*                  GT_FALSE - disable override
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Lion2 device: applicable starting from revision B1
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterSourceIdOverrideEnableSet
(
    IN  GT_U8                           devNum,
    IN  GT_BOOL                         enable
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    hwData;       /* HW data           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);
    if (PRV_CPSS_DXCH_LION2_B1_AND_ABOVE_CHECK_MAC(devNum) == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMetalFix;
    hwData = BOOL2BIT_MAC(enable);

    rc = prvCpssHwPpSetRegField(
        devNum, regAddr,
        0 /*offset*/, 1/*fieldLength*/, hwData);

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterSourceIdOverrideEnableSet
*
* DESCRIPTION:
*     Enable/Disable overriding of source id by routing engine.
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum   - the device number
*       enable   - GT_TRUE  - enable override
*                  GT_FALSE - disable override
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Lion2 device: applicable starting from revision B1
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterSourceIdOverrideEnableSet
(
    IN  GT_U8                           devNum,
    IN  GT_BOOL                         enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdOverrideEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpRouterSourceIdOverrideEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterSourceIdOverrideEnableGet
*
* DESCRIPTION:
*     Get Enable/Disable status of overriding of source id
*     by routing engine.
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       enablePtr - (pointer to)enable:
*                    GT_TRUE  - enable override
*                    GT_FALSE - disable override
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_BAD_PTR               - on NULL pointer
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Lion2 device: applicable starting from revision B1
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterSourceIdOverrideEnableGet
(
    IN  GT_U8                           devNum,
    OUT GT_BOOL                         *enablePtr
)
{
    GT_U32    regAddr;      /* register address  */
    GT_STATUS rc;           /* return code       */
    GT_U32    hwData;       /* HW data           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);
    if (PRV_CPSS_DXCH_LION2_B1_AND_ABOVE_CHECK_MAC(devNum) == 0)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMetalFix;

    rc = prvCpssHwPpGetRegField(
        devNum, regAddr,
        0 /*offset*/, 1/*fieldLength*/, &hwData);
    if (rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(hwData);

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpRouterSourceIdOverrideEnableGet
*
* DESCRIPTION:
*     Get Enable/Disable status of overriding of source id
*     by routing engine.
*
* APPLICABLE DEVICES:
*        Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       enablePtr - (pointer to)enable:
*                    GT_TRUE  - enable override
*                    GT_FALSE - disable override
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_BAD_PTR               - on NULL pointer
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Lion2 device: applicable starting from revision B1
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterSourceIdOverrideEnableGet
(
    IN  GT_U8                           devNum,
    OUT GT_BOOL                         *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterSourceIdOverrideEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpRouterSourceIdOverrideEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet
*
* DESCRIPTION:
*      Sets the multi-target TC queue assigned to multi-target Control
*      packets and to RPF Fail packets where the RPF Fail Command is assigned
*      from the MLL entry.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                    - the device number
*       ctrlMultiTargetTCQueue    - The multi-target TC queue for control
*                                   traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
*       failRpfMultiTargetTCQueue - the multi-target TC queue for fail rpf
*                                   traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  ctrlMultiTargetTCQueue,
    IN  GT_U32  failRpfMultiTargetTCQueue
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    /* update ctrlMultiTargetTCQueue value */
    if(ctrlMultiTargetTCQueue > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(failRpfMultiTargetTCQueue > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesGlobalReg;
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr, 16,4,ctrlMultiTargetTCQueue | (failRpfMultiTargetTCQueue << 2));
    return rc;
}

/*******************************************************************************
* cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet
*
* DESCRIPTION:
*      Sets the multi-target TC queue assigned to multi-target Control
*      packets and to RPF Fail packets where the RPF Fail Command is assigned
*      from the MLL entry.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                    - the device number
*       ctrlMultiTargetTCQueue    - The multi-target TC queue for control
*                                   traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
*       failRpfMultiTargetTCQueue - the multi-target TC queue for fail rpf
*                                   traffic. There are 4 possible queues (APPLICABLE RANGES: 0..3)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*******************************************************************************/
GT_STATUS cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  ctrlMultiTargetTCQueue,
    IN  GT_U32  failRpfMultiTargetTCQueue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ctrlMultiTargetTCQueue, failRpfMultiTargetTCQueue));

    rc = internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueSet(devNum, ctrlMultiTargetTCQueue, failRpfMultiTargetTCQueue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ctrlMultiTargetTCQueue, failRpfMultiTargetTCQueue));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet
*
* DESCRIPTION:
*      Gets the multi-target TC queue assigned to multi-target Control
*      packets and to RPF Fail packets where the RPF Fail Command is assigned
*      from the MLL entry.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                    - the device number
*
* OUTPUTS:
*       ctrlMultiTargetTCQueuePtr    - The multi-target TC queue for control
*                                      traffic. There are 4 possible queues
*       failRpfMultiTargetTCQueuePtr - the multi-target TC queue for fail rpf
*                                      traffic. There are 4 possible queues
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL Ptr
*
* COMMENTS:
*       A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet
(
    IN   GT_U8   devNum,
    OUT  GT_U32  *ctrlMultiTargetTCQueuePtr,
    OUT  GT_U32  *failRpfMultiTargetTCQueuePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(ctrlMultiTargetTCQueuePtr);
    CPSS_NULL_PTR_CHECK_MAC(failRpfMultiTargetTCQueuePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesGlobalConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesGlobalReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,18,2,failRpfMultiTargetTCQueuePtr);
    if(GT_OK != rc)
        return rc;

    rc = prvCpssHwPpGetRegField(devNum,regAddr, 16,2,ctrlMultiTargetTCQueuePtr);

    return rc;
}

/*******************************************************************************
* cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet
*
* DESCRIPTION:
*      Gets the multi-target TC queue assigned to multi-target Control
*      packets and to RPF Fail packets where the RPF Fail Command is assigned
*      from the MLL entry.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                    - the device number
*
* OUTPUTS:
*       ctrlMultiTargetTCQueuePtr    - The multi-target TC queue for control
*                                      traffic. There are 4 possible queues
*       failRpfMultiTargetTCQueuePtr - the multi-target TC queue for fail rpf
*                                      traffic. There are 4 possible queues
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL Ptr
*
* COMMENTS:
*       A packet is considered as a multi-target control if it is a FROM_CPU DSA
*       Tagged with DSA<Use_Vidx> = 1 or a multi-target packet that is also to
*       be mirrored to the CPU
*
*******************************************************************************/
GT_STATUS cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet
(
    IN   GT_U8   devNum,
    OUT  GT_U32  *ctrlMultiTargetTCQueuePtr,
    OUT  GT_U32  *failRpfMultiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ctrlMultiTargetTCQueuePtr, failRpfMultiTargetTCQueuePtr));

    rc = internal_cpssDxChIpFailRpfCtrlTrafficMultiTargetTCQueueGet(devNum, ctrlMultiTargetTCQueuePtr, failRpfMultiTargetTCQueuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ctrlMultiTargetTCQueuePtr, failRpfMultiTargetTCQueuePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapSet
*
* DESCRIPTION:
*     Sets the Qos Profile to multi-target TC queue mapping.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       qosProfile         - QOS Profile index
*       multiTargetTCQueue - the multi-target TC queue. There are 4 possible
*                            queues.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    IN  GT_U32  multiTargetTCQueue
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;               /* value to write                     */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    PRV_CPSS_DXCH_QOS2MT_ENTRY_CHECK_MAC(devNum,qosProfile);

    /* get reg_addr and offset within the address from qosProfile value */
    /* note that each QOS profile need 2 bits for Queue index so there  */
    /* are 16 entries in each 32bit register                            */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).
            mcLinkedListMLLTables.qoSProfileToMultiTargetTCQueuesReg[qosProfile/16];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.qoSProfile2MTTCQueuesMapTable[(qosProfile/16)];
    }

    offset = (qosProfile % 16) * 2;

    /* write mtTcQueue value */
    if( multiTargetTCQueue >= BIT_2)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,2,multiTargetTCQueue);

    return rc;
}

/*******************************************************************************
* cpssDxChIpQosProfileToMultiTargetTCQueueMapSet
*
* DESCRIPTION:
*     Sets the Qos Profile to multi-target TC queue mapping.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       qosProfile         - QOS Profile index
*       multiTargetTCQueue - the multi-target TC queue. There are 4 possible
*                            queues.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpQosProfileToMultiTargetTCQueueMapSet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    IN  GT_U32  multiTargetTCQueue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToMultiTargetTCQueueMapSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, multiTargetTCQueue));

    rc = internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapSet(devNum, qosProfile, multiTargetTCQueue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, multiTargetTCQueue));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapGet
*
* DESCRIPTION:
*     gets the Qos Profile to multi-target TC queue mapping.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       qosProfile         - QOS Profile index
*
* OUTPUTS:
*       multiTargetTCQueuePtr - the multi-target TC queue. There are 4 possible
*                               queues.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    OUT GT_U32  *multiTargetTCQueuePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;               /* value to write                     */

    /* check parameters */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(multiTargetTCQueuePtr);

    PRV_CPSS_DXCH_QOS2MT_ENTRY_CHECK_MAC(devNum, qosProfile);

    /* get reg_addr and offset within the address from qosProfile value */
    /* note that each QOS profile need 2 bits for Queue index so there  */
    /* are 16 entires in each 32bit register                            */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).
            mcLinkedListMLLTables.qoSProfileToMultiTargetTCQueuesReg[qosProfile/16];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.qoSProfile2MTTCQueuesMapTable[(qosProfile/16)];
    }

    offset = (qosProfile % 16) * 2;

    rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,2,multiTargetTCQueuePtr);

    return rc;
}

/*******************************************************************************
* cpssDxChIpQosProfileToMultiTargetTCQueueMapGet
*
* DESCRIPTION:
*     gets the Qos Profile to multi-target TC queue mapping.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       qosProfile         - QOS Profile index
*
* OUTPUTS:
*       multiTargetTCQueuePtr - the multi-target TC queue. There are 4 possible
*                               queues.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpQosProfileToMultiTargetTCQueueMapGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  qosProfile,
    OUT GT_U32  *multiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToMultiTargetTCQueueMapGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, multiTargetTCQueuePtr));

    rc = internal_cpssDxChIpQosProfileToMultiTargetTCQueueMapGet(devNum, qosProfile, multiTargetTCQueuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, multiTargetTCQueuePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpTcDpToMultiTargetTcQueueMapSet
*
* DESCRIPTION:
*     Sets the packet's {TC,DP} to multi-target TC queue mapping.
*     (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum             - the device number
*       tc                 - traffic class assigned to the packet.
*                            (received on a cascade port configured for extended Global QoS mode)
*                            (APPLICABLE RANGES: 0..7).
*       dp                 - drop precedence assigned to the packet for tail drop.
*                           (received on a cascade port configured for extended Global QoS mode)
*       multiTargetTCQueue - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpTcDpToMultiTargetTcQueueMapSet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    IN  GT_U32             multiTargetTCQueue
)
{
    GT_U32 dpValue;
    GT_U32 index;
    GT_U32 regAddr;
    GT_U32 fieldOffset;
    GT_U32 fieldLength;
    PRV_CPSS_DXCH_PP_REGS_ADDR_VER1_STC *regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum);
    /* check input parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_COS_DP_TO_HW_CHECK_AND_CONVERT_MAC(
        devNum, dp, dpValue);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(multiTargetTCQueue);
    /* build 5 bit {TC,DP) index */
    index = 0;
    index = (tc << 2) | dpValue;
    /* each register incorporates 16 mc priority queue values */
    regAddr = regsAddrPtr->MLL.mcLinkedListMLLTables.extQoSModeMCQueueSelectionReg[index/16];
    fieldLength = 2;
    fieldOffset = (index%16)*fieldLength;
    return prvCpssHwPpSetRegField(devNum, regAddr, fieldOffset, fieldLength, multiTargetTCQueue);
}

/*******************************************************************************
* cpssDxChIpTcDpToMultiTargetTcQueueMapSet
*
* DESCRIPTION:
*     Sets the packet's {TC,DP} to multi-target TC queue mapping.
*     (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum             - the device number
*       tc                 - traffic class assigned to the packet.
*                            (received on a cascade port configured for extended Global QoS mode)
*                            (APPLICABLE RANGES: 0..7).
*       dp                 - drop precedence assigned to the packet for tail drop.
*                           (received on a cascade port configured for extended Global QoS mode)
*       multiTargetTCQueue - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpTcDpToMultiTargetTcQueueMapSet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    IN  GT_U32             multiTargetTCQueue
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpTcDpToMultiTargetTcQueueMapSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tc, dp, multiTargetTCQueue));

    rc = internal_cpssDxChIpTcDpToMultiTargetTcQueueMapSet(devNum, tc, dp, multiTargetTCQueue);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tc, dp, multiTargetTCQueue));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpTcDpToMultiTargetTcQueueMapGet
*
* DESCRIPTION:
*     Gets the packet's {TC,DP} to multi-target TC queue mapping.
*     (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum             - the device number
*       tc                 - traffic class assigned to the packet.
*                            (received on a cascade port configured for extended Global QoS mode)
*                            (APPLICABLE RANGES: 0..7).
*       dp                 - drop precedence assigned to the packet for tail drop.
*                           (received on a cascade port configured for extended Global QoS mode)
*
* OUTPUTS:
*       multiTargetTCQueuePtr - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpTcDpToMultiTargetTcQueueMapGet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    OUT  GT_U32            *multiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    GT_U32 dpValue;
    GT_U32 index;
    GT_U32 regAddr;
    GT_U32 fieldOffset;
    GT_U32 fieldLength;
    GT_U32 fieldValue;
    PRV_CPSS_DXCH_PP_REGS_ADDR_VER1_STC *regsAddrPtr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum);
    /* check input parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_COS_DP_TO_HW_CHECK_AND_CONVERT_MAC(
        devNum, dp, dpValue);
    PRV_CPSS_DXCH_COS_CHECK_TC_MAC(tc);
    CPSS_NULL_PTR_CHECK_MAC(multiTargetTCQueuePtr);

    /* build 5 bit {TC,DP) index */
    index = 0;
    index = (tc << 2) | dpValue;
    /* each register incorporates 16 mc priority queue values */
    regAddr = regsAddrPtr->MLL.mcLinkedListMLLTables.extQoSModeMCQueueSelectionReg[index/16];
    fieldLength = 2;
    fieldOffset = (index%16)*fieldLength;
    rc =  prvCpssHwPpGetRegField(devNum, regAddr, fieldOffset, fieldLength, &fieldValue);
    if (rc != GT_OK)
    {
        return rc;
    }
    *multiTargetTCQueuePtr = fieldValue;
    return rc;
}

/*******************************************************************************
* cpssDxChIpTcDpToMultiTargetTcQueueMapGet
*
* DESCRIPTION:
*     Gets the packet's {TC,DP} to multi-target TC queue mapping.
*     (It is used for packets received on cascade ports configured to work in extended QoS mode)
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum             - the device number
*       tc                 - traffic class assigned to the packet.
*                            (received on a cascade port configured for extended Global QoS mode)
*                            (APPLICABLE RANGES: 0..7).
*       dp                 - drop precedence assigned to the packet for tail drop.
*                           (received on a cascade port configured for extended Global QoS mode)
*
* OUTPUTS:
*       multiTargetTCQueuePtr - the multi-target TC queue. (APPLICABLE RANGES: 0..3).
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpTcDpToMultiTargetTcQueueMapGet
(
    IN  GT_U8              devNum,
    IN  GT_U32             tc,
    IN  CPSS_DP_LEVEL_ENT  dp,
    OUT  GT_U32            *multiTargetTCQueuePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpTcDpToMultiTargetTcQueueMapGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tc, dp, multiTargetTCQueuePtr));

    rc = internal_cpssDxChIpTcDpToMultiTargetTcQueueMapGet(devNum, tc, dp, multiTargetTCQueuePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tc, dp, multiTargetTCQueuePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetQueueFullDropCntGet
*
* DESCRIPTION:
*      Get the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetQueueFullDropCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *dropPktsPtr
)
{
    return cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                             dropPktsPtr);
}

/*******************************************************************************
* cpssDxChIpMultiTargetQueueFullDropCntGet
*
* DESCRIPTION:
*      Get the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetQueueFullDropCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetQueueFullDropCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPktsPtr));

    rc = internal_cpssDxChIpMultiTargetQueueFullDropCntGet(devNum, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetQueueFullDropCntSet
*
* DESCRIPTION:
*      set the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum      - the device number
*       dropPkts    - the counter value to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetQueueFullDropCntSet
(
    IN GT_U8     devNum,
    IN GT_U32    dropPkts
)
{
    return cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                             dropPkts);
}

/*******************************************************************************
* cpssDxChIpMultiTargetQueueFullDropCntSet
*
* DESCRIPTION:
*      set the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum      - the device number
*       dropPkts    - the counter value to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetQueueFullDropCntSet
(
    IN GT_U8     devNum,
    IN GT_U32    dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetQueueFullDropCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPkts));

    rc = internal_cpssDxChIpMultiTargetQueueFullDropCntSet(devNum, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetTCQueueSchedModeSet
*
* DESCRIPTION:
*      sets the multi-target TC queue scheduling mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       multiTargetTcQueue - the multi-target TC queue. There are 4 possible
*                            queues.
*       schedulingMode     - the scheduling mode.
*       queueWeight        - the queue weight for SDWRR scheduler (APPLICABLE RANGES: 0..255)
*                           (relvant only if schedMode =
*                            CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetTCQueueSchedModeSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    IN  CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT schedulingMode,
    IN  GT_U32                                  queueWeight
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32     value,offset;      /* value to write */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesWeightConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesWeightReg;
    }

    if(multiTargetTcQueue > 3 )
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    /*if schedMode = CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E,
            write weight value */
    if (schedulingMode == CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E)
    {
        /* find offset of weight field according to mtTcQueue */
        offset = multiTargetTcQueue *8;

        if(GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(queueWeight,8))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
        /* write weight value */
        rc = prvCpssHwPpSetRegField(devNum,regAddr,
                             offset,8,queueWeight);
        if (rc != GT_OK)
            return rc;
    }

    /* find offset of schedulingMode field according to multiTargetTcQueue */
    offset = multiTargetTcQueue *1;

    /* find enable/disable value to write according to schedulingMode */
    switch (schedulingMode)
    {
        case CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E:
            value = 0;
            break;
        case CPSS_DXCH_IP_MT_TC_QUEUE_SP_SCHED_MODE_E:
            value = 1;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesStrictPriorityEnableConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesSpEnableReg;
    }

    /* write schedulingMode value */
    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,1,value);

    return rc;
}

/*******************************************************************************
* cpssDxChIpMultiTargetTCQueueSchedModeSet
*
* DESCRIPTION:
*      sets the multi-target TC queue scheduling mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       multiTargetTcQueue - the multi-target TC queue. There are 4 possible
*                            queues.
*       schedulingMode     - the scheduling mode.
*       queueWeight        - the queue weight for SDWRR scheduler (APPLICABLE RANGES: 0..255)
*                           (relvant only if schedMode =
*                            CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetTCQueueSchedModeSet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    IN  CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT schedulingMode,
    IN  GT_U32                                  queueWeight
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetTCQueueSchedModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetTcQueue, schedulingMode, queueWeight));

    rc = internal_cpssDxChIpMultiTargetTCQueueSchedModeSet(devNum, multiTargetTcQueue, schedulingMode, queueWeight);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetTcQueue, schedulingMode, queueWeight));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetTCQueueSchedModeGet
*
* DESCRIPTION:
*      gets the multi-target TC queue scheduling mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       multiTargetTcQueue - the multi-target TC queue. There are 4 possible
*                            queues.
*
* OUTPUTS:
*       schedulingModePtr     - the scheduling mode.
*       queueWeightPtr        - the queue weight for SDWRR scheduler
*                               (relvant only if schedMode =
*                               CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetTCQueueSchedModeGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    OUT CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT *schedulingModePtr,
    OUT GT_U32                                  *queueWeightPtr
)
{
    GT_U32     regAddr;              /* register address  */
    GT_STATUS  rc = GT_OK;           /* return code  */
    GT_U32     hwValue = 0;              /* hw value */
    GT_U32     offset = 0;               /* offset */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(schedulingModePtr);
    CPSS_NULL_PTR_CHECK_MAC(queueWeightPtr);

    if(multiTargetTcQueue > 3 )
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    /* read schedulingMode value */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
            multitargetTCQueuesStrictPriorityEnableConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesSpEnableReg;
    }

    /* find offset of schedulingMode field according to multiTargetTcQueue */
    offset = multiTargetTcQueue *1;

    rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,1,&hwValue);
    if (rc != GT_OK)
        return rc;

    switch (hwValue)
    {
        case 0:
            *schedulingModePtr = CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E;
            break;
        case 1:
            *schedulingModePtr = CPSS_DXCH_IP_MT_TC_QUEUE_SP_SCHED_MODE_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /*if schedMode = CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E,
            read weight value */
    if ( *schedulingModePtr == CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E)
    {
        if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
        {
            regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetTCQueuesAndArbitrationConfig.
                multitargetTCQueuesWeightConfig;
        }
        else
        {
            regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtTcQueuesWeightReg;
        }

        /* find offset of weight field according to mtTcQueue */
        offset = multiTargetTcQueue *8;

        /* read weight value */
        rc = prvCpssHwPpGetRegField(devNum,regAddr,
                             offset,8,queueWeightPtr);
        if (rc != GT_OK)
            return rc;
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpMultiTargetTCQueueSchedModeGet
*
* DESCRIPTION:
*      gets the multi-target TC queue scheduling mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*       multiTargetTcQueue - the multi-target TC queue. There are 4 possible
*                            queues.
*
* OUTPUTS:
*       schedulingModePtr     - the scheduling mode.
*       queueWeightPtr        - the queue weight for SDWRR scheduler
*                               (relvant only if schedMode =
*                               CPSS_DXCH_IP_MT_TC_QUEUE_SDWRR_SCHED_MODE_E).
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetTCQueueSchedModeGet
(
    IN  GT_U8                                   devNum,
    IN  GT_U32                                  multiTargetTcQueue,
    OUT CPSS_DXCH_IP_MT_TC_QUEUE_SCHED_MODE_ENT *schedulingModePtr,
    OUT GT_U32                                  *queueWeightPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetTCQueueSchedModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetTcQueue, schedulingModePtr, queueWeightPtr));

    rc = internal_cpssDxChIpMultiTargetTCQueueSchedModeGet(devNum, multiTargetTcQueue, schedulingModePtr, queueWeightPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetTcQueue, schedulingModePtr, queueWeightPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpBridgeServiceEnable
*
* DESCRIPTION:
*      enable/disable a router bridge service.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum            - the device number
*       bridgeService     - the router bridge service
*       enableDisableMode - Enable/Disable mode of this function (weather
*                           to enable/disable for ipv4/ipv6/arp)
*       enableService     - weather to enable the service for the above more.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpBridgeServiceEnable
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    IN  GT_BOOL                                             enableService
)
{
    GT_U32      value;      /* value to write */
    GT_STATUS   rc;         /* function return code */

    GT_U32    regAddr;              /* register address                   */
    GT_U32    offset = 0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }

    value = (enableService == GT_TRUE) ? 1:0;

    /* update enable values according to bridgeService */
    switch (bridgeService)
    {
        case CPSS_DXCH_IP_HEADER_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 14;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 15;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E: /* Not Valid value. */

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_UC_RPF_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 8;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 10;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 9;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_SIP_SA_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 11;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 13;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 12;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

    case CPSS_DXCH_IP_SIP_FILTER_BRG_SERVICE_E:
        switch(enableDisableMode)
        {
            case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                /* update ipv4Enable value */
                offset = 16;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                /* update ipv6Enable value */
                offset = 18;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                /* update arpEnable value */
                offset = 17;
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,1,value);
    return rc;
}

/*******************************************************************************
* cpssDxChIpBridgeServiceEnable
*
* DESCRIPTION:
*      enable/disable a router bridge service.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum            - the device number
*       bridgeService     - the router bridge service
*       enableDisableMode - Enable/Disable mode of this function (weather
*                           to enable/disable for ipv4/ipv6/arp)
*       enableService     - weather to enable the service for the above more.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpBridgeServiceEnable
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    IN  GT_BOOL                                             enableService
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpBridgeServiceEnable);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeService, enableDisableMode, enableService));

    rc = internal_cpssDxChIpBridgeServiceEnable(devNum, bridgeService, enableDisableMode, enableService);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeService, enableDisableMode, enableService));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpBridgeServiceEnableGet
*
* DESCRIPTION:
*      enable/disable a router bridge service.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum            - the device number
*       bridgeService     - the router bridge service
*       enableDisableMode - Enable/Disable mode of this function (weather
*                           to enable/disable for ipv4/ipv6/arp)
*
* OUTPUTS:
*       enableServicePtr  - weather to enable the service for the above more.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpBridgeServiceEnableGet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    OUT GT_BOOL                                             *enableServicePtr
)
{
    GT_U32      hwValue;    /* read hwValue  */
    GT_STATUS   rc;         /* function return code */

    GT_U32    regAddr;              /* register address */
    GT_U32    offset = 0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(enableServicePtr);


    /* update enable values according to bridgeService */
    switch (bridgeService)
    {
        case CPSS_DXCH_IP_HEADER_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 14;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 15;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E: /* Not Valid value. */

                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_UC_RPF_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 8;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 10;
                    break;

                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 9;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

        case CPSS_DXCH_IP_SIP_SA_CHECK_BRG_SERVICE_E:
            switch(enableDisableMode)
            {
                case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                    /* update ipv4Enable value */
                    offset = 11;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                    /* update ipv6Enable value */
                    offset = 13;
                    break;
                case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                    /* update arpEnable value */
                    offset = 12;
                    break;
                default:
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
        break;

    case CPSS_DXCH_IP_SIP_FILTER_BRG_SERVICE_E:
        switch(enableDisableMode)
        {
            case CPSS_DXCH_IP_BRG_SERVICE_IPV4_ENABLE_DISABLE_E:
                /* update ipv4Enable value */
                offset = 16;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_IPV6_ENABLE_DISABLE_E:
                /* update ipv6Enable value */
                offset = 18;
                break;

            case CPSS_DXCH_IP_BRG_SERVICE_ARP_ENABLE_DISABLE_E:
                /* update arpEnable value */
                offset = 17;
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 1, &hwValue);

    *enableServicePtr = (0 == hwValue) ? GT_FALSE : GT_TRUE;

    return rc;
}

/*******************************************************************************
* cpssDxChIpBridgeServiceEnableGet
*
* DESCRIPTION:
*      enable/disable a router bridge service.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum            - the device number
*       bridgeService     - the router bridge service
*       enableDisableMode - Enable/Disable mode of this function (weather
*                           to enable/disable for ipv4/ipv6/arp)
*
* OUTPUTS:
*       enableServicePtr  - weather to enable the service for the above more.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpBridgeServiceEnableGet
(
    IN  GT_U8                                               devNum,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENT                        bridgeService,
    IN  CPSS_DXCH_IP_BRG_SERVICE_ENABLE_DISABLE_MODE_ENT    enableDisableMode,
    OUT GT_BOOL                                             *enableServicePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpBridgeServiceEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, bridgeService, enableDisableMode, enableServicePtr));

    rc = internal_cpssDxChIpBridgeServiceEnableGet(devNum, bridgeService, enableDisableMode, enableServicePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, bridgeService, enableDisableMode, enableServicePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet
*
* DESCRIPTION:
*      Set exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                    - the device number
*       portGroupsBmp             - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       routerBridgedExceptionPkts - the counter value to set
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               routerBridgedExceptionPkts
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerBridgedPktsExceptionCntr.routerBridgedPktExceptionsCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerBridgedPktExcptCnt;
    }

    /* set the counter */
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, routerBridgedExceptionPkts);

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet
*
* DESCRIPTION:
*      Set exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                    - the device number
*       portGroupsBmp             - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       routerBridgedExceptionPkts - the counter value to set
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               routerBridgedExceptionPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, routerBridgedExceptionPkts));

    rc = internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet(devNum, portGroupsBmp, routerBridgedExceptionPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, routerBridgedExceptionPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet
*
* DESCRIPTION:
*      Get exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                       exception  packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_BAD_PTR               - on illegal pointer value
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *routerBridgedExceptionPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    CPSS_NULL_PTR_CHECK_MAC(routerBridgedExceptionPktsPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerBridgedPktsExceptionCntr.routerBridgedPktExceptionsCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerBridgedPktExcptCnt;
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum,
                                                portGroupsBmp,
                                                regAddr,
                                                0,
                                                32,
                                                routerBridgedExceptionPktsPtr,
                                                NULL);
    return rc;
}

/*******************************************************************************
* cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet
*
* DESCRIPTION:
*      Get exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                       exception  packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_BAD_PTR               - on illegal pointer value
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *routerBridgedExceptionPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, routerBridgedExceptionPktsPtr));

    rc = internal_cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet(devNum, portGroupsBmp, routerBridgedExceptionPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, routerBridgedExceptionPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterBridgedPacketsExceptionCntGet
*
* DESCRIPTION:
*      Get exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*
* OUTPUTS:
*       routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                       exception  packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_BAD_PTR               - on illegal pointer value
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterBridgedPacketsExceptionCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *routerBridgedExceptionPktsPtr
)
{
    return cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntGet(devNum,
                                                                  CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                                  routerBridgedExceptionPktsPtr);
}

/*******************************************************************************
* cpssDxChIpRouterBridgedPacketsExceptionCntGet
*
* DESCRIPTION:
*      Get exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*
* OUTPUTS:
*       routerBridgedExceptionPktsPtr - the number of counted router bridged
*                                       exception  packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_BAD_PTR               - on illegal pointer value
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterBridgedPacketsExceptionCntGet
(
    IN   GT_U8    devNum,
    OUT  GT_U32   *routerBridgedExceptionPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterBridgedPacketsExceptionCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerBridgedExceptionPktsPtr));

    rc = internal_cpssDxChIpRouterBridgedPacketsExceptionCntGet(devNum, routerBridgedExceptionPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerBridgedExceptionPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpRouterBridgedPacketsExceptionCntSet
*
* DESCRIPTION:
*      Set exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                        - the device number
*       routerBridgedExceptionPkts    - the counter value to set
*
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterBridgedPacketsExceptionCntSet
(
    IN   GT_U8    devNum,
    IN  GT_U32    routerBridgedExceptionPkts
)
{
    return cpssDxChIpPortGroupRouterBridgedPacketsExceptionCntSet(devNum,
                                                                  CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                                                  routerBridgedExceptionPkts);
}

/*******************************************************************************
* cpssDxChIpRouterBridgedPacketsExceptionCntSet
*
* DESCRIPTION:
*      Set exception counter for Special Services for Bridged Traffic.
*      it counts the number of Bridged packets failing any of the following checks:
*        - SIP Filter check for bridged IPv4/6 packets
*        - IP Header Check for bridged IPv4/6 packets
*        - Unicast RPF check for bridged IPv4/6 and ARP packets
*        - Unicast SIP/SA check for bridged IPv4/6 and ARP packets
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum                        - the device number
*       routerBridgedExceptionPkts    - the counter value to set
*
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on bad  devNum
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterBridgedPacketsExceptionCntSet
(
    IN   GT_U8    devNum,
    IN  GT_U32    routerBridgedExceptionPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterBridgedPacketsExceptionCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerBridgedExceptionPkts));

    rc = internal_cpssDxChIpRouterBridgedPacketsExceptionCntSet(devNum, routerBridgedExceptionPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerBridgedExceptionPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllBridgeEnable
*
* DESCRIPTION:
*      enable/disable MLL based bridging.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mllBridgeEnable - enable /disable MLL based bridging.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllBridgeEnable
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    mllBridgeEnable
)
{

    GT_U32    regAddr;          /* register address   */
    GT_U32    data;             /* value to write     */
    GT_STATUS rc;               /* return code        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    /* Get address of MLL Global Control Register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLGlobalCtrl;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
    }

    data = (GT_TRUE == mllBridgeEnable)? 1:0;

    rc = prvCpssHwPpSetRegField(devNum,regAddr,13,1,data);
    return rc;
}

/*******************************************************************************
* cpssDxChIpMllBridgeEnable
*
* DESCRIPTION:
*      enable/disable MLL based bridging.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mllBridgeEnable - enable /disable MLL based bridging.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllBridgeEnable
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    mllBridgeEnable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllBridgeEnable);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllBridgeEnable));

    rc = internal_cpssDxChIpMllBridgeEnable(devNum, mllBridgeEnable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllBridgeEnable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllBridgeEnableGet
*
* DESCRIPTION:
*      get state of MLL based bridging.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*
* OUTPUTS:
*       mllBridgeEnablePtr - enable /disable MLL based bridging.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL prt
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllBridgeEnableGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *mllBridgeEnablePtr
)
{
    GT_U32    regAddr;          /* register address   */
    GT_U32    hwData;             /* value to write     */
    GT_STATUS rc;               /* return code        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(mllBridgeEnablePtr);

    /* Get address of MLL Global Control Register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLGlobalCtrl.MLLGlobalCtrl;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllGlobalReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,13,1,&hwData);
    if(GT_OK != rc)
        return rc;

    *mllBridgeEnablePtr = (0 == hwData)? GT_FALSE : GT_TRUE;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpMllBridgeEnableGet
*
* DESCRIPTION:
*      get state of MLL based bridging.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum             - the device number
*
* OUTPUTS:
*       mllBridgeEnablePtr - enable /disable MLL based bridging.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL prt
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllBridgeEnableGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *mllBridgeEnablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllBridgeEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllBridgeEnablePtr));

    rc = internal_cpssDxChIpMllBridgeEnableGet(devNum, mllBridgeEnablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllBridgeEnablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetRateShaperSet
*
* DESCRIPTION:
*      set the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*       multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                     target Rate shaper
*       windowSize - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetRateShaperSet
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    multiTargetRateShaperEnable,
    IN   GT_U32     windowSize
)
{
    return cpssDxChIpPortGroupMultiTargetRateShaperSet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                               multiTargetRateShaperEnable,
                                               windowSize);
}

/*******************************************************************************
* cpssDxChIpMultiTargetRateShaperSet
*
* DESCRIPTION:
*      set the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*       multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                     target Rate shaper
*       windowSize - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetRateShaperSet
(
    IN   GT_U8      devNum,
    IN   GT_BOOL    multiTargetRateShaperEnable,
    IN   GT_U32     windowSize
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetRateShaperSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetRateShaperEnable, windowSize));

    rc = internal_cpssDxChIpMultiTargetRateShaperSet(devNum, multiTargetRateShaperEnable, windowSize);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetRateShaperEnable, windowSize));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetRateShaperGet
*
* DESCRIPTION:
*      set the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*      DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*      DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*
* OUTPUTS:
*       multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                        target Rate shaper
*       windowSizePtr - if enabled then this is the shaper window size
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetRateShaperGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *multiTargetRateShaperEnablePtr,
    OUT   GT_U32     *windowSizePtr
)
{
    return cpssDxChIpPortGroupMultiTargetRateShaperGet(devNum,
                                               CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                               multiTargetRateShaperEnablePtr,
                                               windowSizePtr);
}

/*******************************************************************************
* cpssDxChIpMultiTargetRateShaperGet
*
* DESCRIPTION:
*      set the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*      DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*      DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*
* OUTPUTS:
*       multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                        target Rate shaper
*       windowSizePtr - if enabled then this is the shaper window size
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetRateShaperGet
(
    IN    GT_U8      devNum,
    OUT   GT_BOOL    *multiTargetRateShaperEnablePtr,
    OUT   GT_U32     *windowSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetRateShaperGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, multiTargetRateShaperEnablePtr, windowSizePtr));

    rc = internal_cpssDxChIpMultiTargetRateShaperGet(devNum, multiTargetRateShaperEnablePtr, windowSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, multiTargetRateShaperEnablePtr, windowSizePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetUcSchedModeSet
*
* DESCRIPTION:
*      set the Multi target/unicast sheduler mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       ucSPEnable- weather the Unicast uses SP , if GT_FALSE then it means
*                   both the Unicast and multi target uses DSWRR scheduling
*       ucWeight  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                   is the unicast weight (APPLICABLE RANGES: 0..255).
*       mcWeight  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                   is the multi target weight (APPLICABLE RANGES: 0..255).
*       schedMtu  - The MTU used by the scheduler
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetUcSchedModeSet
(
    IN   GT_U8                              devNum,
    IN   GT_BOOL                            ucSPEnable,
    IN   GT_U32                             ucWeight,
    IN   GT_U32                             mcWeight,
    IN   CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   schedMtu
)
{
    GT_U32    regAddr;              /* register address  */
    GT_U32    data;                 /* value to write    */
    GT_STATUS rc;                   /* return code       */
    GT_U32    schedMtuData;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    /* Get address of Multi Target Vs. Unicast SDWRR and Strict Priority Scheduler register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetVsUcSDWRRAndStrictPriorityScheduler.
            mcUcSDWRRAndStrictPriorityConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtUcSchedulerModeReg;
    }

    switch (schedMtu)
    {
        case CPSS_DXCH_IP_MT_UC_SCHED_MTU_2K_E:
            schedMtuData = 0;
            break;
        case CPSS_DXCH_IP_MT_UC_SCHED_MTU_8K_E:
            schedMtuData = 1;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    data = (GT_TRUE == ucSPEnable)? 1:0;

    /* Enable/disable  Strict Priority for Unicast packets*/
    rc = prvCpssHwPpSetRegField(devNum,regAddr,16,1,data);
    if (GT_OK != rc)
        return rc;

    if (GT_FALSE == ucSPEnable)
    {
        if ( GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(ucWeight,8))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

        if ( GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(mcWeight,8))
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

        rc = prvCpssHwPpSetRegField(devNum,regAddr,8,8,ucWeight);
        if (GT_OK != rc)
            return rc;

        rc = prvCpssHwPpSetRegField(devNum,regAddr,0,8,mcWeight);
        if (GT_OK != rc)
            return rc;
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr,17,1,schedMtuData);

    return rc;
}

/*******************************************************************************
* cpssDxChIpMultiTargetUcSchedModeSet
*
* DESCRIPTION:
*      set the Multi target/unicast sheduler mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       ucSPEnable- weather the Unicast uses SP , if GT_FALSE then it means
*                   both the Unicast and multi target uses DSWRR scheduling
*       ucWeight  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                   is the unicast weight (APPLICABLE RANGES: 0..255).
*       mcWeight  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                   is the multi target weight (APPLICABLE RANGES: 0..255).
*       schedMtu  - The MTU used by the scheduler
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetUcSchedModeSet
(
    IN   GT_U8                              devNum,
    IN   GT_BOOL                            ucSPEnable,
    IN   GT_U32                             ucWeight,
    IN   GT_U32                             mcWeight,
    IN   CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   schedMtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetUcSchedModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucSPEnable, ucWeight, mcWeight, schedMtu));

    rc = internal_cpssDxChIpMultiTargetUcSchedModeSet(devNum, ucSPEnable, ucWeight, mcWeight, schedMtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucSPEnable, ucWeight, mcWeight, schedMtu));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMultiTargetUcSchedModeGet
*
* DESCRIPTION:
*      get the Multi target/unicast sheduler mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       ucSPEnablePtr- weather the Unicast uses SP , if GT_FALSE then it means
*                      both the Unicast and multi target uses DSWRR scheduling
*       ucWeightPtr  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                      is the unicast weight (APPLICABLE RANGES: 0..255).
*       mcWeightPtr  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                      is the multi target weight (APPLICABLE RANGES: 0..255).
*       schedMtuPtr  - The MTU used by the scheduler
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*       GT_BAD_STATE             - on invalid hardware value read
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMultiTargetUcSchedModeGet
(
    IN   GT_U8                              devNum,
    OUT  GT_BOOL                            *ucSPEnablePtr,
    OUT  GT_U32                             *ucWeightPtr,
    OUT  GT_U32                             *mcWeightPtr,
    OUT  CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   *schedMtuPtr
)
{
    GT_U32    regAddr;                /* register address  */
    GT_U32    hwData;                 /* hw value   */
    GT_STATUS rc = GT_OK;             /* return code   */


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(ucSPEnablePtr);
    CPSS_NULL_PTR_CHECK_MAC(ucWeightPtr);
    CPSS_NULL_PTR_CHECK_MAC(mcWeightPtr);
    CPSS_NULL_PTR_CHECK_MAC(schedMtuPtr);

    /* Get address of Multi Target Vs. Unicast SDWRR and Strict Priority Scheduler register */
    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetVsUcSDWRRAndStrictPriorityScheduler.
            mcUcSDWRRAndStrictPriorityConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mtUcSchedulerModeReg;
    }

    /* get MTU used by the scheduler */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,17,1,&hwData);
    if (GT_OK != rc)
        return rc;

    switch (hwData)
    {
        case 0:
            *schedMtuPtr = CPSS_DXCH_IP_MT_UC_SCHED_MTU_2K_E;
            break;
        case 1 :
            *schedMtuPtr = CPSS_DXCH_IP_MT_UC_SCHED_MTU_8K_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* get ucSPEnable */
    rc = prvCpssHwPpGetRegField(devNum,regAddr,16,1,&hwData);
    if (GT_OK != rc)
        return rc;

    *ucSPEnablePtr = (0 == hwData) ? GT_FALSE : GT_TRUE;

    if (GT_FALSE == *ucSPEnablePtr)
    {
        /* get ucWeight */
        rc = prvCpssHwPpGetRegField(devNum,regAddr,8,8,ucWeightPtr);
        if (GT_OK != rc)
            return rc;

        /* get mcWeight */
        rc = prvCpssHwPpGetRegField(devNum,regAddr,0,8,mcWeightPtr);
        if (GT_OK != rc)
            return rc;
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpMultiTargetUcSchedModeGet
*
* DESCRIPTION:
*      get the Multi target/unicast sheduler mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       ucSPEnablePtr- weather the Unicast uses SP , if GT_FALSE then it means
*                      both the Unicast and multi target uses DSWRR scheduling
*       ucWeightPtr  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                      is the unicast weight (APPLICABLE RANGES: 0..255).
*       mcWeightPtr  - if DSWRR scheduler is used (ucSPEnable==GT_FALSE) then this
*                      is the multi target weight (APPLICABLE RANGES: 0..255).
*       schedMtuPtr  - The MTU used by the scheduler
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*       GT_BAD_STATE             - on invalid hardware value read
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMultiTargetUcSchedModeGet
(
    IN   GT_U8                              devNum,
    OUT  GT_BOOL                            *ucSPEnablePtr,
    OUT  GT_U32                             *ucWeightPtr,
    OUT  GT_U32                             *mcWeightPtr,
    OUT  CPSS_DXCH_IP_MT_UC_SCHED_MTU_ENT   *schedMtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMultiTargetUcSchedModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, ucSPEnablePtr, ucWeightPtr, mcWeightPtr, schedMtuPtr));

    rc = internal_cpssDxChIpMultiTargetUcSchedModeGet(devNum, ucSPEnablePtr, ucWeightPtr, mcWeightPtr, schedMtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, ucSPEnablePtr, ucWeightPtr, mcWeightPtr, schedMtuPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpArpBcModeSet
*
* DESCRIPTION:
*       set a arp broadcast mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum       - the device number
*       arpBcMode    - the arp broadcast command. Possible Commands:
*                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
* GalTis:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpArpBcModeSet
(
    IN GT_U8               devNum,
    IN CPSS_PACKET_CMD_ENT arpBcMode
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    data;
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    /* Get address of IPv4 Control Register0 */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
    }

    switch (arpBcMode)
    {
        case CPSS_PACKET_CMD_NONE_E:
            data = 0;
            break;
        case CPSS_PACKET_CMD_MIRROR_TO_CPU_E:
            data = 1;
            break;
        case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
            data = 2;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum,regAddr,30,2,data);
    return rc;
}

/*******************************************************************************
* cpssDxChIpArpBcModeSet
*
* DESCRIPTION:
*       set a arp broadcast mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum       - the device number
*       arpBcMode    - the arp broadcast command. Possible Commands:
*                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
* GalTis:
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpArpBcModeSet
(
    IN GT_U8               devNum,
    IN CPSS_PACKET_CMD_ENT arpBcMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpArpBcModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, arpBcMode));

    rc = internal_cpssDxChIpArpBcModeSet(devNum, arpBcMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, arpBcMode));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpArpBcModeGet
*
* DESCRIPTION:
*       get a arp broadcast mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum       - the device number
*
* OUTPUTS:
*       arpBcModePtr - the arp broadcast command. Possible Commands:
*                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None.
* GalTis:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpArpBcModeGet
(
    IN  GT_U8               devNum,
    OUT CPSS_PACKET_CMD_ENT *arpBcModePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    hwData;
    GT_STATUS rc = GT_OK;           /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(arpBcModePtr);

    /* Get address of IPv4 Control Register0 */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv4GlobalCtrl.IPv4CtrlReg0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ctrlReg0;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr,30,2, &hwData);
    if(GT_OK != rc)
    {
        return rc;
    }

    switch (hwData)
    {
        case 0:
            *arpBcModePtr = CPSS_PACKET_CMD_NONE_E;
            break;
        case 1:
            *arpBcModePtr = CPSS_PACKET_CMD_MIRROR_TO_CPU_E;
            break;
        case 2:
            *arpBcModePtr = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpArpBcModeGet
*
* DESCRIPTION:
*       get a arp broadcast mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum       - the device number
*
* OUTPUTS:
*       arpBcModePtr - the arp broadcast command. Possible Commands:
*                      CPSS_PACKET_CMD_NONE_E,CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                      CPSS_PACKET_CMD_MIRROR_TO_CPU_E
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None.
* GalTis:
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpArpBcModeGet
(
    IN  GT_U8               devNum,
    OUT CPSS_PACKET_CMD_ENT *arpBcModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpArpBcModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, arpBcModePtr));

    rc = internal_cpssDxChIpArpBcModeGet(devNum, arpBcModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, arpBcModePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpPortRoutingEnable
*
* DESCRIPTION:
*       Enable multicast/unicast IPv4/v6 routing on a port.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       portNum       - the port to enable on
*       ucMcEnable    - routing type to enable Unicast/Multicast
*       protocolStack - what type of traffic to enable ipv4 or ipv6 or both.
*       enableRouting - enable IP routing for this port
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortRoutingEnable
(
    IN GT_U8                            devNum,
    IN GT_PORT_NUM                      portNum,
    IN CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN GT_BOOL                          enableRouting
)
{
    GT_U32    regAddr[2] ={0,0};              /* registers address             */
    GT_U32    data, i;
    GT_STATUS rc = GT_OK;                     /* return code                   */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    GT_U32  fieldName;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    switch (ucMcEnable)
    {
        case CPSS_IP_UNICAST_E:
        case CPSS_IP_MULTICAST_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
        case CPSS_IP_PROTOCOL_IPV4V6_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if ((protocolStack == CPSS_IP_PROTOCOL_IPV4_E) || (protocolStack == CPSS_IP_PROTOCOL_IPV4V6_E))
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_MC_ROUTING_ENABLE_E;
            }
            rc = prvCpssDxChWriteTableEntryField(devNum,
                                                 PRV_CPSS_DXCH_LION3_TABLE_IPVX_INGRESS_EPORT_E,
                                                 portNum,
                                                 PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                 fieldName,
                                                 PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                                 BOOL2BIT_MAC(enableRouting));
            if (rc != GT_OK)
                return rc;
        }

        if ((protocolStack == CPSS_IP_PROTOCOL_IPV6_E) || (protocolStack == CPSS_IP_PROTOCOL_IPV4V6_E))
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_MC_ROUTING_ENABLE_E;
            }
            rc = prvCpssDxChWriteTableEntryField(devNum,
                                                 PRV_CPSS_DXCH_LION3_TABLE_IPVX_INGRESS_EPORT_E,
                                                 portNum,
                                                 PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                 fieldName,
                                                 PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                                 BOOL2BIT_MAC(enableRouting));
            if (rc != GT_OK)
                return rc;
        }
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        data = (GT_TRUE == enableRouting)? 1:0;

        switch (protocolStack)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
            break;

            case CPSS_IP_PROTOCOL_IPV6_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

            break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /*  Unicast Enable Control Register for Ipv6*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucEnCtrlReg;

                        /* Unicast Enable Control Register*/
                        regAddr[1] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ucEnCtrlReg;

                        break;

                    case CPSS_IP_MULTICAST_E:
                        /* for Ipv6*/
                        regAddr[0] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcEnCtrlReg;
                        /* MC Enable Control Register*/
                        regAddr[1] = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                 }

            break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* now write one or two registers */
        for (i = 0;(rc == GT_OK) && (i <2) ; i++)
        {
            if (regAddr[i] != 0)
                rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr[i],(GT_U32)localPort ,1,
                                               data);
        }
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortRoutingEnable
*
* DESCRIPTION:
*       Enable multicast/unicast IPv4/v6 routing on a port.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       portNum       - the port to enable on
*       ucMcEnable    - routing type to enable Unicast/Multicast
*       protocolStack - what type of traffic to enable ipv4 or ipv6 or both.
*       enableRouting - enable IP routing for this port
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortRoutingEnable
(
    IN GT_U8                            devNum,
    IN GT_PORT_NUM                      portNum,
    IN CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    IN GT_BOOL                          enableRouting
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRoutingEnable);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, ucMcEnable, protocolStack, enableRouting));

    rc = internal_cpssDxChIpPortRoutingEnable(devNum, portNum, ucMcEnable, protocolStack, enableRouting);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, ucMcEnable, protocolStack, enableRouting));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortRoutingEnableGet
*
* DESCRIPTION:
*       Get status of multicast/unicast IPv4/v6 routing on a port.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       portNum       - the port to enable on
*       ucMcEnable    - routing type to enable Unicast/Multicast
*       protocolStack - what type of traffic to enable ipv4 or ipv6 or both.
*
* OUTPUTS:
*       enableRoutingPtr - (pointer to)enable IP routing for this port
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PARAM             - wrong protocolStack
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       CPSS_IP_PROTOCOL_IPV4V6_E is not supported in this get API.
*       Can not get both values for ipv4 and ipv6 in the same get.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortRoutingEnableGet
(
    IN  GT_U8                            devNum,
    IN  GT_PORT_NUM                      portNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN  CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT GT_BOOL                          *enableRoutingPtr
)
{
    GT_U32    regAddr;              /* registers address */
    GT_U32    data=0;
    GT_STATUS rc = GT_OK;           /* return code */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */
    GT_U32  fieldName;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(enableRoutingPtr);

    switch (ucMcEnable)
    {
        case CPSS_IP_UNICAST_E:
        case CPSS_IP_MULTICAST_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }
    switch (protocolStack)
    {
        case CPSS_IP_PROTOCOL_IPV4_E:
        case CPSS_IP_PROTOCOL_IPV6_E:
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        if (protocolStack == CPSS_IP_PROTOCOL_IPV4_E)
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV4_MC_ROUTING_ENABLE_E;
            }
        }
        else /*CPSS_IP_PROTOCOL_IPV6_E */
        {
            if (ucMcEnable == CPSS_IP_UNICAST_E)
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_UC_ROUTING_ENABLE_E;
            }
            else
            {
                fieldName = LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_IPV6_MC_ROUTING_ENABLE_E;
            }
        }

        rc = prvCpssDxChReadTableEntryField(devNum,
                                            PRV_CPSS_DXCH_LION3_TABLE_IPVX_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            fieldName,
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &data);
        if (rc != GT_OK)
        {
            return rc;
        }

        *enableRoutingPtr = BIT2BOOL_MAC(data);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        switch (protocolStack)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv4Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
            break;

            case CPSS_IP_PROTOCOL_IPV6_E:
                switch (ucMcEnable)
                {
                    case CPSS_IP_UNICAST_E:
                        /* Unicast Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucEnCtrlReg;
                        break;
                    case CPSS_IP_MULTICAST_E:
                        /* MC Enable Control Register*/
                        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcEnCtrlReg;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

            break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                /* can not get both values for ipv4 and ipv6 in the same get*/
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        /* now read the register */
        rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,(GT_U32)localPort ,1,&data);

        if(rc != GT_OK)
            return rc;

        *enableRoutingPtr = BIT2BOOL_MAC(data);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortRoutingEnableGet
*
* DESCRIPTION:
*       Get status of multicast/unicast IPv4/v6 routing on a port.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       portNum       - the port to enable on
*       ucMcEnable    - routing type to enable Unicast/Multicast
*       protocolStack - what type of traffic to enable ipv4 or ipv6 or both.
*
* OUTPUTS:
*       enableRoutingPtr - (pointer to)enable IP routing for this port
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PARAM             - wrong protocolStack
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       CPSS_IP_PROTOCOL_IPV4V6_E is not supported in this get API.
*       Can not get both values for ipv4 and ipv6 in the same get.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortRoutingEnableGet
(
    IN  GT_U8                            devNum,
    IN  GT_PORT_NUM                      portNum,
    IN  CPSS_IP_UNICAST_MULTICAST_ENT    ucMcEnable,
    IN  CPSS_IP_PROTOCOL_STACK_ENT       protocolStack,
    OUT GT_BOOL                          *enableRoutingPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRoutingEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, ucMcEnable, protocolStack, enableRoutingPtr));

    rc = internal_cpssDxChIpPortRoutingEnableGet(devNum, portNum, ucMcEnable, protocolStack, enableRoutingPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, ucMcEnable, protocolStack, enableRoutingPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}
/*******************************************************************************
* internal_cpssDxChIpQosProfileToRouteEntryMapSet
*
* DESCRIPTION:
*       Sets the QoS profile to route entry offset mapping table.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       qosProfile       - QOS Profile index
*       routeEntryOffset - The offset in the array of route entries to be
*                          selected for this QOS profile
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in DxCh2, DxCh3, xCat, xCat3: <Route Entry Index> +
*                               (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*                               (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*                    Floor(QoSProfile-to-Route-Block-Offset(QoSProfile) *
*                         (<Number of Paths> + 1) / 8)
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpQosProfileToRouteEntryMapSet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    IN  GT_U32               routeEntryOffset
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_DXCH_QOS2MT_ENTRY_CHECK_MAC(devNum,qosProfile);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* Each entry consists of 4 QoS Profile Offsets, and each offset is 3 bits long,
           so to calculate the entry in the table we divide qosProfile by 4, and
           to calculate the offset within the entry we use 3 * (qosProfile % 4) */
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                         PRV_CPSS_DXCH_LION3_TABLE_IPVX_ROUTER_QOS_PROFILE_OFFSETS_E,
                                         qosProfile / 4,
                                         PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                         3 * (qosProfile % 4),
                                         3,
                                         routeEntryOffset);
        if (rc != GT_OK)
        {
            return rc;
        }
    }
    else
    {
        /* Get address of the register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.qoSProfile2RouteBlockOffsetMapTable[qosProfile / 8];

        offset = (qosProfile % 8) * 4;
        rc = prvCpssHwPpSetRegField(devNum,regAddr,offset,3,routeEntryOffset);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpQosProfileToRouteEntryMapSet
*
* DESCRIPTION:
*       Sets the QoS profile to route entry offset mapping table.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       qosProfile       - QOS Profile index
*       routeEntryOffset - The offset in the array of route entries to be
*                          selected for this QOS profile
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in DxCh2, DxCh3, xCat, xCat3: <Route Entry Index> +
*                               (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*                               (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*                    Floor(QoSProfile-to-Route-Block-Offset(QoSProfile) *
*                         (<Number of Paths> + 1) / 8)
*
*******************************************************************************/
GT_STATUS cpssDxChIpQosProfileToRouteEntryMapSet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    IN  GT_U32               routeEntryOffset
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToRouteEntryMapSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, routeEntryOffset));

    rc = internal_cpssDxChIpQosProfileToRouteEntryMapSet(devNum, qosProfile, routeEntryOffset);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, routeEntryOffset));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpQosProfileToRouteEntryMapGet
*
* DESCRIPTION:
*       gets the QoS profile to route entry offset mapping table.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       qosProfile       - QOS Profile index
*
* OUTPUTS:
*       routeEntryOffsetPtr - The offset in the array of route entries to be
*                             selected for this QOS profile
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in DxCh2, DxCh3, xCat, xCat3: <Route Entry Index> +
*                               (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*                               (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*                    Floor(QoSProfile-to-Route-Block-Offset(QoSProfile) *
*                         (<Number of Paths> + 1) / 8)
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpQosProfileToRouteEntryMapGet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    OUT GT_U32               *routeEntryOffsetPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(routeEntryOffsetPtr);

    PRV_CPSS_DXCH_QOS2MT_ENTRY_CHECK_MAC(devNum, qosProfile);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* Each entry consists of 4 QoS Profile Offsets, and each offset is 3 bits long,
           so to calculate the entry in the table we divide qosProfile by 4, and
           to calculate the offset within the entry we use 3 * (qosProfile % 4) */
        rc = prvCpssDxChReadTableEntryField(devNum,
                                         PRV_CPSS_DXCH_LION3_TABLE_IPVX_ROUTER_QOS_PROFILE_OFFSETS_E,
                                         qosProfile / 4,
                                         PRV_CPSS_DXCH_TABLE_WORD_INDICATE_GLOBAL_BIT_CNS,
                                         3 * (qosProfile % 4),
                                         3,
                                         routeEntryOffsetPtr);
    }
    else
    {
        /* Get address of the register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.qoSProfile2RouteBlockOffsetMapTable[qosProfile / 8];

        offset = (qosProfile % 8) * 4;
        rc = prvCpssHwPpGetRegField(devNum,regAddr,offset,3,routeEntryOffsetPtr);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpQosProfileToRouteEntryMapGet
*
* DESCRIPTION:
*       gets the QoS profile to route entry offset mapping table.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       qosProfile       - QOS Profile index
*
* OUTPUTS:
*       routeEntryOffsetPtr - The offset in the array of route entries to be
*                             selected for this QOS profile
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       In QoS-based routing, the Route table entry is selected according to the
*       following index calculation:
*       1. in DxCh2, DxCh3, xCat, xCat3: <Route Entry Index> +
*                               (QoSProfile-to-Route-Block-Offset(QoSProfile) %
*                               (<Number of Paths> + 1)
*       2. in Lion : <Route Entry Index> +
*                    Floor(QoSProfile-to-Route-Block-Offset(QoSProfile) *
*                         (<Number of Paths> + 1) / 8)
*
*******************************************************************************/
GT_STATUS cpssDxChIpQosProfileToRouteEntryMapGet
(
    IN  GT_U8                devNum,
    IN  GT_U32               qosProfile,
    OUT GT_U32               *routeEntryOffsetPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpQosProfileToRouteEntryMapGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, qosProfile, routeEntryOffsetPtr));

    rc = internal_cpssDxChIpQosProfileToRouteEntryMapGet(devNum, qosProfile, routeEntryOffsetPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, qosProfile, routeEntryOffsetPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRoutingEnable
*
* DESCRIPTION:
*       globally enable/disable routing.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       enableRouting - enable /disable global routing
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PARAM             - wrong devNum
*
* COMMENTS:
*       the ASIC defualt is routing enabled.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRoutingEnable
(
    IN GT_U8    devNum,
    IN GT_BOOL  enableRouting
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    data;
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    data = (GT_TRUE == enableRouting)? 1:0;
    /* Get address of  register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }
    rc = prvCpssHwPpSetRegField(devNum,regAddr, 6,1,data);

    return rc;
}

/*******************************************************************************
* cpssDxChIpRoutingEnable
*
* DESCRIPTION:
*       globally enable/disable routing.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       enableRouting - enable /disable global routing
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PARAM             - wrong devNum
*
* COMMENTS:
*       the ASIC defualt is routing enabled.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpRoutingEnable
(
    IN GT_U8    devNum,
    IN GT_BOOL  enableRouting
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRoutingEnable);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enableRouting));

    rc = internal_cpssDxChIpRoutingEnable(devNum, enableRouting);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enableRouting));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRoutingEnableGet
*
* DESCRIPTION:
*       Get global routing status
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum              - the device number
*
* OUTPUTS:
*       enableRoutingPtr    -  (pointer to)enable /disable global routing
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRoutingEnableGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *enableRoutingPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    data;
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    CPSS_NULL_PTR_CHECK_MAC(enableRoutingPtr);

    /* Get address of  register */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerGlobalReg;
    }
    rc = prvCpssHwPpGetRegField(devNum,regAddr, 6,1,&data);

    if(rc != GT_OK)
        return rc;

    *enableRoutingPtr = BIT2BOOL_MAC(data);

    return rc;
}

/*******************************************************************************
* cpssDxChIpRoutingEnableGet
*
* DESCRIPTION:
*       Get global routing status
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum              - the device number
*
* OUTPUTS:
*       enableRoutingPtr    -  (pointer to)enable /disable global routing
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpRoutingEnableGet
(
    IN  GT_U8    devNum,
    OUT GT_BOOL  *enableRoutingPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRoutingEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enableRoutingPtr));

    rc = internal_cpssDxChIpRoutingEnableGet(devNum, enableRoutingPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enableRoutingPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpCntGet
*
* DESCRIPTION:
*       Return the IP counter set requested.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum  - the device number
*       cntSet - counters set to retrieve.
*
* OUTPUTS:
*       countersPtr - (pointer to)struct contains the counter values.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PTR               - on NULL pointer
*       GT_FAIL                  - on error
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       This function doesn't handle counters overflow.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpCntGet
(
    IN  GT_U8                        devNum,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    return cpssDxChIpPortGroupCntGet(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                     cntSet, countersPtr);
}

/*******************************************************************************
* cpssDxChIpCntGet
*
* DESCRIPTION:
*       Return the IP counter set requested.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum  - the device number
*       cntSet - counters set to retrieve.
*
* OUTPUTS:
*       countersPtr - (pointer to)struct contains the counter values.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PTR               - on NULL pointer
*       GT_FAIL                  - on error
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       This function doesn't handle counters overflow.
*
*******************************************************************************/
GT_STATUS cpssDxChIpCntGet
(
    IN  GT_U8                        devNum,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, countersPtr));

    rc = internal_cpssDxChIpCntGet(devNum, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpCntSetModeSet
*
* DESCRIPTION:
*      Sets a counter set's bounded inteface and interface mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       cntSet        - the counter set
*       cntSetMode    - the counter set bind mode (interface or Next hop)
*       interfaceModeCfgPtr - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                          this is the interface configuration
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpCntSetModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    IN  CPSS_DXCH_IP_CNT_SET_MODE_ENT              cntSetMode,
    IN  CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    regAddr2;             /* register address                   */
    GT_U32    data;
    GT_U32    data2;
    GT_STATUS rc;                   /* return code                        */
    GT_U8 setNum;
    GT_U32  portGroupId,portPortGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  portValue;    /* port value */
    GT_U32  hwPort,hwDev;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    if(cntSetMode != CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E)
        CPSS_NULL_PTR_CHECK_MAC(interfaceModeCfgPtr);

    switch (cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        regAddr  = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig0[setNum];
        regAddr2 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig1[setNum];

        data = 0;
        data2 = 0;

        switch (cntSetMode)
        {
            case CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E:
                data |= (0x0 << 29); /* <bit 29> = 0 indicates interface mode */
                switch (interfaceModeCfgPtr->portTrunkCntMode)
                {
                    case CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                        data |= (0x0 << 30); /* <bits 30:31> = 0 indicates count all */
                        break;
                    case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                        data |= (0x1 << 30); /* <bits 30:31> = 1 indicates count ePortDevice */
                        if (interfaceModeCfgPtr->portTrunk.port > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_E_PORT_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        if (interfaceModeCfgPtr->hwDevNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum) == 0)
                        {
                            data2 |= ((interfaceModeCfgPtr->portTrunk.port & 0x1FFF) << 0);
                            data2 |= ((interfaceModeCfgPtr->hwDevNum & 0x3FF) << 13);
                        }
                        else
                        {
                            data2 |= ((interfaceModeCfgPtr->portTrunk.port & 0x7FFF) << 0);
                            data2 |= ((interfaceModeCfgPtr->hwDevNum & 0x3FF) << 15);
                        }
                        break;
                    case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                        data |= (0x2 << 30); /* <bits 30:31> = 2 indicates count trunk */
                        if (interfaceModeCfgPtr->portTrunk.trunk > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        data2 |= ((interfaceModeCfgPtr->portTrunk.trunk & 0xFFF) << 0);
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                switch (interfaceModeCfgPtr->vlanMode)
                {
                    case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                        data |= (0x0 << 25); /* <bit 25> = 0 indicates count all */
                        break;
                    case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                        if (interfaceModeCfgPtr->vlanId > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VID_MAC(devNum))
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        data |= (0x1 << 25); /* <bit 25> = 1 indicates count eVlan */
                        data |= (interfaceModeCfgPtr->vlanId & 0x1FFF);
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                switch (interfaceModeCfgPtr->ipMode)
                {
                    case CPSS_IP_PROTOCOL_IPV4_E:
                        data |= (0x1 << 26); /* <bits 26:28> = 1 indicates count ipv4 */
                        break;
                    case CPSS_IP_PROTOCOL_IPV6_E:
                        data |= (0x2 << 26); /* <bits 26:28> = 2 indicates count ipv6 */
                        break;
                    case CPSS_IP_PROTOCOL_IPV4V6_E:
                        data |= (0x0 << 26); /* <bits 26:28> = 0 indicates count all */
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;
            case CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E:
                data |= (0x1 << 29); /* <bit 29> = 1 indicates route entry mode */
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssHwPpWriteRegister(devNum,regAddr,data);
        if (rc != GT_OK)
            return rc;

        /* on some cases, there is no need to set second register */
        if (cntSetMode == CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E)
        {
            if ((interfaceModeCfgPtr->portTrunkCntMode != CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E) ||
                (interfaceModeCfgPtr->vlanMode != CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E))
            {
                rc = prvCpssHwPpWriteRegister(devNum,regAddr2,data2);
                if (rc != GT_OK)
                    return rc;
            }
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngCntSetCfgRegs[setNum];

        /* support multi-port-groups device - same configuration to all port groups */
        portPortGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;

        switch (cntSetMode)
        {
            /* Interface counter */
            case CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E:
                rc = prvCpssHwPpSetRegField(devNum,regAddr,29,1,0);
                if(GT_OK != rc)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

                /* Set Port/Trunk mode*/
                switch (interfaceModeCfgPtr->portTrunkCntMode)
                {
                    case  CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                        data = 0;
                        break;
                    case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                        /* FEr#3116: Wrong counting of IP counters per port - IP counters cannot be set by {device+port} */
                        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E))
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                        }

                        PRV_CPSS_DXCH_DUAL_HW_DEVICE_AND_PORT_CHECK_MAC(
                            interfaceModeCfgPtr->hwDevNum,
                            interfaceModeCfgPtr->portTrunk.port);
                        hwDev =  PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_DEV_MAC(
                            interfaceModeCfgPtr->hwDevNum,
                            interfaceModeCfgPtr->portTrunk.port);
                        hwPort = PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_PORT_MAC(
                            interfaceModeCfgPtr->hwDevNum,
                            interfaceModeCfgPtr->portTrunk.port);

                        if(hwPort >= BIT_6)
                        {
                            /* 6 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }

                        if(hwDev >= BIT_5)
                        {
                            /* 5 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }

                        /* hold 'port filter' */
                        if(PRV_CPSS_HW_DEV_NUM_MAC(devNum) == interfaceModeCfgPtr->hwDevNum)
                        {
                            /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
                            portPortGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum,
                                interfaceModeCfgPtr->portTrunk.port);
                        }

                        data = 1;

                        /* loop on all port groups :
                            on the port group that 'own' the port , set the needed configuration
                            on other port groups put 'NULL port'
                        */
                        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
                        {
                            if(PRV_CPSS_HW_DEV_NUM_MAC(devNum) != interfaceModeCfgPtr->hwDevNum)
                            {
                                /* no conversion needed for remote device */
                                portValue = hwPort;
                            }
                            else if(portPortGroupId == portGroupId)
                            {
                                /* convert global to local port */
                                portValue = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,
                                    interfaceModeCfgPtr->portTrunk.port);
                            }
                            else
                            {
                                /* use NULL port , so no counting will happen */
                                portValue = PRV_CPSS_DXCH_NULL_PORT_NUM_CNS;
                            }

                            /* Set 6 bits of the port\trunk field and bits 7,8 are 0. */
                            rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr, 0, 8,
                                            portValue);
                            if(GT_OK != rc)
                                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        }
                        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

                        /* Set device num*/
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,8,5,hwDev);
                        if(GT_OK != rc)
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        break;

                    case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                        if(interfaceModeCfgPtr->portTrunk.trunk >= BIT_7)
                        {
                            /* 7 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        /* Set 7 bits of the port\trunk field and the 8th is 0. */
                        rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 8,
                                      interfaceModeCfgPtr->portTrunk.trunk);
                        if(GT_OK != rc)
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        data = 2;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                rc = prvCpssHwPpSetRegField(devNum,regAddr,30,2,data);
                if(GT_OK != rc)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                /* Set IpMode */
                switch (interfaceModeCfgPtr->ipMode)
                {
                    case CPSS_IP_PROTOCOL_IPV4_E:
                        data = 1;
                        break;
                    case CPSS_IP_PROTOCOL_IPV6_E:
                        data = 2;
                        break;
                    case CPSS_IP_PROTOCOL_IPV4V6_E:
                        data = 0;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                rc = prvCpssHwPpSetRegField(devNum,regAddr,27,2,data);
                if(GT_OK != rc)
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                /* Set VLAN count mode */
                switch ( interfaceModeCfgPtr->vlanMode)
                {
                    case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,0);
                        break;
                    case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                        if(interfaceModeCfgPtr->vlanId >= BIT_12)
                        {
                            /* 12 bits in HW */
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                        }
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,1);
                        if(GT_OK != rc)
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

                        /* Set VID*/
                        rc = prvCpssHwPpSetRegField(devNum,regAddr,14,12,
                                                       interfaceModeCfgPtr->vlanId);
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                break;

            case CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E:
                rc = prvCpssHwPpSetRegField(devNum,regAddr,29,1,1);
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpCntSetModeSet
*
* DESCRIPTION:
*      Sets a counter set's bounded inteface and interface mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       cntSet        - the counter set
*       cntSetMode    - the counter set bind mode (interface or Next hop)
*       interfaceModeCfgPtr - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                          this is the interface configuration
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpCntSetModeSet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    IN  CPSS_DXCH_IP_CNT_SET_MODE_ENT              cntSetMode,
    IN  CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntSetModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, cntSetMode, interfaceModeCfgPtr));

    rc = internal_cpssDxChIpCntSetModeSet(devNum, cntSet, cntSetMode, interfaceModeCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, cntSetMode, interfaceModeCfgPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpCntSetModeGet
*
* DESCRIPTION:
*      Gets a counter set's bounded inteface and interface mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       cntSet        - the counter set
*
* OUTPUTS:
*       cntSetModePtr - the counter set bind mode (interface or Next hop)
*       interfaceModeCfgPtr - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                             this is the interface configuration
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpCntSetModeGet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    OUT CPSS_DXCH_IP_CNT_SET_MODE_ENT              *cntSetModePtr,
    OUT CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_U32    regAddr;              /*  register address  */
    GT_U32    regAddr2;             /*  register address  */
    GT_U32    hwData = 0;
    GT_U32    hwData2 = 0;
    GT_U32    value = 0;
    GT_STATUS rc = GT_OK;
    GT_U8     setNum;
    GT_U32    portGroupId;
    GT_U32    portValue, tmpPortValue;
    GT_U32    hwDev;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(cntSetModePtr);
    CPSS_NULL_PTR_CHECK_MAC(interfaceModeCfgPtr);


    switch (cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
     }

    if(PRV_CPSS_SIP_5_CHECK_MAC(devNum))
    {
        /* get first reg addr */
        regAddr  = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig0[setNum];

        /* read hw data from first register */
        rc = prvCpssHwPpReadRegister(devNum,regAddr,&hwData);
        if(GT_OK != rc)
        {
           return rc;
        }

        value = (hwData >> 29) & 0x1;

        switch(value)
        {
            case 0:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E;

                /* get second reg addr */
                regAddr2 = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementCntrsSetConfig1[setNum];

                /* read hw data from second register */
                rc = prvCpssHwPpReadRegister(devNum,regAddr2,&hwData2);

                if (rc != GT_OK)
                    return rc;

                value = (hwData >> 30) & 0x3;
                switch(value)
                {
                    case 0:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E;

                        break;
                    case 1:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_PORT_CNT_MODE_E;
                        if(PRV_CPSS_SIP_5_15_CHECK_MAC(devNum) == 0)
                        {
                            interfaceModeCfgPtr->portTrunk.port = (GT_PORT_NUM)(hwData2 & 0x1FFF);
                            interfaceModeCfgPtr->hwDevNum = (GT_HW_DEV_NUM)((hwData2>>13)&0x3FF);
                        }
                        else
                        {
                            interfaceModeCfgPtr->portTrunk.port = (GT_PORT_NUM)(hwData2 & 0x7FFF);
                            interfaceModeCfgPtr->hwDevNum = (GT_HW_DEV_NUM)((hwData2>>15)&0x3FF);
                        }
                        break;
                    case 2:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_TRUNK_CNT_MODE_E;
                        interfaceModeCfgPtr->portTrunk.trunk = (GT_TRUNK_ID)(hwData2 & 0xFFF);
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                value = (hwData >> 25) & 0x1;
                switch(value)
                {
                    case 0:
                        interfaceModeCfgPtr->vlanMode = CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E;
                        break;
                    case 1:
                        interfaceModeCfgPtr->vlanMode = CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E;
                        interfaceModeCfgPtr->vlanId = (GT_U16)(hwData & 0x1FFF);
                        break;

                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }

                value = (hwData >> 26) & 0x7;
                switch (value)
                {
                    case 1:
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV4_E;
                        break;
                    case 2 :
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV6_E;
                        break;
                    case 0:
                        interfaceModeCfgPtr->ipMode = CPSS_IP_PROTOCOL_IPV4V6_E;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
                break;

            case 1:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngCntSetCfgRegs[setNum];

        rc = prvCpssHwPpGetRegField(devNum,regAddr,29,1,&value);
        if(GT_OK != rc)
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
        }

        switch (value)
        {
            case 0:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E;

                rc = prvCpssHwPpGetRegField(devNum,regAddr,30,2,&value);
                if(GT_OK != rc)
                {
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                }

                switch (value)
                {
                    case 0:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E;
                        break;
                    case 1:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_PORT_CNT_MODE_E;

                        /* FEr#3116: Wrong counting of IP counters per port - IP counters cannot be set by {device+port} */
                        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,PRV_CPSS_DXCH_LION_WRONG_COUNTING_OF_IP_COUNTERS_PER_PORT_WA_E))
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
                        }

                        /*  Get device num  */
                        rc = prvCpssHwPpGetRegField(devNum,regAddr,8,5,&hwDev);
                        if(GT_OK != rc)
                        {
                            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                        }

                        /*  loop on all port groups  */
                        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
                        {
                            /* Set 6 bits of the port\trunk filed and bits 7,8 are 0. */
                            rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr, 0, 8,
                                            &portValue);
                            if(GT_OK != rc)
                            {
                                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
                            }

                            tmpPortValue = portValue;

                            if(portValue != PRV_CPSS_DXCH_NULL_PORT_NUM_CNS)
                            {
                                PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_DEV_PORT_MAC(hwDev, tmpPortValue);

                                if(hwDev != PRV_CPSS_HW_DEV_NUM_MAC(devNum))
                                {
                                    /* no conversion needed for remote device */
                                    interfaceModeCfgPtr->portTrunk.port = tmpPortValue;
                                }
                                else
                                {
                                    /*  convert global to local port  */
                                    interfaceModeCfgPtr->portTrunk.port =
                                        PRV_CPSS_LOCAL_PORT_TO_GLOBAL_PORT_CONVERT_MAC(devNum,portGroupId,portValue);
                                }
                                break;
                            }
                        }
                        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

                        interfaceModeCfgPtr->hwDevNum = (GT_HW_DEV_NUM)hwDev;

                        break;
                    case 2:
                        interfaceModeCfgPtr->portTrunkCntMode = CPSS_DXCH_IP_TRUNK_CNT_MODE_E;

                        /* Set 7 bits of the port\trunk filed and the 8th is 0. */
                        rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 8, &value);

                        interfaceModeCfgPtr->portTrunk.trunk = (GT_TRUNK_ID)value;
                        break;
                    default:
                        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
                }
                break;
            case 1:
                *cntSetModePtr = CPSS_DXCH_IP_CNT_SET_ROUTE_ENTRY_MODE_E;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpCntSetModeGet
*
* DESCRIPTION:
*      Gets a counter set's bounded inteface and interface mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum        - the device number
*       cntSet        - the counter set
*
* OUTPUTS:
*       cntSetModePtr - the counter set bind mode (interface or Next hop)
*       interfaceModeCfgPtr - if cntSetMode = CPSS_DXCH_IP_CNT_SET_INTERFACE_MODE_E
*                             this is the interface configuration
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpCntSetModeGet
(
    IN  GT_U8                                      devNum,
    IN  CPSS_IP_CNT_SET_ENT                        cntSet,
    OUT CPSS_DXCH_IP_CNT_SET_MODE_ENT              *cntSetModePtr,
    OUT CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceModeCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntSetModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, cntSetModePtr, interfaceModeCfgPtr));

    rc = internal_cpssDxChIpCntSetModeGet(devNum, cntSet, cntSetModePtr, interfaceModeCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, cntSetModePtr, interfaceModeCfgPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpCntSet
*
* DESCRIPTION:
*       set the requested IP counter set.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum       - the device number
*       cntSet       - counters set to clear.
*       countersPtr  - the counter values to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpCntSet
(
    IN GT_U8                         devNum,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    return cpssDxChIpPortGroupCntSet(devNum, CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                     cntSet, countersPtr);

}

/*******************************************************************************
* cpssDxChIpCntSet
*
* DESCRIPTION:
*       set the requested IP counter set.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum       - the device number
*       cntSet       - counters set to clear.
*       countersPtr  - the counter values to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpCntSet
(
    IN GT_U8                         devNum,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, cntSet, countersPtr));

    rc = internal_cpssDxChIpCntSet(devNum, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllSkippedEntriesCountersGet
*
* DESCRIPTION:
*       Get MLL entries skipped counter.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - device number
*
* OUTPUTS:
*       skipCounterPtr   - (pointer to) number of MLL entries skipped.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - on wrong input parameters
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllSkippedEntriesCountersGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *skipCounterPtr
)
{
    return cpssDxChIpMllPortGroupSkippedEntriesCountersGet(devNum,
                                            CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                            skipCounterPtr);
}

/*******************************************************************************
* cpssDxChIpMllSkippedEntriesCountersGet
*
* DESCRIPTION:
*       Get MLL entries skipped counter.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - device number
*
* OUTPUTS:
*       skipCounterPtr   - (pointer to) number of MLL entries skipped.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - on wrong input parameters
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllSkippedEntriesCountersGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *skipCounterPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllSkippedEntriesCountersGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, skipCounterPtr));

    rc = internal_cpssDxChIpMllSkippedEntriesCountersGet(devNum, skipCounterPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, skipCounterPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllPortGroupSkippedEntriesCountersGet
*
* DESCRIPTION:
*       Get MLL entries skipped counter.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum         - device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       skipCounterPtr   - (pointer to) number of MLL entries skipped.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - on wrong input parameters
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllPortGroupSkippedEntriesCountersGet
(
    IN  GT_U8                    devNum,
    IN  GT_PORT_GROUPS_BMP       portGroupsBmp,
    OUT GT_U32                   *skipCounterPtr
)
{
    GT_STATUS rc;         /* return code      */
    GT_U32    regAddr;    /* register address */
    GT_U32    regData;    /* register data    */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
          CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(skipCounterPtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLSkippedEntriesCntr;

    /* summary the counter from all port groups */
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, &regData,
                                                NULL);
    if( rc != GT_OK )
    {
        return rc;
    }

    *skipCounterPtr =  regData;

    return rc;

}

/*******************************************************************************
* cpssDxChIpMllPortGroupSkippedEntriesCountersGet
*
* DESCRIPTION:
*       Get MLL entries skipped counter.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum         - device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       skipCounterPtr   - (pointer to) number of MLL entries skipped.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - on wrong input parameters
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllPortGroupSkippedEntriesCountersGet
(
    IN  GT_U8                    devNum,
    IN  GT_PORT_GROUPS_BMP       portGroupsBmp,
    OUT GT_U32                   *skipCounterPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllPortGroupSkippedEntriesCountersGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, skipCounterPtr));

    rc = internal_cpssDxChIpMllPortGroupSkippedEntriesCountersGet(devNum, portGroupsBmp, skipCounterPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, skipCounterPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpSetMllCntInterface
*
* DESCRIPTION:
*      Sets a mll counter set's bounded inteface.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mllCntSet       - mll counter set
*                         (APPLICABLE RANGES: 0..1)
*       interfaceCfgPtr - the mll counter interface configuration
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpSetMllCntInterface
(
    IN GT_U8                                       devNum,
    IN GT_U32                                      mllCntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceCfgPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    regAddr2;             /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32    fieldData = 0;        /* Data to read/write */
    GT_U32    data = 0;
    GT_U32    data2 = 0;
    GT_U32    hwPort,hwDev;
    GT_BOOL   setSecondReg;

    CPSS_NULL_PTR_CHECK_MAC(interfaceCfgPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    /* DxCh supports 2 mll counters*/
    if(mllCntSet > 1)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr  = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLOutInterfaceCntrConfig[mllCntSet];
        regAddr2 = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLOutInterfaceCntrConfig1[mllCntSet];

        data = 0;
        data2 = 0;
        setSecondReg = GT_FALSE;

        switch (interfaceCfgPtr->portTrunkCntMode)
        {
            case CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                break;
            case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                data |= (0x1 << 30); /* <bits 30:31> = 1 indicates count port */
                if (interfaceCfgPtr->portTrunk.port > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_E_PORT_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                if (interfaceCfgPtr->hwDevNum > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_HW_DEV_NUM_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                data2 |= interfaceCfgPtr->portTrunk.port & 0xFFFFF;
                data2 |= ((interfaceCfgPtr->hwDevNum ) & 0xFFF) << 20;
                setSecondReg = GT_TRUE;
                break;
            case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                data |= (0x2 << 30); /* <bits 30:31> = 2 indicates count trunk */
                if (interfaceCfgPtr->portTrunk.trunk > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_TRUNK_ID_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                data2 |= interfaceCfgPtr->portTrunk.trunk & 0xFFF;
                setSecondReg = GT_TRUE;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        switch (interfaceCfgPtr->vlanMode)
        {
            case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                break;
            case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                if (interfaceCfgPtr->vlanId > PRV_CPSS_DXCH_PP_HW_MAX_VALUE_OF_VID_MAC(devNum))
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                data  |= (0x1 << 26); /* <bit 26> = 1 indicates count vlan */
                data  |= ((interfaceCfgPtr->vlanId & 0xFFFF) << 10);
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        switch (interfaceCfgPtr->ipMode)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                data |= (0x1 << 27); /* <bits 27:28> = 1 indicates count ipv4 */
                break;
            case CPSS_IP_PROTOCOL_IPV6_E:
                data |= (0x2 << 27); /* <bits 27:28> = 2 indicates count ipv6 */
                break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                data |= (0x0 << 27); /* <bits 27:28> = 0 indicates count all */
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }

        rc = prvCpssHwPpWriteRegister(devNum,regAddr,data);
        if (rc != GT_OK)
            return rc;

        /* on some cases, there is no need to set second register */
        if(setSecondReg == GT_TRUE)
        {
            rc = prvCpssHwPpWriteRegister(devNum,regAddr2,data2);
            if (rc != GT_OK)
                return rc;
        }
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllOutInterfaceCfg[mllCntSet];

        switch (interfaceCfgPtr->portTrunkCntMode)
        {

            case CPSS_DXCH_IP_DISREGARD_PORT_TRUNK_CNT_MODE_E:
                /*counter-set counts packets Received/Transmitted via binded Port+Dev*/
                rc = prvCpssHwPpSetRegField(devNum,regAddr,30,2,0);
                break;
            case CPSS_DXCH_IP_TRUNK_CNT_MODE_E:
                if(interfaceCfgPtr->portTrunk.trunk >= BIT_7)
                {
                    /* 7 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Set port\trunk mode to trunk */
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 30, 2, 2);
                if(GT_OK != rc)
                    return rc;
                /* Set 7 bits of the port\trunk filed and the 8th is 0. */
                rc = prvCpssHwPpSetRegField(devNum,regAddr,0, 8,
                                               interfaceCfgPtr->portTrunk.trunk);

                break;
            case CPSS_DXCH_IP_PORT_CNT_MODE_E:
                PRV_CPSS_DXCH_DUAL_HW_DEVICE_AND_PORT_CHECK_MAC(
                    interfaceCfgPtr->hwDevNum,
                    interfaceCfgPtr->portTrunk.port);
                hwDev =  PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_DEV_MAC(
                    interfaceCfgPtr->hwDevNum,
                    interfaceCfgPtr->portTrunk.port);
                hwPort = PRV_CPSS_DXCH_DUAL_HW_DEVICE_CONVERT_PORT_MAC(
                    interfaceCfgPtr->hwDevNum,
                    interfaceCfgPtr->portTrunk.port);
                if(hwPort >= BIT_6)
                {
                    /* 6 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                if(hwDev >= BIT_5)
                {
                    /* 5 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }

                /* Set port\trunk mode to port */
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 30, 2, 1);
                if(GT_OK != rc)
                    return rc;

                /* Set 6 bits of the port\trunk filed and bits 7,8 are 0. */
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 0, 8,hwPort);
                if(GT_OK != rc)
                    return rc;

                /* Set Dev*/
                rc = prvCpssHwPpSetRegField(devNum,regAddr, 8, 5,hwDev);

                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

        }

        if(GT_OK != rc)
            return rc;

        /* Set IpMode */
        switch(interfaceCfgPtr->ipMode)
        {
            case CPSS_IP_PROTOCOL_IPV4_E:
                fieldData = 1;
                break;
            case CPSS_IP_PROTOCOL_IPV6_E:
                fieldData = 2;
                break;
            case CPSS_IP_PROTOCOL_IPV4V6_E:
                fieldData = 0;
                break;
            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
        rc = prvCpssHwPpSetRegField(devNum,regAddr,27,2,fieldData);
        if(GT_OK != rc)
            return rc;


        /* Set vlan mode & vid*/
        switch (interfaceCfgPtr->vlanMode)
        {
            case CPSS_DXCH_IP_USE_VLAN_CNT_MODE_E:
                if(interfaceCfgPtr->vlanId >= BIT_12)
                {
                    /* 12 bits in HW */
                    CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
                }
                rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,1);
                if(GT_OK != rc)
                    return rc;

                rc = prvCpssHwPpSetRegField(devNum,regAddr,14,12,
                                               interfaceCfgPtr->vlanId);
                break;

            case CPSS_DXCH_IP_DISREGARD_VLAN_CNT_MODE_E:
                rc = prvCpssHwPpSetRegField(devNum,regAddr,26,1,0);
                break;

            default:
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
        }
    }

    return rc;

}

/*******************************************************************************
* cpssDxChIpSetMllCntInterface
*
* DESCRIPTION:
*      Sets a mll counter set's bounded inteface.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mllCntSet       - mll counter set
*                         (APPLICABLE RANGES: 0..1)
*       interfaceCfgPtr - the mll counter interface configuration
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpSetMllCntInterface
(
    IN GT_U8                                       devNum,
    IN GT_U32                                      mllCntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_INTERFACE_CFG_STC *interfaceCfgPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSetMllCntInterface);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllCntSet, interfaceCfgPtr));

    rc = internal_cpssDxChIpSetMllCntInterface(devNum, mllCntSet, interfaceCfgPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllCntSet, interfaceCfgPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllCntGet
*
* DESCRIPTION:
*      Get the mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum     - the device number.
*       mllCntSet  - the mll counter set out of the 2
*
* OUTPUTS:
*       mllOutMCPktsPtr - According to the configuration of this cnt set, The
*                      number of routed IP Multicast packets Duplicated by the
*                      MLL Engine and transmitted via this interface
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllCntGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mllCntSet,
    OUT GT_U32  *mllOutMCPktsPtr
)
{
    return cpssDxChIpPortGroupMllCntGet(devNum,
                                        CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                        mllCntSet, mllOutMCPktsPtr);
}

/*******************************************************************************
* cpssDxChIpMllCntGet
*
* DESCRIPTION:
*      Get the mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum     - the device number.
*       mllCntSet  - the mll counter set out of the 2
*
* OUTPUTS:
*       mllOutMCPktsPtr - According to the configuration of this cnt set, The
*                      number of routed IP Multicast packets Duplicated by the
*                      MLL Engine and transmitted via this interface
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllCntGet
(
    IN  GT_U8   devNum,
    IN  GT_U32  mllCntSet,
    OUT GT_U32  *mllOutMCPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllCntSet, mllOutMCPktsPtr));

    rc = internal_cpssDxChIpMllCntGet(devNum, mllCntSet, mllOutMCPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllCntSet, mllOutMCPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllCntSet
*
* DESCRIPTION:
*      set an mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*       mllCntSet       - the mll counter set out of the 2
*       mllOutMCPkts    - the counter value to set
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllCntSet
(
    IN GT_U8    devNum,
    IN GT_U32   mllCntSet,
    IN GT_U32   mllOutMCPkts
)
{
    return cpssDxChIpPortGroupMllCntSet(devNum,
                                        CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                        mllCntSet, mllOutMCPkts);
}

/*******************************************************************************
* cpssDxChIpMllCntSet
*
* DESCRIPTION:
*      set an mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*       mllCntSet       - the mll counter set out of the 2
*       mllOutMCPkts    - the counter value to set
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllCntSet
(
    IN GT_U8    devNum,
    IN GT_U32   mllCntSet,
    IN GT_U32   mllOutMCPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mllCntSet, mllOutMCPkts));

    rc = internal_cpssDxChIpMllCntSet(devNum, mllCntSet, mllOutMCPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mllCntSet, mllOutMCPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllSilentDropCntGet
*
* DESCRIPTION:
*      Get the silent drops in the MLL priority queues.
*      A silent drop is a drop that is applied to a replica of the packet that
*      was previously replicated in the TTI.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       silentDropPktsPtr - (pointer to) the number of counted silent dropped packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllSilentDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *silentDropPktsPtr
)
{
    return cpssDxChIpMllPortGroupSilentDropCntGet(devNum,
                                         CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                         silentDropPktsPtr);
}

/*******************************************************************************
* cpssDxChIpMllSilentDropCntGet
*
* DESCRIPTION:
*      Get the silent drops in the MLL priority queues.
*      A silent drop is a drop that is applied to a replica of the packet that
*      was previously replicated in the TTI.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       silentDropPktsPtr - (pointer to) the number of counted silent dropped packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllSilentDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *silentDropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllSilentDropCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, silentDropPktsPtr));

    rc = internal_cpssDxChIpMllSilentDropCntGet(devNum, silentDropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, silentDropPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllPortGroupSilentDropCntGet
*
* DESCRIPTION:
*      Get the silent drops in the MLL priority queues.
*      A silent drop is a drop that is applied to a replica of the packet that
*      was previously replicated in the TTI.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* OUTPUTS:
*       silentDropPktsPtr - (pointer to) the number of counted silent dropped packets.

* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllPortGroupSilentDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *silentDropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
          CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(silentDropPktsPtr);


    regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.MLLSilentDropCntr;

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, silentDropPktsPtr, NULL);
    return rc;
}

/*******************************************************************************
* cpssDxChIpMllPortGroupSilentDropCntGet
*
* DESCRIPTION:
*      Get the silent drops in the MLL priority queues.
*      A silent drop is a drop that is applied to a replica of the packet that
*      was previously replicated in the TTI.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
* OUTPUTS:
*       silentDropPktsPtr - (pointer to) the number of counted silent dropped packets.

* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllPortGroupSilentDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *silentDropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllPortGroupSilentDropCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, silentDropPktsPtr));

    rc = internal_cpssDxChIpMllPortGroupSilentDropCntGet(devNum, portGroupsBmp, silentDropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, silentDropPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}
/*******************************************************************************
* internal_cpssDxChIpDropCntSet
*
* DESCRIPTION:
*      set the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*       dropPkts - the counter value to set
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpDropCntSet
(
    IN GT_U8 devNum,
    IN GT_U32 dropPkts
)
{
    return cpssDxChIpPortGroupDropCntSet(devNum,
                                         CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                         dropPkts);
}

/*******************************************************************************
* cpssDxChIpDropCntSet
*
* DESCRIPTION:
*      set the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*       dropPkts - the counter value to set
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpDropCntSet
(
    IN GT_U8 devNum,
    IN GT_U32 dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpDropCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPkts));

    rc = internal_cpssDxChIpDropCntSet(devNum, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpSetDropCntMode
*
* DESCRIPTION:
*      Sets the drop counter count mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*       dropCntMode - the drop counter count mode
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpSetDropCntMode
(
    IN GT_U8                          devNum,
    IN CPSS_DXCH_IP_DROP_CNT_MODE_ENT dropCntMode
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    value;                /* value to write to register         */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntrConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCntCfgReg;
    }

    switch (dropCntMode)
    {
        case CPSS_DXCH_IP_DROP_CNT_COUNT_ALL_MODE_E             :
            value = 0;
            break;
        case CPSS_DXCH_IP_DROP_CNT_IP_HEADER_MODE_E             :
            value = 1;
            break;
        case CPSS_DXCH_IP_DROP_CNT_DIP_DA_MISMATCH_MODE_E       :
            value = 2;
            break;
        case CPSS_DXCH_IP_DROP_CNT_ILLEGAL_ADDRESS_MODE_E       :
            value = 3;
            break;
        case CPSS_DXCH_IP_DROP_CNT_SIP_ALL_ZEROS_MODE_E         :
            value = 4;
            break;
        case CPSS_DXCH_IP_DROP_CNT_SIP_SA_MISMATCH_MODE_E       :
            value = 5;
            break;
        case CPSS_DXCH_IP_DROP_CNT_UC_RPF_MODE_E                :
            value = 6;
            break;
        case CPSS_DXCH_IP_DROP_CNT_NH_CMD_MODE_E                :
            value = 7;
            break;
        case CPSS_DXCH_IP_DROP_CNT_MC_RPF_MODE_E                :
            value = 8;
            break;
        case CPSS_DXCH_IP_DROP_CNT_TTL_HOP_LIMIT_EXCEEDED_MODE_E:
            value = 9;
            break;
        case CPSS_DXCH_IP_DROP_CNT_MTU_EXCEEDED_MODE_E          :
            value = 10;
            break;
        case CPSS_DXCH_IP_DROP_CNT_OPTION_MODE_E                :
            value = 11;
            break;
        case CPSS_DXCH_IP_DROP_CNT_IPV6_SCOPE_MODE_E            :
            value = 13;
            break;
        case CPSS_DXCH_IP_DROP_CNT_UC_SIP_FILTER_MODE_E         :
            value = 14;
            break;
        case CPSS_DXCH_IP_DROP_CNT_ACCESS_MATRIX_MODE_E         :
            value = 15;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return prvCpssHwPpSetRegField(devNum,regAddr, 0,4, value);
}

/*******************************************************************************
* cpssDxChIpSetDropCntMode
*
* DESCRIPTION:
*      Sets the drop counter count mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum      - the device number
*       dropCntMode - the drop counter count mode
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpSetDropCntMode
(
    IN GT_U8                          devNum,
    IN CPSS_DXCH_IP_DROP_CNT_MODE_ENT dropCntMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpSetDropCntMode);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropCntMode));

    rc = internal_cpssDxChIpSetDropCntMode(devNum, dropCntMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropCntMode));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpGetDropCntMode
*
* DESCRIPTION:
*      Gets the drop counter count mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*
* OUTPUTS:
*       dropCntModePtr  - (pointer to) the drop counter count mode
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_BAD_PTR               - on NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpGetDropCntMode
(
    IN  GT_U8                          devNum,
    OUT CPSS_DXCH_IP_DROP_CNT_MODE_ENT *dropCntModePtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_U32    value;                /* value to write to register         */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    if (dropCntModePtr == NULL)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PTR, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntrConfig;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCntCfgReg;
    }

    rc = prvCpssHwPpGetRegField(devNum,regAddr, 0,4, &value);
    if (rc != GT_OK)
        {
        return rc;
    }

    switch (value)
    {
        case 0:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_COUNT_ALL_MODE_E;
            break;
        case 1:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_IP_HEADER_MODE_E;
            break;
        case 2:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_DIP_DA_MISMATCH_MODE_E;
            break;
        case 3:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_ILLEGAL_ADDRESS_MODE_E;
            break;
        case 4:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_SIP_ALL_ZEROS_MODE_E;
            break;
        case 5:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_SIP_SA_MISMATCH_MODE_E;
            break;
        case 6:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_UC_RPF_MODE_E;
            break;
        case 7:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_NH_CMD_MODE_E;
            break;
        case 8:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_MC_RPF_MODE_E;
            break;
        case 9:
            *dropCntModePtr =
                            CPSS_DXCH_IP_DROP_CNT_TTL_HOP_LIMIT_EXCEEDED_MODE_E;
            break;
        case 10:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_MTU_EXCEEDED_MODE_E;
            break;
        case 11:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_OPTION_MODE_E;
            break;
        case 13:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_IPV6_SCOPE_MODE_E;
            break;
        case 14:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_UC_SIP_FILTER_MODE_E;
            break;
        case 15:
            *dropCntModePtr = CPSS_DXCH_IP_DROP_CNT_ACCESS_MATRIX_MODE_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpGetDropCntMode
*
* DESCRIPTION:
*      Gets the drop counter count mode.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*
* OUTPUTS:
*       dropCntModePtr  - (pointer to) the drop counter count mode
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_BAD_PTR               - on NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpGetDropCntMode
(
    IN  GT_U8                          devNum,
    OUT CPSS_DXCH_IP_DROP_CNT_MODE_ENT *dropCntModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpGetDropCntMode);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropCntModePtr));

    rc = internal_cpssDxChIpGetDropCntMode(devNum, dropCntModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropCntModePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpDropCntGet
*
* DESCRIPTION:
*      Get the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets according to the
*                     drop counter mode.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *dropPktsPtr
)
{
    return cpssDxChIpPortGroupDropCntGet(devNum,
                                         CPSS_PORT_GROUP_UNAWARE_MODE_CNS,
                                         dropPktsPtr);
}

/*******************************************************************************
* cpssDxChIpDropCntGet
*
* DESCRIPTION:
*      Get the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets according to the
*                     drop counter mode.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpDropCntGet
(
    IN  GT_U8  devNum,
    OUT GT_U32 *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpDropCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, dropPktsPtr));

    rc = internal_cpssDxChIpDropCntGet(devNum, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMtuProfileSet
*
* DESCRIPTION:
*       Sets the next hop interface MTU profile limit value.
*
* APPLICABLE DEVICES:
*       DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mtuProfileIndex - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
*       mtu             - the maximum transmission unit (APPLICABLE RANGES: 0..0x3FFF).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMtuProfileSet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    IN GT_U32 mtu
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32  i,bits_offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    if(mtuProfileIndex > 7)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(mtu > 0x3FFF)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    i = mtuProfileIndex/2;
    bits_offset = mtuProfileIndex % 2;

    /* for index =0,1 -> offset 0x4, 1,2 - 0x8 end and so on*/
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerMTUConfigReg[i];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMtuCfgRegs[i];
    }

    bits_offset *=14;

    rc = prvCpssHwPpSetRegField(devNum,regAddr,bits_offset ,14,mtu);
    return rc;
}

/*******************************************************************************
* cpssDxChIpMtuProfileSet
*
* DESCRIPTION:
*       Sets the next hop interface MTU profile limit value.
*
* APPLICABLE DEVICES:
*       DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mtuProfileIndex - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
*       mtu             - the maximum transmission unit (APPLICABLE RANGES: 0..0x3FFF).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMtuProfileSet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    IN GT_U32 mtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMtuProfileSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuProfileIndex, mtu));

    rc = internal_cpssDxChIpMtuProfileSet(devNum, mtuProfileIndex, mtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuProfileIndex, mtu));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMtuProfileGet
*
* DESCRIPTION:
*       Gets the next hop interface MTU profile limit value.
*
* APPLICABLE DEVICES:
*       DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mtuProfileIndex - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
*
* OUTPUTS:
*       mtuPtr             - the maximum transmission unit
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMtuProfileGet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    OUT GT_U32 *mtuPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32  i,bits_offset;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(mtuPtr);

    if(mtuProfileIndex > 7)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);


    i = mtuProfileIndex/2;
    bits_offset = mtuProfileIndex % 2;

    /* for index =0,1 -> offset 0x4, 1,2 - 0x8 end and so on*/
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerMTUConfigReg[i];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMtuCfgRegs[i];
    }

    bits_offset *=14;

    rc = prvCpssHwPpGetRegField(devNum,regAddr,bits_offset ,14,mtuPtr);
    return rc;
}

/*******************************************************************************
* cpssDxChIpMtuProfileGet
*
* DESCRIPTION:
*       Gets the next hop interface MTU profile limit value.
*
* APPLICABLE DEVICES:
*       DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number
*       mtuProfileIndex - the mtu profile index out of the possible 8 (APPLICABLE RANGES: 0..7).
*
* OUTPUTS:
*       mtuPtr             - the maximum transmission unit
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - on NULL pointer
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMtuProfileGet
(
    IN GT_U8  devNum,
    IN GT_U32 mtuProfileIndex,
    OUT GT_U32 *mtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMtuProfileGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuProfileIndex, mtuPtr));

    rc = internal_cpssDxChIpMtuProfileGet(devNum, mtuProfileIndex, mtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuProfileIndex, mtuPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpv6AddrPrefixScopeSet
*
* DESCRIPTION:
*       Defines a prefix of a scope type.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       prefix           - an IPv6 address prefix
*       prefixLen        - length of the prefix (APPLICABLE RANGES: 0..16)
*       addressScope     - type of the address scope spanned by the prefix
*       prefixScopeIndex - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on error.
*       GT_BAD_PARAM             - case that the prefix length is out of range.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Configures an entry in the prefix look up table
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpv6AddrPrefixScopeSet
(
    IN  GT_U8                           devNum,
    IN  GT_IPV6ADDR                     prefix,
    IN  GT_U32                          prefixLen,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT      addressScope,
    IN  GT_U32                          prefixScopeIndex
)
{

    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_STATUS addressScopeValue;

    GT_U32      value=0, mask=0, prefixValue=0;     /* value to write   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    if (prefixLen > 16)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    switch(addressScope)
    {
    case CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E:
        addressScopeValue = 0;
        break;
    case CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E:
        addressScopeValue = 1;
        break;
    case CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E:
        addressScopeValue = 2;
        break;
    case CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E:
        addressScopeValue = 3;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(prefixScopeIndex > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    mask = 0xFFFF << (16-prefixLen);
    mask = mask << 16;
    prefixValue = prefix.arIP[0] << 8;
    prefixValue = prefixValue | prefix.arIP[1];
    prefixValue = 0x0000FFFF & prefixValue;
    value = prefixValue | mask;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopePrefix[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeRegs[prefixScopeIndex];
    }

    rc = prvCpssHwPpWriteRegister(devNum,regAddr,value);
    if (rc != GT_OK)
        {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeLevel[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeLevel[prefixScopeIndex];
    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, 0, 2, addressScopeValue);

    return rc;

}

/*******************************************************************************
* cpssDxChIpv6AddrPrefixScopeSet
*
* DESCRIPTION:
*       Defines a prefix of a scope type.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       prefix           - an IPv6 address prefix
*       prefixLen        - length of the prefix (APPLICABLE RANGES: 0..16)
*       addressScope     - type of the address scope spanned by the prefix
*       prefixScopeIndex - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on error.
*       GT_BAD_PARAM             - case that the prefix length is out of range.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Configures an entry in the prefix look up table
*
*******************************************************************************/
GT_STATUS cpssDxChIpv6AddrPrefixScopeSet
(
    IN  GT_U8                           devNum,
    IN  GT_IPV6ADDR                     prefix,
    IN  GT_U32                          prefixLen,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT      addressScope,
    IN  GT_U32                          prefixScopeIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6AddrPrefixScopeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, prefix, prefixLen, addressScope, prefixScopeIndex));

    rc = internal_cpssDxChIpv6AddrPrefixScopeSet(devNum, prefix, prefixLen, addressScope, prefixScopeIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, prefix, prefixLen, addressScope, prefixScopeIndex));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpv6AddrPrefixScopeGet
*
* DESCRIPTION:
*       Get a prefix of a scope type.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       prefixScopeIndex - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* OUTPUTS:
*       prefixPtr        - an IPv6 address prefix
*       prefixLenPtr     - length of the prefix
*       addressScopePtr  - type of the address scope spanned by the prefix
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on error.
*       GT_BAD_PARAM             - case that the prefix length is out of range.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpv6AddrPrefixScopeGet
(
    IN  GT_U8                           devNum,
    OUT GT_IPV6ADDR                     *prefixPtr,
    OUT GT_U32                          *prefixLenPtr,
    OUT CPSS_IPV6_PREFIX_SCOPE_ENT      *addressScopePtr,
    IN  GT_U32                          prefixScopeIndex
)
{
    GT_U32      regAddr;              /* register address  */
    GT_STATUS   rc;                   /* return code  */
    GT_U32      addressScopeValue;
    GT_U32      hwValue;              /* hwValue */
    GT_U32      mask = 0;
    GT_U32      tmp = 0;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(prefixPtr);
    CPSS_NULL_PTR_CHECK_MAC(prefixLenPtr);
    CPSS_NULL_PTR_CHECK_MAC(addressScopePtr);

    if(prefixScopeIndex > 3)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopePrefix[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeRegs[prefixScopeIndex];
    }

    rc = prvCpssHwPpReadRegister(devNum,regAddr,&hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    /* calculate prefix len from hwValue */
    mask = hwValue >> 16;

    while ( ((mask >> (15 - tmp)) & 0x1)  &&  tmp <= 15)
    {
        tmp++;
    }

    *prefixLenPtr = tmp;


    /* calculate IPv6 address prefix from hwValue */
    prefixPtr->arIP[1] = (GT_U8)(hwValue & 0xFF);
    prefixPtr->arIP[0] = (GT_U8)((hwValue>>8) & 0xFF);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeLevel[prefixScopeIndex];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ipScopeLevel[prefixScopeIndex];
    }

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 2, &addressScopeValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    switch(addressScopeValue)
    {
    case 0:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E;
        break;
    case 1:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E;
        break;
    case 2:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E;
        break;
    case 3:
        *addressScopePtr = CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpv6AddrPrefixScopeGet
*
* DESCRIPTION:
*       Get a prefix of a scope type.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       prefixScopeIndex - index of the new prefix scope entry (APPLICABLE RANGES: 0..3)
*
* OUTPUTS:
*       prefixPtr        - an IPv6 address prefix
*       prefixLenPtr     - length of the prefix
*       addressScopePtr  - type of the address scope spanned by the prefix
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_FAIL                  - on error.
*       GT_BAD_PARAM             - case that the prefix length is out of range.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpv6AddrPrefixScopeGet
(
    IN  GT_U8                           devNum,
    OUT GT_IPV6ADDR                     *prefixPtr,
    OUT GT_U32                          *prefixLenPtr,
    OUT CPSS_IPV6_PREFIX_SCOPE_ENT      *addressScopePtr,
    IN  GT_U32                          prefixScopeIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6AddrPrefixScopeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, prefixPtr, prefixLenPtr, addressScopePtr, prefixScopeIndex));

    rc = internal_cpssDxChIpv6AddrPrefixScopeGet(devNum, prefixPtr, prefixLenPtr, addressScopePtr, prefixScopeIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, prefixPtr, prefixLenPtr, addressScopePtr, prefixScopeIndex));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpv6UcScopeCommandSet
*
* DESCRIPTION:
*       sets the ipv6 Unicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
*       scopeCommand     - action to be done on a packet that match the above
*                          scope configuration.
*                          possible commands:
*                           CPSS_PACKET_CMD_ROUTE_E,
*                           CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                           CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                           CPSS_PACKET_CMD_DROP_SOFT_E,
*                           CPSS_PACKET_CMD_DROP_HARD_E
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpv6UcScopeCommandSet
(
    IN GT_U8                      devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN GT_BOOL                    borderCrossed,
    IN CPSS_PACKET_CMD_ENT        scopeCommand
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32      value=0;        /* value to write   */
    GT_U32   offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucScopeTblRegs[addressScopeSrc];
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    switch (scopeCommand)
    {
    case CPSS_PACKET_CMD_ROUTE_E:
        value = 0;
        break;

    case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
        value = 2;
        break;

    case CPSS_PACKET_CMD_DROP_SOFT_E:
        value = 4;
        break;

    case CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E:
        value = 1;
        break;

    case CPSS_PACKET_CMD_DROP_HARD_E:
        value = 3;
        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 3, value);

    return rc;
}

/*******************************************************************************
* cpssDxChIpv6UcScopeCommandSet
*
* DESCRIPTION:
*       sets the ipv6 Unicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
*       scopeCommand     - action to be done on a packet that match the above
*                          scope configuration.
*                          possible commands:
*                           CPSS_PACKET_CMD_ROUTE_E,
*                           CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                           CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                           CPSS_PACKET_CMD_DROP_SOFT_E,
*                           CPSS_PACKET_CMD_DROP_HARD_E
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpv6UcScopeCommandSet
(
    IN GT_U8                      devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN GT_BOOL                    borderCrossed,
    IN CPSS_PACKET_CMD_ENT        scopeCommand
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6UcScopeCommandSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand));

    rc = internal_cpssDxChIpv6UcScopeCommandSet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpv6UcScopeCommandGet
*
* DESCRIPTION:
*       gets the ipv6 Unicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
* OUTPUTS:
*       scopeCommandPtr  - action to be done on a packet that match the above
*                          scope configuration.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpv6UcScopeCommandGet
(
    IN  GT_U8                      devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN  GT_BOOL                    borderCrossed,
    OUT CPSS_PACKET_CMD_ENT        *scopeCommandPtr
)
{
    GT_U32      regAddr;          /* register address  */
    GT_STATUS   rc;               /* return code  */
    GT_U32      hwValue = 0;      /* hw value  */
    GT_U32      offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(scopeCommandPtr);


    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6UcScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.ucScopeTblRegs[addressScopeSrc];
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 3, &hwValue);
    if(GT_OK != rc)
    {
        return rc;
    }

    switch (hwValue)
    {
    case 0:
        *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_E;
        break;
    case 2:
        *scopeCommandPtr = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
        break;
    case 4:
        *scopeCommandPtr = CPSS_PACKET_CMD_DROP_SOFT_E;
        break;
    case 1:
        *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;
        break;
    case 3:
        *scopeCommandPtr = CPSS_PACKET_CMD_DROP_HARD_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpv6UcScopeCommandGet
*
* DESCRIPTION:
*       gets the ipv6 Unicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
* OUTPUTS:
*       scopeCommandPtr  - action to be done on a packet that match the above
*                          scope configuration.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpv6UcScopeCommandGet
(
    IN  GT_U8                      devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT addressScopeDest,
    IN  GT_BOOL                    borderCrossed,
    OUT CPSS_PACKET_CMD_ENT        *scopeCommandPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6UcScopeCommandGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr));

    rc = internal_cpssDxChIpv6UcScopeCommandGet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpv6McScopeCommandSet
*
* DESCRIPTION:
*       sets the ipv6 Multicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
*       scopeCommand     - action to be done on a packet that match the above
*                          scope configuration.
*                          possible commands:
*                           CPSS_PACKET_CMD_ROUTE_E,
*                           CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                           CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                           CPSS_PACKET_CMD_DROP_SOFT_E,
*                           CPSS_PACKET_CMD_DROP_HARD_E,
*                           CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                           CPSS_PACKET_CMD_BRIDGE_E
*       mllSelectionRule - rule for choosing MLL for IPv6 Multicast propogation
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpv6McScopeCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN GT_BOOL                          borderCrossed,
    IN CPSS_PACKET_CMD_ENT              scopeCommand,
    IN CPSS_IPV6_MLL_SELECTION_RULE_ENT mllSelectionRule
)
{

    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U32      value=0;        /* value to write   */
    GT_U32   offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6McScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcScopeTblRegs[addressScopeSrc];
    }

    switch (scopeCommand)
    {
        case CPSS_PACKET_CMD_ROUTE_E:
            value = 0;
            break;
        case CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E:
            value = 1;
            break;
        case CPSS_PACKET_CMD_TRAP_TO_CPU_E:
            value = 2;
            break;
        case CPSS_PACKET_CMD_DROP_HARD_E:
            value = 3;
            break;

        case CPSS_PACKET_CMD_DROP_SOFT_E:
            value = 4;
            break;

        case CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E:
            value = 5;
            break;
        case CPSS_PACKET_CMD_BRIDGE_E:
            value = 6;
                break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset, 3, value);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

        /* write MLL Select */

    switch(mllSelectionRule)
    {
        case CPSS_IPV6_MLL_SELECTION_RULE_LOCAL_E:
             value = 0;
             break;
        case CPSS_IPV6_MLL_SELECTION_RULE_GLOBAL_E:
             value = 1;
             break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    rc = prvCpssHwPpSetRegField(devNum, regAddr, offset+3, 1, value);
    return rc;
}

/*******************************************************************************
* cpssDxChIpv6McScopeCommandSet
*
* DESCRIPTION:
*       sets the ipv6 Multicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
*       scopeCommand     - action to be done on a packet that match the above
*                          scope configuration.
*                          possible commands:
*                           CPSS_PACKET_CMD_ROUTE_E,
*                           CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                           CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                           CPSS_PACKET_CMD_DROP_SOFT_E,
*                           CPSS_PACKET_CMD_DROP_HARD_E,
*                           CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                           CPSS_PACKET_CMD_BRIDGE_E
*       mllSelectionRule - rule for choosing MLL for IPv6 Multicast propogation
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpv6McScopeCommandSet
(
    IN GT_U8                            devNum,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN GT_BOOL                          borderCrossed,
    IN CPSS_PACKET_CMD_ENT              scopeCommand,
    IN CPSS_IPV6_MLL_SELECTION_RULE_ENT mllSelectionRule
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6McScopeCommandSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand, mllSelectionRule));

    rc = internal_cpssDxChIpv6McScopeCommandSet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand, mllSelectionRule);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommand, mllSelectionRule));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpv6McScopeCommandGet
*
* DESCRIPTION:
*       gets the ipv6 Multicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
* OUTPUTS:
*       scopeCommandPtr     - action to be done on a packet that match the above
*                             scope configuration.
*                             possible commands:
*                             CPSS_PACKET_CMD_ROUTE_E,
*                             CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                             CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                             CPSS_PACKET_CMD_DROP_SOFT_E,
*                             CPSS_PACKET_CMD_DROP_HARD_E,
*                             CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                             CPSS_PACKET_CMD_BRIDGE_E
*       mllSelectionRulePtr - rule for choosing MLL for IPv6 Multicast propogation
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpv6McScopeCommandGet
(
    IN  GT_U8                            devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN  GT_BOOL                          borderCrossed,
    OUT CPSS_PACKET_CMD_ENT              *scopeCommandPtr,
    OUT CPSS_IPV6_MLL_SELECTION_RULE_ENT *mllSelectionRulePtr
)
{
    GT_U32      regAddr;            /* register address  */
    GT_STATUS   rc;                 /* return code  */
    GT_U32      hwValue=0;          /* hw value */
    GT_U32      offset;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);
    CPSS_NULL_PTR_CHECK_MAC(scopeCommandPtr);
    CPSS_NULL_PTR_CHECK_MAC(mllSelectionRulePtr);


    if ((addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeSrc != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if ((addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_LINK_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_SITE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_UNIQUE_LOCAL_E) &&
        (addressScopeDest != CPSS_IPV6_PREFIX_SCOPE_GLOBAL_E))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.IPv6Scope.IPv6McScopeTableReg[addressScopeSrc];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipv6Regs.mcScopeTblRegs[addressScopeSrc];
    }

    /* if the border was not crossed, meaning source Site ID == Dest Site ID
       the offset=4. if the border was crossed the offset=0 */
    if (borderCrossed == GT_FALSE)
    {
        offset = 4;
    }
    else
    {
        offset = 0;
    }

    offset += (addressScopeDest*8);

    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset, 3, &hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    switch (hwValue)
    {
        case 0:
            *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_E;
            break;
        case 1:
            *scopeCommandPtr = CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E;
            break;
        case 2:
            *scopeCommandPtr = CPSS_PACKET_CMD_TRAP_TO_CPU_E;
            break;
        case 3:
            *scopeCommandPtr = CPSS_PACKET_CMD_DROP_HARD_E;
            break;
        case 4:
            *scopeCommandPtr = CPSS_PACKET_CMD_DROP_SOFT_E;
            break;
        case 5:
            *scopeCommandPtr = CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E;
            break;
        case 6:
            *scopeCommandPtr = CPSS_PACKET_CMD_BRIDGE_E;
                break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* read MLL Select */
    rc = prvCpssHwPpGetRegField(devNum, regAddr, offset+3, 1, &hwValue);
    if (rc != GT_OK)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    }

    switch(hwValue)
    {
        case 0:
             *mllSelectionRulePtr = CPSS_IPV6_MLL_SELECTION_RULE_LOCAL_E;
             break;
        case 1:
             *mllSelectionRulePtr = CPSS_IPV6_MLL_SELECTION_RULE_GLOBAL_E;
             break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpv6McScopeCommandGet
*
* DESCRIPTION:
*       gets the ipv6 Multicast scope commands.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum           - the device number
*       addressScopeSrc  - IPv6 address scope of source address
*       addressScopeDest - IPv6 address scope of destination address
*       borderCrossed    - GT_TRUE if source site ID is diffrent to destination
*                          site ID
* OUTPUTS:
*       scopeCommandPtr     - action to be done on a packet that match the above
*                             scope configuration.
*                             possible commands:
*                             CPSS_PACKET_CMD_ROUTE_E,
*                             CPSS_PACKET_CMD_ROUTE_AND_MIRROR_E,
*                             CPSS_PACKET_CMD_TRAP_TO_CPU_E,
*                             CPSS_PACKET_CMD_DROP_SOFT_E,
*                             CPSS_PACKET_CMD_DROP_HARD_E,
*                             CPSS_PACKET_CMD_BRIDGE_AND_MIRROR_E,
*                             CPSS_PACKET_CMD_BRIDGE_E
*       mllSelectionRulePtr - rule for choosing MLL for IPv6 Multicast propogation
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_FAIL                  - on error.
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_NO_RESOURCE           - if failed to allocate CPU memory
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_BAD_PTR               - on NULL ptr
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpv6McScopeCommandGet
(
    IN  GT_U8                            devNum,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeSrc,
    IN  CPSS_IPV6_PREFIX_SCOPE_ENT       addressScopeDest,
    IN  GT_BOOL                          borderCrossed,
    OUT CPSS_PACKET_CMD_ENT              *scopeCommandPtr,
    OUT CPSS_IPV6_MLL_SELECTION_RULE_ENT *mllSelectionRulePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpv6McScopeCommandGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr, mllSelectionRulePtr));

    rc = internal_cpssDxChIpv6McScopeCommandGet(devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr, mllSelectionRulePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, addressScopeSrc, addressScopeDest, borderCrossed, scopeCommandPtr, mllSelectionRulePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterMacSaBaseSet
*
* DESCRIPTION:
*       Sets 40 MSBs of Router MAC SA Base address on specified device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - the device number
*       macPtr - (pointer to)The system Mac address to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterMacSaBaseSet
(
    IN  GT_U8           devNum,
    IN  GT_ETHERADDR    *macPtr
)
{
    GT_U32  macBytes1234;          /* Holds bits 8 - 39 of mac   (bytes 1,2,3,4)  */
    GT_U32  macMsbByte;            /* Holds bits 40 - 47 of mac  (byte 0)  */
    GT_STATUS rc = GT_OK;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(macPtr);

    macBytes1234 = (macPtr->arEther[4]        |
                  (macPtr->arEther[3] << 8)  |
                  (macPtr->arEther[2] << 16) |
                  (macPtr->arEther[1] << 24));
    macMsbByte =  macPtr->arEther[0];

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssHwPpWriteRegister(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg0,
               macBytes1234);
        if(rc != GT_OK)
            return rc;

        rc = prvCpssHwPpSetRegField(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg1,
               0,8,
               macMsbByte);
    }
    else
    {
    rc = prvCpssHwPpWriteRegister(devNum,
           PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[0],macBytes1234);
    if(rc != GT_OK)
        return rc;

    rc = prvCpssHwPpSetRegField(devNum,
           PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[1],0,8,macMsbByte);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterMacSaBaseSet
*
* DESCRIPTION:
*       Sets 40 MSBs of Router MAC SA Base address on specified device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - the device number
*       macPtr - (pointer to)The system Mac address to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterMacSaBaseSet
(
    IN  GT_U8           devNum,
    IN  GT_ETHERADDR    *macPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaBaseSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, macPtr));

    rc = internal_cpssDxChIpRouterMacSaBaseSet(devNum, macPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, macPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterMacSaBaseGet
*
* DESCRIPTION:
*       Get 40 MSBs of Router MAC SA Base address on specified device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - the device number
*
* OUTPUTS:
*       macPtr - (pointer to)The system Mac address to set.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterMacSaBaseGet
(
    IN  GT_U8           devNum,
    OUT GT_ETHERADDR    *macPtr
)
{
    GT_STATUS rc;
    GT_U32  macBytes1234;          /* Holds bits 8 - 39 of mac   (bytes 1,2,3,4)  */
    GT_U32  macMsbByte;            /* Holds bits 40 - 47 of mac  (byte 0)  */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(macPtr);


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssHwPpReadRegister(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg0,
               &macBytes1234);
        if(rc != GT_OK)
            return rc;

        rc = prvCpssHwPpGetRegField(devNum,
               PRV_DXCH_REG1_UNIT_HA_MAC(devNum).routerMACSABaseReg1,
               0,8,
               &macMsbByte);
    }
    else
    {
        rc = prvCpssHwPpReadRegister(devNum,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[0],&macBytes1234);
        if(rc != GT_OK)
            return rc;

        rc = prvCpssHwPpGetRegField(devNum,
        PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerMacSaBaseReg[1],0,8,&macMsbByte);
    }

    if(rc != GT_OK)
        return rc;

    macPtr->arEther[4] = (GT_U8)(macBytes1234 >>  0);
    macPtr->arEther[3] = (GT_U8)(macBytes1234 >>  8);
    macPtr->arEther[2] = (GT_U8)(macBytes1234 >> 16);
    macPtr->arEther[1] = (GT_U8)(macBytes1234 >> 24);
    macPtr->arEther[0] = (GT_U8)macMsbByte;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpRouterMacSaBaseGet
*
* DESCRIPTION:
*       Get 40 MSBs of Router MAC SA Base address on specified device.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum - the device number
*
* OUTPUTS:
*       macPtr - (pointer to)The system Mac address to set.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterMacSaBaseGet
(
    IN  GT_U8           devNum,
    OUT GT_ETHERADDR    *macPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaBaseGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, macPtr));

    rc = internal_cpssDxChIpRouterMacSaBaseGet(devNum, macPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, macPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterMacSaLsbModeSet
*
* DESCRIPTION:
*       Sets the mode in which the device sets the packet's MAC SA least
*       significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*       saLsbMode       - The MAC SA least-significant bit mode
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       The device 5 most significant bytes are set by cpssDxChIpRouterMacSaBaseSet().
*
*       The least significant bytes are set by cpssDxChIpRouterPortVlanMacSaLsbSet().
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterMacSaLsbModeSet
(
    IN  GT_U8                        devNum,
    IN  CPSS_MAC_SA_LSB_MODE_ENT     saLsbMode
)
{
    GT_U32      hwData; /* value to write into register   */
    GT_STATUS   rc ;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);


     /* setting the Lsb mode */
    switch (saLsbMode)
    {
        case CPSS_SA_LSB_PER_PORT_E:
            hwData = 2;
            break;
        case CPSS_SA_LSB_PER_PKT_VID_E:
            hwData = 0;
            break;
        case CPSS_SA_LSB_PER_VLAN_E:
            hwData = 1;
            break;
        default:

        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    rc = prvCpssHwPpWriteRegister(
               devNum,
               PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig,
               hwData);
    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterMacSaLsbModeSet
*
* DESCRIPTION:
*       Sets the mode in which the device sets the packet's MAC SA least
*       significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*       saLsbMode       - The MAC SA least-significant bit mode
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       The device 5 most significant bytes are set by cpssDxChIpRouterMacSaBaseSet().
*
*       The least significant bytes are set by cpssDxChIpRouterPortVlanMacSaLsbSet().
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterMacSaLsbModeSet
(
    IN  GT_U8                        devNum,
    IN  CPSS_MAC_SA_LSB_MODE_ENT     saLsbMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaLsbModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, saLsbMode));

    rc = internal_cpssDxChIpRouterMacSaLsbModeSet(devNum, saLsbMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, saLsbMode));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterMacSaLsbModeGet
*
* DESCRIPTION:
*       Gets the mode in which the device sets the packet's MAC SA least
*       significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*
* OUTPUTS:
*       saLsbModePtr    - (pointer to) The MAC SA least-significant bit mode
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterMacSaLsbModeGet
(
    IN  GT_U8                        devNum,
    OUT CPSS_MAC_SA_LSB_MODE_ENT     *saLsbModePtr
)
{
    GT_U32      hwData; /* value to write into register   */
    GT_STATUS   rc ;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    CPSS_NULL_PTR_CHECK_MAC(saLsbModePtr);

    rc = prvCpssHwPpReadRegister(devNum,
           PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.hdrAltGlobalConfig,
           &hwData);

    if(rc != GT_OK)
        return rc;

     /* setting the Lsb mode */
    switch (hwData)
    {
        case 2:
            *saLsbModePtr = CPSS_SA_LSB_PER_PORT_E;
            break;
        case 0:
            *saLsbModePtr = CPSS_SA_LSB_PER_PKT_VID_E;
            break;
        case 1:
            *saLsbModePtr = CPSS_SA_LSB_PER_VLAN_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterMacSaLsbModeGet
*
* DESCRIPTION:
*       Gets the mode in which the device sets the packet's MAC SA least
*       significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*
* OUTPUTS:
*       saLsbModePtr    - (pointer to) The MAC SA least-significant bit mode
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterMacSaLsbModeGet
(
    IN  GT_U8                        devNum,
    OUT CPSS_MAC_SA_LSB_MODE_ENT     *saLsbModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaLsbModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, saLsbModePtr));

    rc = internal_cpssDxChIpRouterMacSaLsbModeGet(devNum, saLsbModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, saLsbModePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortRouterMacSaLsbModeSet
*
* DESCRIPTION:
*       Sets the mode, per port, in which the device sets the packet's MAC SA
*       least significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*       devNum          - the device number
*       portNum         - the port number
*       saLsbMode       - The MAC SA least-significant bit mode
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       The device 5 most significant bytes are set by cpssDxChIpRouterMacSaBaseSet().
*
*       The least significant bytes are set by:
*       Port mode is set by cpssDxChIpRouterPortMacSaLsbSet().
*       Vlan mode is set by cpssDxChIpRouterVlanMacSaLsbSet().
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortRouterMacSaLsbModeSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  CPSS_MAC_SA_LSB_MODE_ENT    saLsbMode
)
{
    GT_U32      hwData; /* value to write into register   */
    GT_U32      regAddr;
    GT_U32      offset;
    GT_STATUS   rc;
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum, portNum);

    /* setting the Lsb mode */
    switch (saLsbMode)
    {
        case CPSS_SA_LSB_PER_PORT_E:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
            {
                /* this mode is obsolete in the device ! */
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwData = 2;
            break;
        case CPSS_SA_LSB_PER_PKT_VID_E:
            hwData = 0;
            break;
        case CPSS_SA_LSB_PER_VLAN_E:
            hwData = 1;
            break;
        case CPSS_SA_LSB_FULL_48_BIT_GLOBAL:
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
            {
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
            }
            hwData = 3;
            break;
        default:

        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                                PRV_CPSS_DXCH_LION3_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                LION3_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTER_MAC_SA_ASSIGNMENT_MODE_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               hwData);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerHdrAltMacSaModifyMode[localPort / 16];
        offset = (localPort % 16) * 2;
        rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,offset,2,hwData);
        if(rc != GT_OK)
        {
            return rc;
        }

        /* Packets of Egress STC and Egress Mirroring are handled by global port in the Header Alteration.
           For multi-port-groups devices repeat configuration for global port */

        if(portNum == localPort)
        {
            /* Configuration of overlapped ports (identical global and local ports numbers)
               will lead to miss configuration for local ports in other port groups */
            return rc;
        }

        /* Port numbers range for the registers [0..63] */
        portNum &= 0x3f;
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerHdrAltMacSaModifyMode[portNum / 16];
        offset = (portNum % 16) * 2;

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            rc = prvCpssHwPpPortGroupSetRegField(devNum,
                                                    portGroupId,
                                                    regAddr,
                                                    offset,
                                                    2, hwData);
            if(rc != GT_OK)
            {
                return rc;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    }
    return rc;
}

/*******************************************************************************
* cpssDxChIpPortRouterMacSaLsbModeSet
*
* DESCRIPTION:
*       Sets the mode, per port, in which the device sets the packet's MAC SA
*       least significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*       devNum          - the device number
*       portNum         - the port number
*       saLsbMode       - The MAC SA least-significant bit mode
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       The device 5 most significant bytes are set by cpssDxChIpRouterMacSaBaseSet().
*
*       The least significant bytes are set by:
*       Port mode is set by cpssDxChIpRouterPortMacSaLsbSet().
*       Vlan mode is set by cpssDxChIpRouterVlanMacSaLsbSet().
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortRouterMacSaLsbModeSet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    IN  CPSS_MAC_SA_LSB_MODE_ENT    saLsbMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRouterMacSaLsbModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saLsbMode));

    rc = internal_cpssDxChIpPortRouterMacSaLsbModeSet(devNum, portNum, saLsbMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saLsbMode));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpPortRouterMacSaLsbModeGet
*
* DESCRIPTION:
*       Gets the mode, per port, in which the device sets the packet's MAC SA least
*       significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*       devNum          - the device number
*       portNum         - the port number
*
* OUTPUTS:
*       saLsbModePtr    - (pointer to) The MAC SA least-significant bit mode
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None;
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortRouterMacSaLsbModeGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT CPSS_MAC_SA_LSB_MODE_ENT    *saLsbModePtr
)
{
    GT_U32      hwData; /* value to write into register   */
    GT_U32      regAddr;
    GT_U32      offset;
    GT_STATUS   rc ;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_CHECK_MAC(devNum, portNum);

    CPSS_NULL_PTR_CHECK_MAC(saLsbModePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                                PRV_CPSS_DXCH_LION3_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                LION3_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTER_MAC_SA_ASSIGNMENT_MODE_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               &hwData);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.routerHdrAltMacSaModifyMode[localPort / 16];
        offset = (localPort % 16) * 2;
        rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,offset,2,&hwData);
    }

    if(rc != GT_OK)
        return rc;

     /* setting the Lsb mode */
    switch (hwData)
    {
        case 2:
            *saLsbModePtr = CPSS_SA_LSB_PER_PORT_E;
            break;
        case 0:
            *saLsbModePtr = CPSS_SA_LSB_PER_PKT_VID_E;
            break;
        case 1:
            *saLsbModePtr = CPSS_SA_LSB_PER_VLAN_E;
            break;
        case 3:
            *saLsbModePtr = CPSS_SA_LSB_FULL_48_BIT_GLOBAL;
            if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_FALSE)
                CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortRouterMacSaLsbModeGet
*
* DESCRIPTION:
*       Gets the mode, per port, in which the device sets the packet's MAC SA least
*       significant bytes.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*       devNum          - the device number
*       portNum         - the port number
*
* OUTPUTS:
*       saLsbModePtr    - (pointer to) The MAC SA least-significant bit mode
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/saLsbMode.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None;
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortRouterMacSaLsbModeGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT CPSS_MAC_SA_LSB_MODE_ENT    *saLsbModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortRouterMacSaLsbModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saLsbModePtr));

    rc = internal_cpssDxChIpPortRouterMacSaLsbModeGet(devNum, portNum, saLsbModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saLsbModePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpRouterPortVlanMacSaLsbSet
*
* DESCRIPTION:
*       Sets the 8 LSB Router MAC SA for this VLAN / EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     vlanPortId      - VLAN Id or Eggress Port Id
*     saMac           - The 8 bits SA mac value to be written to the SA bits of
*                       routed packet if SA alteration mode is configured to
*                       take LSB according to VLAN id / Eggress Port Id.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterPortVlanMacSaLsbSet
(
    IN GT_U8   devNum,
    IN GT_U16  vlanPortId,
    IN GT_U8   saMac
)
{
    GT_U32      hwData[1]; /* data to write to PP's table */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    PRV_CPSS_VLAN_VALUE_CHECK_MAC(vlanPortId);

    /*
        NOTE: this API is ch1,2 only -
            because : hold table that indexed by vlan and port to the same (28 lowest) indexes
            --> this is portVlan reason in the API name
    */

    hwData[0] = saMac;

    rc = prvCpssDxChWriteTableEntry(devNum,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    (GT_U32)vlanPortId, hwData);
    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterPortVlanMacSaLsbSet
*
* DESCRIPTION:
*       Sets the 8 LSB Router MAC SA for this VLAN / EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     vlanPortId      - VLAN Id or Eggress Port Id
*     saMac           - The 8 bits SA mac value to be written to the SA bits of
*                       routed packet if SA alteration mode is configured to
*                       take LSB according to VLAN id / Eggress Port Id.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterPortVlanMacSaLsbSet
(
    IN GT_U8   devNum,
    IN GT_U16  vlanPortId,
    IN GT_U8   saMac
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortVlanMacSaLsbSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlanPortId, saMac));

    rc = internal_cpssDxChIpRouterPortVlanMacSaLsbSet(devNum, vlanPortId, saMac);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlanPortId, saMac));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterPortVlanMacSaLsbGet
*
* DESCRIPTION:
*       Gets the 8 LSB Router MAC SA for this VLAN / EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     vlanPortId      - VLAN Id or Eggress Port Id
*
* OUTPUTS:
*     saMacPtr        - (pointer to) The 8 bits SA mac value written to the SA
*                       bits of routed packet if SA alteration mode is configured
*                       to take LSB according to VLAN id / Eggress Port Id.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_BAD_PTR               - one of the parameters is NULL pointer
*     GT_TIMEOUT       - after max number of retries checking if PP ready
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterPortVlanMacSaLsbGet
(
    IN  GT_U8   devNum,
    IN  GT_U16  vlanPortId,
    OUT GT_U8   *saMacPtr
)
{
    GT_U32      hwData[1]; /* data read from PP's table */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    PRV_CPSS_VLAN_VALUE_CHECK_MAC(vlanPortId);
    CPSS_NULL_PTR_CHECK_MAC(saMacPtr);

    /*
        NOTE: this API is ch1,2 only -
            because : hold table that indexed by vlan and port to the same (28 lowest) indexes
            --> this is portVlan reason in the API name
    */

    rc = prvCpssDxChReadTableEntry(devNum,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    (GT_U32)vlanPortId, hwData);

    if(rc != GT_OK)
        return rc;

    *saMacPtr = (GT_U8)hwData[0];

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterPortVlanMacSaLsbGet
*
* DESCRIPTION:
*       Gets the 8 LSB Router MAC SA for this VLAN / EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* NOT APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     vlanPortId      - VLAN Id or Eggress Port Id
*
* OUTPUTS:
*     saMacPtr        - (pointer to) The 8 bits SA mac value written to the SA
*                       bits of routed packet if SA alteration mode is configured
*                       to take LSB according to VLAN id / Eggress Port Id.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_BAD_PTR               - one of the parameters is NULL pointer
*     GT_TIMEOUT       - after max number of retries checking if PP ready
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterPortVlanMacSaLsbGet
(
    IN  GT_U8   devNum,
    IN  GT_U16  vlanPortId,
    OUT GT_U8   *saMacPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortVlanMacSaLsbGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlanPortId, saMacPtr));

    rc = internal_cpssDxChIpRouterPortVlanMacSaLsbGet(devNum, vlanPortId, saMacPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlanPortId, saMacPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterPortMacSaLsbSet
*
* DESCRIPTION:
*       Sets the 8 LSB Router MAC SA for this EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     portNum         - Eggress Port number
*     saMac           - The 8 bits SA mac value to be written to the SA bits of
*                       routed packet if SA alteration mode is configured to
*                       take LSB according to Eggress Port number.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterPortMacSaLsbSet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN GT_U8                    saMac
)
{
    GT_U32      hwData[1]; /* data to write to PP's table */
    GT_STATUS   rc;
    GT_U32      tableIndex;
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E |
         CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan  0..4K , port 4K..+28
            --> added 2 APIs per vlan per port
    */

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

    hwData[0] = saMac;

    /* port entries start after 4096 vlan entries */
    tableIndex = localPort + 4096;

    rc = prvCpssDxChPortGroupWriteTableEntry(devNum,portGroupId,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    tableIndex, hwData);
    if(rc != GT_OK)
    {
        return rc;
    }

    /* Packets of Egress STC and Egress Mirroring are handled by global port in the Header Alteration.
       For multi-port-groups devices repeat configuration for global port */

    if(portNum == localPort)
    {
        /* Configuration of overlapped ports (identical global and local ports numbers)
           will lead to miss configuration for local ports in other port groups */
        return rc;
    }

    /* Port numbers range for the table entry [0..63] */
    portNum &= 0x3f;
    tableIndex = portNum + 4096;

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
    {
        rc = prvCpssDxChPortGroupWriteTableEntry(devNum,
                                    portGroupId,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    tableIndex, hwData);
        if(rc != GT_OK)
        {
            return rc;
        }
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterPortMacSaLsbSet
*
* DESCRIPTION:
*       Sets the 8 LSB Router MAC SA for this EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     portNum         - Eggress Port number
*     saMac           - The 8 bits SA mac value to be written to the SA bits of
*                       routed packet if SA alteration mode is configured to
*                       take LSB according to Eggress Port number.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterPortMacSaLsbSet
(
    IN GT_U8                    devNum,
    IN GT_PHYSICAL_PORT_NUM     portNum,
    IN GT_U8                    saMac
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortMacSaLsbSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saMac));

    rc = internal_cpssDxChIpRouterPortMacSaLsbSet(devNum, portNum, saMac);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saMac));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterPortMacSaLsbGet
*
* DESCRIPTION:
*       Gets the 8 LSB Router MAC SA for this EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     portNum         - Eggress Port number
*
* OUTPUTS:
*     saMacPtr        - (pointer to) The 8 bits SA mac value written to the SA
*                       bits of routed packet if SA alteration mode is configured
*                       to take LSB according to Eggress Port number.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum
*     GT_BAD_PTR               - one of the parameters is NULL pointer
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterPortMacSaLsbGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_U8                   *saMacPtr
)
{
    GT_U32      hwData[1]; /* data read from PP's table */
    GT_STATUS   rc;
    GT_U32      tableIndex;
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E |
         CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);
    CPSS_NULL_PTR_CHECK_MAC(saMacPtr);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan  0..4K , port 4K..+28
            --> added 2 APIs per vlan per port
    */

    /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
    portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
    localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

    /* port entries start after 4096 vlan entries */
    tableIndex = localPort + 4096;

    rc = prvCpssDxChPortGroupReadTableEntry(devNum,portGroupId,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    tableIndex, hwData);

    if(rc != GT_OK)
        return rc;

    *saMacPtr = (GT_U8)hwData[0];

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterPortMacSaLsbGet
*
* DESCRIPTION:
*       Gets the 8 LSB Router MAC SA for this EGGRESS PORT.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*     devNum          - the device number
*     portNum         - Eggress Port number
*
* OUTPUTS:
*     saMacPtr        - (pointer to) The 8 bits SA mac value written to the SA
*                       bits of routed packet if SA alteration mode is configured
*                       to take LSB according to Eggress Port number.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum
*     GT_BAD_PTR               - one of the parameters is NULL pointer
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterPortMacSaLsbGet
(
    IN  GT_U8                   devNum,
    IN  GT_PHYSICAL_PORT_NUM    portNum,
    OUT GT_U8                   *saMacPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortMacSaLsbGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, saMacPtr));

    rc = internal_cpssDxChIpRouterPortMacSaLsbGet(devNum, portNum, saMacPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, saMacPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterVlanMacSaLsbSet
*
* DESCRIPTION:
*       Sets the 8 LSB Router MAC SA for this VLAN.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*     devNum          - the device number
*     vlan            - VLAN Id
*     saMac           - The 8 bits SA mac value to be written to the SA bits of
*                       routed packet if SA alteration mode is configured to
*                       take LSB according to VLAN.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterVlanMacSaLsbSet
(
    IN GT_U8   devNum,
    IN GT_U16  vlan,
    IN GT_U8   saMac
)
{
    GT_U32      hwData[1]; /* data to write to PP's table */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E);

    PRV_CPSS_VLAN_VALUE_CHECK_MAC(vlan);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan  0..4K , port 4K..+28
            --> added 2 APIs per vlan per port
    */

    hwData[0] = saMac;

    rc = prvCpssDxChWriteTableEntry(devNum,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    (GT_U32)vlan, hwData);
    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterVlanMacSaLsbSet
*
* DESCRIPTION:
*       Sets the 8 LSB Router MAC SA for this VLAN.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*     devNum          - the device number
*     vlan            - VLAN Id
*     saMac           - The 8 bits SA mac value to be written to the SA bits of
*                       routed packet if SA alteration mode is configured to
*                       take LSB according to VLAN.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterVlanMacSaLsbSet
(
    IN GT_U8   devNum,
    IN GT_U16  vlan,
    IN GT_U8   saMac
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterVlanMacSaLsbSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlan, saMac));

    rc = internal_cpssDxChIpRouterVlanMacSaLsbSet(devNum, vlan, saMac);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlan, saMac));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterVlanMacSaLsbGet
*
* DESCRIPTION:
*       Gets the 8 LSB Router MAC SA for this VLAN.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*     devNum          - the device number
*     vlan            - VLAN Id
*
* OUTPUTS:
*     saMacPtr        - (pointer to) The 8 bits SA mac value written to the SA
*                       bits of routed packet if SA alteration mode is configured
*                       to take LSB according to VLAN.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_BAD_PTR               - one of the parameters is NULL pointer
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterVlanMacSaLsbGet
(
    IN  GT_U8   devNum,
    IN  GT_U16  vlan,
    OUT GT_U8   *saMacPtr
)
{
    GT_U32      hwData[1]; /* data read from PP's table */
    GT_STATUS   rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E);

    PRV_CPSS_VLAN_VALUE_CHECK_MAC(vlan);
    CPSS_NULL_PTR_CHECK_MAC(saMacPtr);

    /*
        NOTE: this API is ch3 and above -
            because : the table added another 28 indexes : vlan  0..4K , port 4K..+28
            --> added 2 APIs per vlan per port
    */

    rc = prvCpssDxChReadTableEntry(devNum,
                                    PRV_CPSS_DXCH_TABLE_ROUTE_HA_MAC_SA_E,
                                    (GT_U32)vlan, hwData);

    if(rc != GT_OK)
        return rc;

    *saMacPtr = (GT_U8)hwData[0];

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterVlanMacSaLsbGet
*
* DESCRIPTION:
*       Gets the 8 LSB Router MAC SA for this VLAN.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2.
*
* INPUTS:
*     devNum          - the device number
*     vlan            - VLAN Id
*
* OUTPUTS:
*     saMacPtr        - (pointer to) The 8 bits SA mac value written to the SA
*                       bits of routed packet if SA alteration mode is configured
*                       to take LSB according to VLAN.
*
* RETURNS:
*     GT_OK                    - on success
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error
*     GT_BAD_PARAM             - wrong devNum or vlanId
*     GT_BAD_PTR               - one of the parameters is NULL pointer
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterVlanMacSaLsbGet
(
    IN  GT_U8   devNum,
    IN  GT_U16  vlan,
    OUT GT_U8   *saMacPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterVlanMacSaLsbGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlan, saMacPtr));

    rc = internal_cpssDxChIpRouterVlanMacSaLsbGet(devNum, vlan, saMacPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlan, saMacPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpRouterGlobalMacSaSet
*
* DESCRIPTION:
*       Sets full 48-bit Router MAC SA in Global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*     devNum            - the device number.
*     routerMacSaIndex  - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
*     macSaAddrPtr      - The 48 bits MAC SA.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success.
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error.
*     GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
*
* COMMENTS:
*      This API is applicable when per-egress-physical-port MAC SA assignment
*      mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*      cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*      by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterGlobalMacSaSet
(
    IN GT_U8        devNum,
    IN GT_U32       routerMacSaIndex,
    IN GT_ETHERADDR *macSaAddrPtr
)
{
    GT_U32      hwData[2] = {0}; /* data to write to PP's table */
    GT_STATUS   rc;        /* return code                 */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(routerMacSaIndex);

    CPSS_NULL_PTR_CHECK_MAC(macSaAddrPtr);

    /* convert the MAC address to hw format */
    hwData[0] =  macSaAddrPtr->arEther[5] |
                 (macSaAddrPtr->arEther[4] << 8) |
                 (macSaAddrPtr->arEther[3] << 16)|
                 (macSaAddrPtr->arEther[2] << 24);
    hwData[1] =  macSaAddrPtr->arEther[1] |
                 (macSaAddrPtr->arEther[0] << 8);


    rc = prvCpssDxChWriteTableEntry(devNum,
                                    PRV_CPSS_DXCH_LION3_TABLE_HA_GLOBAL_MAC_SA_E,
                                    routerMacSaIndex, hwData);
    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterGlobalMacSaSet
*
* DESCRIPTION:
*       Sets full 48-bit Router MAC SA in Global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*     devNum            - the device number.
*     routerMacSaIndex  - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
*     macSaAddrPtr      - The 48 bits MAC SA.
*
* OUTPUTS:
*     None.
*
* RETURNS:
*     GT_OK                    - on success.
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error.
*     GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
*
* COMMENTS:
*      This API is applicable when per-egress-physical-port MAC SA assignment
*      mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*      cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*      by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterGlobalMacSaSet
(
    IN GT_U8        devNum,
    IN GT_U32       routerMacSaIndex,
    IN GT_ETHERADDR *macSaAddrPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterGlobalMacSaSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerMacSaIndex, macSaAddrPtr));

    rc = internal_cpssDxChIpRouterGlobalMacSaSet(devNum, routerMacSaIndex, macSaAddrPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerMacSaIndex, macSaAddrPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpRouterGlobalMacSaGet
*
* DESCRIPTION:
*       Gets full 48-bit Router MAC SA from Global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*     devNum            - the device number.
*     routerMacSaIndex  - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
*
* OUTPUTS:
*     macSaAddrPtr      - The 48 bits MAC SA.
*
* RETURNS:
*     GT_OK                    - on success.
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error.
*     GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
*
* COMMENTS:
*      This API is applicable when per-egress-physical-port MAC SA assignment
*      mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*      cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*      by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterGlobalMacSaGet
(
    IN  GT_U8        devNum,
    IN  GT_U32       routerMacSaIndex,
    OUT GT_ETHERADDR *macSaAddrPtr
)
{
    GT_U32      hwData[2] = {0}; /* data to write to PP's table */
    GT_STATUS   rc;              /* return code                 */

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(macSaAddrPtr);

    PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(routerMacSaIndex);

    rc = prvCpssDxChReadTableEntry(devNum,
                                       PRV_CPSS_DXCH_LION3_TABLE_HA_GLOBAL_MAC_SA_E,
                                       routerMacSaIndex,hwData);
    if (rc != GT_OK)
    {
        return rc;
    }


    macSaAddrPtr->arEther[5] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],0,8);
    macSaAddrPtr->arEther[4] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],8,8);
    macSaAddrPtr->arEther[3] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],16,8);
    macSaAddrPtr->arEther[2] = (GT_U8)U32_GET_FIELD_MAC(hwData[0],24,8);
    macSaAddrPtr->arEther[1] = (GT_U8)U32_GET_FIELD_MAC(hwData[1],0,8);
    macSaAddrPtr->arEther[0] = (GT_U8)U32_GET_FIELD_MAC(hwData[1],8,8);

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterGlobalMacSaGet
*
* DESCRIPTION:
*       Gets full 48-bit Router MAC SA from Global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*     devNum            - the device number.
*     routerMacSaIndex  - The index into the global MAC SA table.(APPLICABLE RANGES: 0..255)
*
* OUTPUTS:
*     macSaAddrPtr      - The 48 bits MAC SA.
*
* RETURNS:
*     GT_OK                    - on success.
*     GT_FAIL                  - on error.
*     GT_HW_ERROR              - on hardware error.
*     GT_BAD_PARAM             - wrong devNum or routerMacSaIndex.
*     GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
*
* COMMENTS:
*      This API is applicable when per-egress-physical-port MAC SA assignment
*      mode is configured to global :CPSS_SA_LSB_FULL_48_BIT_GLOBAL by API
*      cpssDxChIpPortRouterMacSaLsbModeSet. The routerMacSaIndex is configured
*      by cpssDxChIpRouterPortGlobalMacSaIndexSet.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterGlobalMacSaGet
(
    IN  GT_U8        devNum,
    IN  GT_U32       routerMacSaIndex,
    OUT GT_ETHERADDR *macSaAddrPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterGlobalMacSaGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, routerMacSaIndex, macSaAddrPtr));

    rc = internal_cpssDxChIpRouterGlobalMacSaGet(devNum, routerMacSaIndex, macSaAddrPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, routerMacSaIndex, macSaAddrPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpRouterPortGlobalMacSaIndexSet
*
* DESCRIPTION:
*       Set router mac sa index refered to global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum           - device number.
*       portNum          - port number.
*       routerMacSaIndex - global MAC SA table index.(APPLICABLE RANGES: 0..255)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - wrong device or port.
*       GT_HW_ERROR              - on writing to HW error.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterPortGlobalMacSaIndexSet
(
    IN GT_U8                devNum,
    IN GT_PORT_NUM          portNum,
    IN GT_U32               routerMacSaIndex
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_GLOBAL_MAC_SA_INDEX_CHECK_MAC(routerMacSaIndex);


    return prvCpssDxChWriteTableEntryField(devNum,
                                   PRV_CPSS_DXCH_LION3_TABLE_HA_EGRESS_EPORT_1_E,
                                   portNum,
                                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                   LION3_HA_EPORT_TABLE_1_FIELDS_ROUTER_MAC_SA_INDEX_E, /* field name */
                                   PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                   routerMacSaIndex);
}

/*******************************************************************************
* cpssDxChIpRouterPortGlobalMacSaIndexSet
*
* DESCRIPTION:
*       Set router mac sa index refered to global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum           - device number.
*       portNum          - port number.
*       routerMacSaIndex - global MAC SA table index.(APPLICABLE RANGES: 0..255)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - wrong device or port.
*       GT_HW_ERROR              - on writing to HW error.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterPortGlobalMacSaIndexSet
(
    IN GT_U8                devNum,
    IN GT_PORT_NUM          portNum,
    IN GT_U32               routerMacSaIndex
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortGlobalMacSaIndexSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, routerMacSaIndex));

    rc = internal_cpssDxChIpRouterPortGlobalMacSaIndexSet(devNum, portNum, routerMacSaIndex);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, routerMacSaIndex));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterPortGlobalMacSaIndexGet
*
* DESCRIPTION:
*       Get router mac sa index refered to global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - device number.
*       portNum     - port number.
*
* OUTPUTS:
*       routerMacSaIndexPtr  - (pointer to) global MAC SA table index.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - wrong device or port.
*       GT_HW_ERROR              - on writing to HW error.
*       GT_BAD_PTR               - one of the parameters is NULL pointer.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterPortGlobalMacSaIndexGet
(
    IN  GT_U8           devNum,
    IN  GT_PORT_NUM     portNum,
    OUT GT_U32          *routerMacSaIndexPtr
)
{
    GT_U32      hwValue;    /* hardware value */
    GT_STATUS   rc;


    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
        CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
         CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(routerMacSaIndexPtr);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    rc = prvCpssDxChReadTableEntryField(devNum,
                                   PRV_CPSS_DXCH_LION3_TABLE_HA_EGRESS_EPORT_1_E,
                                   portNum,
                                   PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                   LION3_HA_EPORT_TABLE_1_FIELDS_ROUTER_MAC_SA_INDEX_E, /* field name */
                                   PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                   &hwValue);
    if (rc != GT_OK)
    {
        return rc;
    }

   *routerMacSaIndexPtr = hwValue;

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterPortGlobalMacSaIndexGet
*
* DESCRIPTION:
*       Get router mac sa index refered to global MAC SA table.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2.
*
* INPUTS:
*       devNum      - device number.
*       portNum     - port number.
*
* OUTPUTS:
*       routerMacSaIndexPtr  - (pointer to) global MAC SA table index.
*
* RETURNS:
*       GT_OK                    - on success.
*       GT_BAD_PARAM             - wrong device or port.
*       GT_HW_ERROR              - on writing to HW error.
*       GT_BAD_PTR               - one of the parameters is NULL pointer.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device.
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterPortGlobalMacSaIndexGet
(
    IN  GT_U8           devNum,
    IN  GT_PORT_NUM     portNum,
    OUT GT_U32          *routerMacSaIndexPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterPortGlobalMacSaIndexGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, routerMacSaIndexPtr));

    rc = internal_cpssDxChIpRouterPortGlobalMacSaIndexGet(devNum, portNum, routerMacSaIndexPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, routerMacSaIndexPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpRouterMacSaModifyEnable
*
* DESCRIPTION:
*      Per Egress port bit Enable Routed packets MAC SA Modification
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum   - the device number
*       portNum  - physical or CPU port number.
*       enable   - GT_FALSE: MAC SA Modification of routed packets is disabled
*                  GT_TRUE: MAC SA Modification of routed packets is enabled
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/portNum.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterMacSaModifyEnable
(
    IN  GT_U8                      devNum,
    IN  GT_PHYSICAL_PORT_NUM       portNum,
    IN  GT_BOOL                    enable
)
{
    GT_U32      bitNum;
    GT_U32      regAddr;
    GT_U32      value;
    GT_STATUS   rc ;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

    value = (enable == GT_TRUE) ? 1 : 0;

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                                PRV_CPSS_DXCH_LION3_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                LION3_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTED_MAC_SA_MOD_EN_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               value);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        bitNum = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
                     PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
                     localPort;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.
                        routerHdrAltEnMacSaModifyReg[OFFSET_TO_WORD_MAC(bitNum)];

        rc =  prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,
                    OFFSET_TO_BIT_MAC(bitNum),1,value);

         /* Packets of Egress STC and Egress Mirroring are handled by global port in the Header Alteration.
           For multi-port-groups devices repeat configuration for global port */

        if(portNum == localPort)
        {
            /* Configuration of overlapped ports (identical global and local ports numbers)
               will lead to miss configuration for local ports in other port groups */
            return rc;
        }

        /* Port numbers range for the registers [0..63] */
        portNum &= 0x3f;
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.
                        routerHdrAltEnMacSaModifyReg[OFFSET_TO_WORD_MAC(portNum)];

        PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum, portGroupId)
        {
            rc =  prvCpssHwPpPortGroupSetRegField(devNum,
                                                  portGroupId,
                                                  regAddr,
                                                  OFFSET_TO_BIT_MAC(portNum),
                                                  1,
                                                  value);

            if(rc != GT_OK)
            {
                return rc;
            }
        }
        PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterMacSaModifyEnable
*
* DESCRIPTION:
*      Per Egress port bit Enable Routed packets MAC SA Modification
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum   - the device number
*       portNum  - physical or CPU port number.
*       enable   - GT_FALSE: MAC SA Modification of routed packets is disabled
*                  GT_TRUE: MAC SA Modification of routed packets is enabled
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/portNum.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterMacSaModifyEnable
(
    IN  GT_U8                      devNum,
    IN  GT_PHYSICAL_PORT_NUM       portNum,
    IN  GT_BOOL                    enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaModifyEnable);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChIpRouterMacSaModifyEnable(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpRouterMacSaModifyEnableGet
*
* DESCRIPTION:
*      Per Egress port bit Get Routed packets MAC SA Modification State
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       portNum       - physical or CPU port number.
*
* OUTPUTS:
*       enablePtr     - GT_FALSE: MAC SA Modification of routed packets is disabled
*                  GT_TRUE: MAC SA Modification of routed packets is enabled
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/portNum.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpRouterMacSaModifyEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_U32  bitNum;
    GT_U32      regAddr;
    GT_U32      value;
    GT_STATUS   rc ;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32   localPort;/* local port - support multi-port-groups device */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);
    PRV_CPSS_DXCH_ENHANCED_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                                PRV_CPSS_DXCH_LION3_TABLE_HA_PHYSICAL_PORT_1_E,
                                                portNum,
                                                PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                                LION3_HA_PHYSICAL_PORT_TABLE_1_FIELDS_ROUTED_MAC_SA_MOD_EN_E, /* field name */
                                                PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                               &value);
    }
    else
    {
        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);
        localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        bitNum = (localPort == CPSS_CPU_PORT_NUM_CNS) ?
                     PRV_CPSS_DXCH_PP_HW_INFO_HA_CPU_PORT_BIT_INDEX_MAC(devNum) :
                     localPort;

        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->haRegs.
                        routerHdrAltEnMacSaModifyReg[OFFSET_TO_WORD_MAC(bitNum)];

        rc =  prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,
                    OFFSET_TO_BIT_MAC(bitNum),1,&value);
    }

    if(rc != GT_OK)
        return rc;

    *enablePtr = (value == 1) ? GT_TRUE : GT_FALSE;

    return rc;
}

/*******************************************************************************
* cpssDxChIpRouterMacSaModifyEnableGet
*
* DESCRIPTION:
*      Per Egress port bit Get Routed packets MAC SA Modification State
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number
*       portNum       - physical or CPU port number.
*
* OUTPUTS:
*       enablePtr     - GT_FALSE: MAC SA Modification of routed packets is disabled
*                  GT_TRUE: MAC SA Modification of routed packets is enabled
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum/portNum.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpRouterMacSaModifyEnableGet
(
    IN  GT_U8                       devNum,
    IN  GT_PHYSICAL_PORT_NUM        portNum,
    OUT GT_BOOL                     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpRouterMacSaModifyEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChIpRouterMacSaModifyEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpEcmpUcRpfCheckEnableSet
*
* DESCRIPTION:
*       Globally enables/disables ECMP/QoS unicast RPF check.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       enable    - enable / disable ECMP/Qos unicast RPF check
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpEcmpUcRpfCheckEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32      value, regAddr;
    GT_STATUS   rc ;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_XCAT2_E);


    value = (enable == GT_TRUE) ? 1 : 0;

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
    }
    else
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
    }
    rc =  prvCpssHwPpSetRegField(devNum, regAddr, 5, 1, value);

    return rc;
}

/*******************************************************************************
* cpssDxChIpEcmpUcRpfCheckEnableSet
*
* DESCRIPTION:
*       Globally enables/disables ECMP/QoS unicast RPF check.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       enable    - enable / disable ECMP/Qos unicast RPF check
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpEcmpUcRpfCheckEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpEcmpUcRpfCheckEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpEcmpUcRpfCheckEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpEcmpUcRpfCheckEnableGet
*
* DESCRIPTION:
*       Gets globally enables/disables ECMP/QoS unicast RPF check state.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       enablePtr - (points to) enable / disable ECMP/Qos unicast RPF check
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpEcmpUcRpfCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      value, regAddr;
    GT_STATUS   rc ;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_XCAT2_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;
    }
    else
    {
        regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerAdditionalCtrlReg;
    }
    rc =  prvCpssHwPpGetRegField(devNum, regAddr, 5, 1, &value);
    if(rc != GT_OK)
        return rc;

    *enablePtr = (value == 1) ? GT_TRUE : GT_FALSE;

    return rc;
}

/*******************************************************************************
* cpssDxChIpEcmpUcRpfCheckEnableGet
*
* DESCRIPTION:
*       Gets globally enables/disables ECMP/QoS unicast RPF check state.
*
* APPLICABLE DEVICES:
*        DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       enablePtr - (points to) enable / disable ECMP/Qos unicast RPF check
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*
*******************************************************************************/
GT_STATUS cpssDxChIpEcmpUcRpfCheckEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpEcmpUcRpfCheckEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpEcmpUcRpfCheckEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupCntSet
*
* DESCRIPTION:
*       set the requested IP counter set.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       cntSet       - counters set to clear.
*       countersPtr  - the counter values to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupCntSet
(
    IN GT_U8                         devNum,
    IN GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U8 setNum;

    CPSS_NULL_PTR_CHECK_MAC(countersPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    switch(cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    /* Router Management In Unicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, countersPtr->inUcPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Multicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngMcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, countersPtr->inMcPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /*Router Management In Unicast Non-Routed Non-Exception Packets
     Counter Set<n> */

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedNonException[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->inUcNonRoutedNonExcpPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /*Router Management In Unicast Non-Routed Exception Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->inUcNonRoutedExcpPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /*Router Management In Multicast Non-Routed Non-Exception Packets
                                           Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedNonExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->inMcNonRoutedNonExcpPkts);

    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);
    /*Router Management In Multicast Non-Routed Exception Packets Counter
                                              Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedExcptCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->inMcNonRoutedExcpPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Unicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum,portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->inUcTrappedMirrorPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Multicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->inMcTrappedMirrorPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management In Multicast RPF Fail Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcRPFFailCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcRPFFailCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32,
                                   countersPtr->mcRfpFailPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    /* Router Management Out Unicast Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementOutUcPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngOutUcPktCntSet[setNum];
    }

    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32,
                                   countersPtr->outUcRoutedPkts);
    if(GT_OK != rc)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_FAIL, LOG_ERROR_NO_MSG);

    return GT_OK;

}

/*******************************************************************************
* cpssDxChIpPortGroupCntSet
*
* DESCRIPTION:
*       set the requested IP counter set.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       cntSet       - counters set to clear.
*       countersPtr  - the counter values to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupCntSet
(
    IN GT_U8                         devNum,
    IN GT_PORT_GROUPS_BMP            portGroupsBmp,
    IN CPSS_IP_CNT_SET_ENT           cntSet,
    IN CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, cntSet, countersPtr));

    rc = internal_cpssDxChIpPortGroupCntSet(devNum, portGroupsBmp, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupCntGet
*
* DESCRIPTION:
*       Return the IP counter set requested.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       cntSet - counters set to retrieve.
*
* OUTPUTS:
*       countersPtr - (pointer to)struct contains the counter values.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PTR               - on NULL pointer
*       GT_FAIL                  - on error
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       This function doesn't handle counters overflow.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupCntGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_GROUPS_BMP           portGroupsBmp,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */
    GT_U8 setNum;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);


    CPSS_NULL_PTR_CHECK_MAC(countersPtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    switch(cntSet)
    {
        case CPSS_IP_CNT_SET0_E:
            setNum =0;
            break;
        case CPSS_IP_CNT_SET1_E:
            setNum =1;
            break;
        case CPSS_IP_CNT_SET2_E:
            setNum =2;
            break;
        case CPSS_IP_CNT_SET3_E:
            setNum =3;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }
    /* Router Management In Unicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                            0,32,&(countersPtr->inUcPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /* Router Management In Multicast Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngMcPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                            0,32,&(countersPtr->inMcPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /*Router Management In Unicast Non-Routed Non-Exception Packets
     Counter Set<n> */

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedNonException[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inUcNonRoutedNonExcpPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /*Router Management In Unicast Non-Routed Exception Packets Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcNonRoutedExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inUcNonRoutedExcpPkts),NULL);

    if(GT_OK != rc)
        return rc;

    /*Router Management In Multicast Non-Routed Non-Exception Packets
                                           Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedNonExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedNonExcptPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inMcNonRoutedNonExcpPkts),NULL);

    if(GT_OK != rc)
        return rc;
   /*Router Management In Multicast Non-Routed Exception Packets Counter
                                          Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcNonRoutedExceptionPktsCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcNonRoutedExcptCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inMcNonRoutedExcpPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management In Unicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInUcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInUcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inUcTrappedMirrorPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management In Multicast Trapped / Mirrored Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcTrappedMirroredPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcTrapMrrPktCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->inMcTrappedMirrorPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management In Multicast RPF Fail Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementInMcRPFFailCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngInMcRPFFailCntSet[setNum];
    }
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->mcRfpFailPkts),NULL);
    if(GT_OK != rc)
        return rc;

    /* Router Management Out Unicast Packet Counter Set<n> */
    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerManagementCntrsSets.routerManagementOutUcPktCntrSet[setNum];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerMngOutUcPktCntSet[setNum];
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr, 0,32,
                                   &(countersPtr->outUcRoutedPkts),NULL);
    if(GT_OK != rc)
        return rc;

    return GT_OK;

}

/*******************************************************************************
* cpssDxChIpPortGroupCntGet
*
* DESCRIPTION:
*       Return the IP counter set requested.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       cntSet - counters set to retrieve.
*
* OUTPUTS:
*       countersPtr - (pointer to)struct contains the counter values.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PTR               - on NULL pointer
*       GT_FAIL                  - on error
*       GT_NOT_INITIALIZED       - The library was not initialized.
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       This function doesn't handle counters overflow.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupCntGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_GROUPS_BMP           portGroupsBmp,
    IN  CPSS_IP_CNT_SET_ENT          cntSet,
    OUT CPSS_DXCH_IP_COUNTER_SET_STC *countersPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, cntSet, countersPtr));

    rc = internal_cpssDxChIpPortGroupCntGet(devNum, portGroupsBmp, cntSet, countersPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, cntSet, countersPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupDropCntSet
*
* DESCRIPTION:
*      set the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       dropPkts - the counter value to set
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupDropCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               dropPkts
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCnt;
    }

    /* set the counter */
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, dropPkts);

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortGroupDropCntSet
*
* DESCRIPTION:
*      set the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       dropPkts - the counter value to set
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupDropCntSet
(
    IN GT_U8                devNum,
    IN GT_PORT_GROUPS_BMP   portGroupsBmp,
    IN GT_U32               dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupDropCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPkts));

    rc = internal_cpssDxChIpPortGroupDropCntSet(devNum, portGroupsBmp, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupDropCntGet
*
* DESCRIPTION:
*      Get the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets according to the
*                     drop counter mode.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *dropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    CPSS_NULL_PTR_CHECK_MAC(dropPktsPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if (PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerDropCntr.routerDropCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerDropCnt;
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                 0, 32, dropPktsPtr, NULL);


    return rc;
}

/*******************************************************************************
* cpssDxChIpPortGroupDropCntGet
*
* DESCRIPTION:
*      Get the drop counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets according to the
*                     drop counter mode.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupDropCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    OUT GT_U32                  *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupDropCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPktsPtr));

    rc = internal_cpssDxChIpPortGroupDropCntGet(devNum, portGroupsBmp, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet
*
* DESCRIPTION:
*      Get the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_PORT_GROUPS_BMP     portGroupsBmp,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    CPSS_NULL_PTR_CHECK_MAC(dropPktsPtr);
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.
            MLLMCFIFODropCntr;
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMcFifoFullDropCnt;
    }

    /* summary the counter from all port groups */
    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, dropPktsPtr, NULL);

    return rc;

}

/*******************************************************************************
* cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet
*
* DESCRIPTION:
*      Get the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       dropPktsPtr - the number of counted dropped packets.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet
(
    IN   GT_U8                  devNum,
    IN   GT_PORT_GROUPS_BMP     portGroupsBmp,
    OUT  GT_U32                 *dropPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPktsPtr));

    rc = internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntGet(devNum, portGroupsBmp, dropPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet
*
* DESCRIPTION:
*      set the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       dropPkts    - the counter value to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet
(
    IN GT_U8                 devNum,
    IN GT_PORT_GROUPS_BMP    portGroupsBmp,
    IN GT_U32                dropPkts
)
{
    GT_U32    regAddr;              /* register address                   */
    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E |
        CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */

        /* this is 'unreachable code' ! (see PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC) */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllMcFifoFullDropCnt;

    /* set the counter */
    rc =  prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                             0, 32, dropPkts);
    return rc;

}

/*******************************************************************************
* cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet
*
* DESCRIPTION:
*      set the multi target queue full drop packet counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum         - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       dropPkts    - the counter value to set.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet
(
    IN GT_U8                 devNum,
    IN GT_PORT_GROUPS_BMP    portGroupsBmp,
    IN GT_U32                dropPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, dropPkts));

    rc = internal_cpssDxChIpPortGroupMultiTargetQueueFullDropCntSet(devNum, portGroupsBmp, dropPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, dropPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupMllCntGet
*
* DESCRIPTION:
*      Get the mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number.
*       portGroupsBmp   - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       mllCntSet  - the mll counter set out of the 2
*
* OUTPUTS:
*       mllOutMCPktsPtr - According to the configuration of this cnt set, The
*                      number of routed IP Multicast packets Duplicated by the
*                      MLL Engine and transmitted via this interface
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupMllCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    IN  GT_U32                  mllCntSet,
    OUT GT_U32                  *mllOutMCPktsPtr
)
{
    GT_STATUS rc;                   /* return code                        */
    GT_U32    regAddr;              /* register address                   */

    CPSS_NULL_PTR_CHECK_MAC(mllOutMCPktsPtr);

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);

    if(mllCntSet > 1)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */
        regAddr = PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).MLLOutInterfaceCntrs.IPMLLOutMcPktsCntr[mllCntSet];
    }
    else
    {
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllOutMcPktCnt[mllCntSet];
    }

    rc = prvCpssPortGroupsBmpCounterSummary(devNum, portGroupsBmp, regAddr,
                                                0, 32, mllOutMCPktsPtr, NULL);
    return rc;

}

/*******************************************************************************
* cpssDxChIpPortGroupMllCntGet
*
* DESCRIPTION:
*      Get the mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2.
*
* INPUTS:
*       devNum          - the device number.
*       portGroupsBmp   - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       mllCntSet  - the mll counter set out of the 2
*
* OUTPUTS:
*       mllOutMCPktsPtr - According to the configuration of this cnt set, The
*                      number of routed IP Multicast packets Duplicated by the
*                      MLL Engine and transmitted via this interface
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupMllCntGet
(
    IN  GT_U8                   devNum,
    IN  GT_PORT_GROUPS_BMP      portGroupsBmp,
    IN  GT_U32                  mllCntSet,
    OUT GT_U32                  *mllOutMCPktsPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMllCntGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, mllCntSet, mllOutMCPktsPtr));

    rc = internal_cpssDxChIpPortGroupMllCntGet(devNum, portGroupsBmp, mllCntSet, mllOutMCPktsPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, mllCntSet, mllOutMCPktsPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupMllCntSet
*
* DESCRIPTION:
*      set an mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*       portGroupsBmp   - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       mllCntSet       - the mll counter set out of the 2
*       mllOutMCPkts    - the counter value to set
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupMllCntSet
(
    IN GT_U8                    devNum,
    IN GT_PORT_GROUPS_BMP       portGroupsBmp,
    IN GT_U32                   mllCntSet,
    IN GT_U32                   mllOutMCPkts
)
{

    GT_U32    regAddr;              /* register address                   */

    GT_STATUS rc;                   /* return code                        */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum, portGroupsBmp);
    if(mllCntSet > 1)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        /* NOTE: this is ROC counter -- 'read only , clear' so no ability to 'set' it */

        /* this is 'unreachable code' ! (see PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC) */
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_APPLICABLE_DEVICE, LOG_ERROR_NO_MSG);
    }

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.mllOutMcPktCnt[mllCntSet];
    /* set the counter */
    rc = prvCpssPortGroupsBmpCounterSet(devNum, portGroupsBmp, regAddr,
                                            0, 32, mllOutMCPkts);

    return rc;

}

/*******************************************************************************
* cpssDxChIpPortGroupMllCntSet
*
* DESCRIPTION:
*      set an mll counter.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum          - the device number
*       portGroupsBmp   - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       mllCntSet       - the mll counter set out of the 2
*       mllOutMCPkts    - the counter value to set
*
* OUTPUTS:
*      None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - Illegal parameter in function called
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupMllCntSet
(
    IN GT_U8                    devNum,
    IN GT_PORT_GROUPS_BMP       portGroupsBmp,
    IN GT_U32                   mllCntSet,
    IN GT_U32                   mllOutMCPkts
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMllCntSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, mllCntSet, mllOutMCPkts));

    rc = internal_cpssDxChIpPortGroupMllCntSet(devNum, portGroupsBmp, mllCntSet, mllOutMCPkts);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, mllCntSet, mllOutMCPkts));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpUcRpfModeSet
*
* DESCRIPTION:
*       Defines the uRPF check mode for a given VID.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       vid       - Vlan Id
*       uRpfMode  - CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                        for this VID.
*                   CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                        globally enabled, then uRPF check is done
*                                        by comparing the packet VID to the VID
*                                        in the additional route entry, otherwise
*                                        it is done using the SIP-Next Hop Entry VID.
*                   CPSS_DXCH_IP_URPF_PORT_MODE_E = uRPF check is done by
*                        comparing the packet source {device,port}/Trunk to
*                              the SIP-Next Hop Entry {device,port}/Trunk.
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device, vid or uRpfMode
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpUcRpfModeSet
(
    IN  GT_U8                           devNum,
    IN  GT_U16                          vid,
    IN  CPSS_DXCH_IP_URPF_MODE_ENT      uRpfMode
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      entryIndex;
    GT_U32      fieldOffset;
    GT_U32      fieldWordNum;
    GT_U32      fieldLength;
    GT_U32      fieldValue;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E);

    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vid);

    switch(uRpfMode)
    {
    case CPSS_DXCH_IP_URPF_DISABLE_MODE_E:
        fieldValue = 0;
        break;
    case CPSS_DXCH_IP_URPF_VLAN_MODE_E:
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                                   PRV_CPSS_DXCH_LION_URPF_PER_VLAN_NOT_SUPPORTED_WA_E))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_NOT_SUPPORTED, LOG_ERROR_NO_MSG);
        }
        fieldValue = 1;
        break;
    case CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E:
        fieldValue = 2;
        break;
    case CPSS_DXCH_IP_URPF_LOOSE_MODE_E:
        fieldValue = 3;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }


    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             PRV_CPSS_DXCH_LION3_TABLE_IPVX_EVLAN_E,
                                             vid,
                                             0, /* word */
                                             0, /* offset */
                                             2, /* length */
                                             fieldValue);
    }
    else
    {
        PRV_CPSS_VLAN_VALUE_CHECK_MAC(vid);

        entryIndex      =   (GT_U32)(vid / 16);    /* 0 - 255 number of lines   */
        fieldOffset     =   (GT_U32)((vid % 16)*2);/* 16 vlans in each lines    */
        fieldWordNum    =   0;                     /* one word in each line     */
        fieldLength     =   2;                     /* 2 bits to hold uRpf VLAN mode */

        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             PRV_CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E,
                                             entryIndex,
                                             fieldWordNum,
                                             fieldOffset,
                                             fieldLength,
                                             fieldValue);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpUcRpfModeSet
*
* DESCRIPTION:
*       Defines the uRPF check mode for a given VID.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       vid       - Vlan Id
*       uRpfMode  - CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                        for this VID.
*                   CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                        globally enabled, then uRPF check is done
*                                        by comparing the packet VID to the VID
*                                        in the additional route entry, otherwise
*                                        it is done using the SIP-Next Hop Entry VID.
*                   CPSS_DXCH_IP_URPF_PORT_MODE_E = uRPF check is done by
*                        comparing the packet source {device,port}/Trunk to
*                              the SIP-Next Hop Entry {device,port}/Trunk.
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device, vid or uRpfMode
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*******************************************************************************/
GT_STATUS cpssDxChIpUcRpfModeSet
(
    IN  GT_U8                           devNum,
    IN  GT_U16                          vid,
    IN  CPSS_DXCH_IP_URPF_MODE_ENT      uRpfMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRpfModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vid, uRpfMode));

    rc = internal_cpssDxChIpUcRpfModeSet(devNum, vid, uRpfMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vid, uRpfMode));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpUcRpfModeGet
*
* DESCRIPTION:
*       Read uRPF check mode for a given VID.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       vid       - Vlan Id
*
* OUTPUTS:
*       uRpfModePtr  -  CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                           for this VID.
*                       CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                        globally enabled, then uRPF check is done
*                                        by comparing the packet VID to the VID
*                                        in the additional route entry, otherwise
*                                        it is done using the SIP-Next Hop Entry VID.
*                       CPSS_DXCH_IP_URPF_PORT_MODE_E = uRPF check is done by
*                           comparing the packet source {device,port}/Trunk to
*                           the SIP-Next Hop Entry {device,port}/Trunk.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpUcRpfModeGet
(
    IN  GT_U8                               devNum,
    IN  GT_U16                              vid,
    OUT CPSS_DXCH_IP_URPF_MODE_ENT          *uRpfModePtr
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      entryIndex;
    GT_U32      fieldOffset;
    GT_U32      fieldWordNum;
    GT_U32      fieldLength;
    GT_U32      fieldValue;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E);

    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vid);
    CPSS_NULL_PTR_CHECK_MAC(uRpfModePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            PRV_CPSS_DXCH_LION3_TABLE_IPVX_EVLAN_E,
                                            vid,
                                            0, /* word */
                                            0, /* offset */
                                            2, /* length */
                                            &fieldValue);
        if(rc != GT_OK)
            return rc;
    }
    else
    {
        PRV_CPSS_VLAN_VALUE_CHECK_MAC(vid);

        entryIndex      =   (GT_U32)(vid / 16);    /* 0 - 255 number of lines   */
        fieldOffset     =   (GT_U32)((vid % 16)*2);/* 16 vlans in each lines    */
        fieldWordNum    =   0;                     /* one word in each line     */
        fieldLength     =   2;                     /* 2 bits to hold uRpf VLAN mode */

        rc = prvCpssDxChReadTableEntryField(devNum,
                                            PRV_CPSS_DXCH_LION_TABLE_ROUTER_VLAN_URPF_STC_E,
                                            entryIndex,
                                            fieldWordNum,
                                            fieldOffset,
                                            fieldLength,
                                            &fieldValue);
        if(rc != GT_OK)
            return rc;
    }

    switch(fieldValue)
    {
    case 0:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_DISABLE_MODE_E;
        break;
    case 1:
        if(GT_TRUE == PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                                   PRV_CPSS_DXCH_LION_URPF_PER_VLAN_NOT_SUPPORTED_WA_E))
        {
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
        }
        *uRpfModePtr = CPSS_DXCH_IP_URPF_VLAN_MODE_E;
        break;
    case 2:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_PORT_TRUNK_MODE_E;
        break;
    case 3:
        *uRpfModePtr = CPSS_DXCH_IP_URPF_LOOSE_MODE_E;
        break;

    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpUcRpfModeGet
*
* DESCRIPTION:
*       Read uRPF check mode for a given VID.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       vid       - Vlan Id
*
* OUTPUTS:
*       uRpfModePtr  -  CPSS_DXCH_IP_URPF_DISABLE_MODE_E = uRPF check is disabled
*                           for this VID.
*                       CPSS_DXCH_IP_URPF_VLAN_MODE_E= Vlan: If ECMP uRPF is
*                                        globally enabled, then uRPF check is done
*                                        by comparing the packet VID to the VID
*                                        in the additional route entry, otherwise
*                                        it is done using the SIP-Next Hop Entry VID.
*                       CPSS_DXCH_IP_URPF_PORT_MODE_E = uRPF check is done by
*                           comparing the packet source {device,port}/Trunk to
*                           the SIP-Next Hop Entry {device,port}/Trunk.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       If ucRPFCheckEnable field configured in cpssDxChIpLttWrite is enabled
*       then VLAN-based uRPF check is performed, regardless of this configuration.
*       Otherwise, uRPF check is performed for this VID according to this
*       configuration.
*       Port-based uRPF mode is not supported if the address is associated
*       with an ECMP/QoS block of nexthop entries.
*
*******************************************************************************/
GT_STATUS cpssDxChIpUcRpfModeGet
(
    IN  GT_U8                               devNum,
    IN  GT_U16                              vid,
    OUT CPSS_DXCH_IP_URPF_MODE_ENT          *uRpfModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRpfModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vid, uRpfModePtr));

    rc = internal_cpssDxChIpUcRpfModeGet(devNum, vid, uRpfModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vid, uRpfModePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortSipSaEnableSet
*
* DESCRIPTION:
*       Enable SIP/SA check for packets received from the given port.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       portNum   - the port number (including CPU port)
*       enable    - GT_FALSE: disable SIP/SA check on the port
*                   GT_TRUE:  enable SIP/SA check on the port
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device or port
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortSipSaEnableSet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    IN  GT_BOOL                      enable
)
{
    GT_U32      regAddr;
    GT_STATUS   rc = GT_OK; /* return code */
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;  /* local port - support multi-port-groups device */
    GT_U32      data;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);

    data = BOOL2BIT_MAC(enable);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             PRV_CPSS_DXCH_LION3_TABLE_IPVX_INGRESS_EPORT_E,
                                             portNum,
                                             PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                             LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_ROUTER_PER_EPORT_SIP_SA_CHECK_ENABLE_E,
                                             PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                             data);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        /* Get address of register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerPerPortSipSaEnable0;

        rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,localPort,1,data);
    }

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortSipSaEnableSet
*
* DESCRIPTION:
*       Enable SIP/SA check for packets received from the given port.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       portNum   - the port number (including CPU port)
*       enable    - GT_FALSE: disable SIP/SA check on the port
*                   GT_TRUE:  enable SIP/SA check on the port
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device or port
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortSipSaEnableSet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    IN  GT_BOOL                      enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortSipSaEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enable));

    rc = internal_cpssDxChIpPortSipSaEnableSet(devNum, portNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortSipSaEnableGet
*
* DESCRIPTION:
*       Return the SIP/SA check status for packets received from the given port.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       portNum   - the port number (including CPU port)
*
* OUTPUTS:
*       enablePtr - GT_FALSE: SIP/SA check on the port is disabled
*                   GT_TRUE:  SIP/SA check on the port is enabled
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device or port
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortSipSaEnableGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    OUT GT_BOOL                      *enablePtr
)
{
    GT_U32      regAddr;
    GT_STATUS   rc = GT_OK; /* return code */
    GT_U32      portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32       localPort;  /* local port - support multi-port-groups device */
    GT_U32      data;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E);
    PRV_CPSS_DXCH_PORT_CHECK_MAC(devNum,portNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    if(PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_ENABLED_MAC(devNum) == GT_TRUE)
    {
        rc = prvCpssDxChReadTableEntryField(devNum,
                                            PRV_CPSS_DXCH_LION3_TABLE_IPVX_INGRESS_EPORT_E,
                                            portNum,
                                            PRV_CPSS_DXCH_TABLE_WORD_INDICATE_FIELD_NAME_CNS,
                                            LION3_IPVX_ROUTER_EPORT_TABLE_FIELDS_ROUTER_PER_EPORT_SIP_SA_CHECK_ENABLE_E,
                                            PRV_CPSS_DXCH_TABLES_WORD_INDICATE_AUTO_CALC_LENGTH_CNS,
                                            &data);
    }
    else
    {
        PRV_CPSS_DXCH_PHY_PORT_OR_CPU_PORT_CHECK_MAC(devNum, portNum);

        /* convert the 'Physical port' to portGroupId,local port -- supporting multi-port-groups device */
        portGroupId = PRV_CPSS_GLOBAL_PORT_TO_PORT_GROUP_ID_CONVERT_MAC(devNum, portNum);

        if(portNum == CPSS_CPU_PORT_NUM_CNS)
            localPort = 31;
        else
            localPort = PRV_CPSS_GLOBAL_PORT_TO_LOCAL_PORT_CONVERT_MAC(devNum,portNum);

        /* Get address of register */
        regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.routerPerPortSipSaEnable0;

        rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,localPort,1,&data);
        if(rc != GT_OK)
            return rc;
    }

    *enablePtr = BIT2BOOL_MAC(data);

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortSipSaEnableGet
*
* DESCRIPTION:
*       Return the SIP/SA check status for packets received from the given port.
*
* APPLICABLE DEVICES:
*        Lion; Lion2; Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2.
*
* INPUTS:
*       devNum    - the device number
*       portNum   - the port number (including CPU port)
*
* OUTPUTS:
*       enablePtr - GT_FALSE: SIP/SA check on the port is disabled
*                   GT_TRUE:  SIP/SA check on the port is enabled
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - on wrong device or port
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*
* COMMENTS:
*       SIP/SA check is triggered only if either this flag or
*       the sipSaCheckMismatchEnable field configured in cpssDxChIpLttWrite
*       are enabled.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortSipSaEnableGet
(
    IN  GT_U8                        devNum,
    IN  GT_PORT_NUM                  portNum,
    OUT GT_BOOL                      *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortSipSaEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portNum, enablePtr));

    rc = internal_cpssDxChIpPortSipSaEnableGet(devNum, portNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupMultiTargetRateShaperSet
*
* DESCRIPTION:
*      set the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                     target Rate shaper
*       windowSize - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetRateShaperSet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    IN  GT_BOOL            multiTargetRateShaperEnable,
    IN  GT_U32             windowSize
)
{
    GT_U32    regAddr;         /* register address  */
    GT_U32    data;            /* value to write    */
    GT_U32    portGroupId;/*the port group Id - support multi-port-groups device */
    GT_STATUS rc;              /* return code       */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E |
        CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum,portGroupsBmp);

    if ((multiTargetRateShaperEnable == GT_TRUE) &&
        (GT_FALSE == CHECK_BITS_DATA_RANGE_MAC(windowSize,16)))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    /* Get address of Multi Target Rate Shaping Register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.multiTargetRateShapingReg;

    data = (GT_TRUE == multiTargetRateShaperEnable)? 1:0;

    /* loop on all active port groups in the bmp */
    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)
    {
        rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,
                                                    24,1,data);
        if (GT_OK != rc)
        {
            return rc;
        }

        /*if enabled then this is the shaper window size*/
        if (GT_TRUE == multiTargetRateShaperEnable)
        {
            rc = prvCpssHwPpPortGroupSetRegField(devNum,portGroupId,regAddr,
                                                        0,16,windowSize);
        }

        if (GT_OK != rc)
        {
            return rc;
        }

    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_IN_BMP_MAC(devNum,portGroupsBmp,portGroupId)

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpPortGroupMultiTargetRateShaperSet
*
* DESCRIPTION:
*      set the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*       multiTargetRateShaperEnable - weather to enable (disable) the Multi
*                                     target Rate shaper
*       windowSize - if enabled then this is the shaper window size (APPLICABLE RANGES: 0..0xFFFF)
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupMultiTargetRateShaperSet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    IN  GT_BOOL            multiTargetRateShaperEnable,
    IN  GT_U32             windowSize
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetRateShaperSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, multiTargetRateShaperEnable, windowSize));

    rc = internal_cpssDxChIpPortGroupMultiTargetRateShaperSet(devNum, portGroupsBmp, multiTargetRateShaperEnable, windowSize);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, multiTargetRateShaperEnable, windowSize));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPortGroupMultiTargetRateShaperGet
*
* DESCRIPTION:
*      get the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*      DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*      DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                        target Rate shaper
*       windowSizePtr - if enabled then this is the shaper window size
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPortGroupMultiTargetRateShaperGet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    OUT GT_BOOL            *multiTargetRateShaperEnablePtr,
    OUT GT_U32             *windowSizePtr
)
{
    GT_U32    regAddr;         /* register address  */
    GT_U32    hwData;          /* hw value */
    GT_U32    portGroupId;/*the port group Id - support multi-port-groups device */
    GT_STATUS rc = GT_OK;      /* return code       */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_XCAT2_E |
        CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);
    CPSS_NULL_PTR_CHECK_MAC(multiTargetRateShaperEnablePtr);
    CPSS_NULL_PTR_CHECK_MAC(windowSizePtr);

    PRV_CPSS_MULTI_PORT_GROUPS_BMP_CHECK_MAC(devNum,portGroupsBmp);

    /* Get the first active port group id */
    PRV_CPSS_MULTI_PORT_GROUPS_BMP_GET_FIRST_ACTIVE_MAC(devNum, portGroupsBmp,
                                                        portGroupId);

    /* Get address of Multi Target Rate Shaping Register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipMtRegs.multiTargetRateShapingReg;


    /* get multiTargetRateShaperEnable */
    rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,
                                                24,1,&hwData);
    if (GT_OK != rc)
        return rc;

    *multiTargetRateShaperEnablePtr = (0 == hwData) ? GT_FALSE : GT_TRUE;


    /* get windowSize */
    rc = prvCpssHwPpPortGroupGetRegField(devNum,portGroupId,regAddr,
                                                0,16,windowSizePtr);

    return rc;
}

/*******************************************************************************
* cpssDxChIpPortGroupMultiTargetRateShaperGet
*
* DESCRIPTION:
*      get the Multi target Rate shaper params.
*
* APPLICABLE DEVICES:
*      DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* NOT APPLICABLE DEVICES:
*      DxCh1; DxCh1_Diamond; xCat2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum     - the device number
*       portGroupsBmp  - bitmap of Port Groups.
*              NOTEs:
*               1. for non multi-port groups device this parameter is IGNORED.
*               2. for multi-port groups device :
*                  bitmap must be set with at least one bit representing
*                  valid port group(s). If a bit of non valid port group
*                  is set then function returns GT_BAD_PARAM.
*                  value CPSS_PORT_GROUP_UNAWARE_MODE_CNS is supported.
*
* OUTPUTS:
*       multiTargetRateShaperEnablePtr - weather to enable (disable) the Multi
*                                        target Rate shaper
*       windowSizePtr - if enabled then this is the shaper window size
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       for multi port-group device, the multi-target rate shaping
*       shapes a traffic on per-port-group basis according to the
*       source port of the packet.
*
*******************************************************************************/
GT_STATUS cpssDxChIpPortGroupMultiTargetRateShaperGet
(
    IN  GT_U8              devNum,
    IN  GT_PORT_GROUPS_BMP portGroupsBmp,
    OUT GT_BOOL            *multiTargetRateShaperEnablePtr,
    OUT GT_U32             *windowSizePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPortGroupMultiTargetRateShaperGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, portGroupsBmp, multiTargetRateShaperEnablePtr, windowSizePtr));

    rc = internal_cpssDxChIpPortGroupMultiTargetRateShaperGet(devNum, portGroupsBmp, multiTargetRateShaperEnablePtr, windowSizePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, portGroupsBmp, multiTargetRateShaperEnablePtr, windowSizePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpTcamEccDaemonEnableSet
*
* DESCRIPTION:
*       Enables or disables Router TCAM ECC Daemon.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum        - device number
*       enable        - GT_TRUE  - Router TCAM ECC Daemon enable
*                       GT_FALSE - Router TCAM ECC Daemon disable
* OUTPUTS:
*      None
*
* RETURNS :
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong parameter
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpTcamEccDaemonEnableSet
(
    IN  GT_U8   devNum,
    IN  GT_BOOL enable
)
{
    GT_U32    regAddr;     /* register address */
    GT_STATUS rc;          /* retruned status */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E |
                                          CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);


    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamControl;
    if (enable == GT_TRUE)
    {
        rc = prvCpssHwPpWriteRegister(devNum,regAddr,0x1F088887);
    }
    else
    {
        rc = prvCpssHwPpSetRegField(devNum, regAddr, 28, 1, 0);
    }
    return rc;
}

/*******************************************************************************
* cpssDxChIpTcamEccDaemonEnableSet
*
* DESCRIPTION:
*       Enables or disables Router TCAM ECC Daemon.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum        - device number
*       enable        - GT_TRUE  - Router TCAM ECC Daemon enable
*                       GT_FALSE - Router TCAM ECC Daemon disable
* OUTPUTS:
*      None
*
* RETURNS :
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong parameter
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpTcamEccDaemonEnableSet
(
    IN  GT_U8   devNum,
    IN  GT_BOOL enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpTcamEccDaemonEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpTcamEccDaemonEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpTcamEccDaemonEnableGet
*
* DESCRIPTION:
*       Gets status (Enabled/Disabled) of Router TCAM ECC Daemon.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum        - device number
*
* OUTPUTS:
*       enablePtr     - (pointer to) Router TCAM ECC Daemon status:
*                       GT_TRUE  - Router TCAM ECC Daemon enable
*                       GT_FALSE - Router TCAM ECC Daemon disable
*
* RETURNS :
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong parameter
*       GT_BAD_PTR               - null pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpTcamEccDaemonEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_U32    value;       /* value to read from register */
    GT_STATUS rc;          /* return status */
    GT_U32    regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E |
                                          CPSS_XCAT2_E | CPSS_LION2_E | CPSS_BOBCAT2_E | CPSS_CAELUM_E | CPSS_BOBCAT3_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->ipRegs.ipTcamControl;

    /* Get ECCDaemonEn */
    rc =  prvCpssHwPpGetRegField(devNum, regAddr, 28, 1, &value);

    if(rc != GT_OK)
    {
        return rc;
    }

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpTcamEccDaemonEnableGet
*
* DESCRIPTION:
*       Gets status (Enabled/Disabled) of Router TCAM ECC Daemon.
*
* APPLICABLE DEVICES:
*        DxCh3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; xCat; xCat3; Lion; xCat2; Lion2; Bobcat2; Caelum; Bobcat3.
*
* INPUTS:
*       devNum        - device number
*
* OUTPUTS:
*       enablePtr     - (pointer to) Router TCAM ECC Daemon status:
*                       GT_TRUE  - Router TCAM ECC Daemon enable
*                       GT_FALSE - Router TCAM ECC Daemon disable
*
* RETURNS :
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong parameter
*       GT_BAD_PTR               - null pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChIpTcamEccDaemonEnableGet
(
    IN  GT_U8   devNum,
    OUT GT_BOOL *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpTcamEccDaemonEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpTcamEccDaemonEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpUcRoutingVid1AssignEnableSet
*
* DESCRIPTION:
*       Enable/disable VID1 assignment by the unicast routing
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2; DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* INPUTS:
*       devNum    - the device number
*       enable    - enable/disable VID1 assignment by the unicast routing
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on wrong devNum
*
* COMMENTS:
*       When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*       It's recommended to use this API before configuring the nexthop entries.
*       Using this API when nexthops are already configured can cause unexpected
*       results.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpUcRoutingVid1AssignEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32 regAddr;
    GT_U32 value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
                                          CPSS_CH1_E | CPSS_CH1_DIAMOND_E |
                                          CPSS_XCAT2_E | CPSS_CH2_E | CPSS_CH3_E |
                                          CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;

    /* write enable value */
    value = BOOL2BIT_MAC(enable);
    return prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, value);
}

/*******************************************************************************
* cpssDxChIpUcRoutingVid1AssignEnableSet
*
* DESCRIPTION:
*       Enable/disable VID1 assignment by the unicast routing
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2; DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* INPUTS:
*       devNum    - the device number
*       enable    - enable/disable VID1 assignment by the unicast routing
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on wrong devNum
*
* COMMENTS:
*       When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*       It's recommended to use this API before configuring the nexthop entries.
*       Using this API when nexthops are already configured can cause unexpected
*       results.
*
*******************************************************************************/
GT_STATUS cpssDxChIpUcRoutingVid1AssignEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRoutingVid1AssignEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpUcRoutingVid1AssignEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpUcRoutingVid1AssignEnableGet
*
* DESCRIPTION:
*       Get the enabling status of VID1 assignment by the unicast routing
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2; DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       enablePtr - (pointer to) VID1 unicast routing assignment enabling status
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on wrong devNum
*
* COMMENTS:
*       When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpUcRoutingVid1AssignEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32 regAddr;
    GT_U32 value;
    GT_STATUS rc;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
                                          CPSS_CH1_E | CPSS_CH1_DIAMOND_E |
                                          CPSS_XCAT2_E | CPSS_CH2_E | CPSS_CH3_E |
                                          CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl0;

    /* read enable value */
    rc = prvCpssHwPpGetRegField(devNum, regAddr, 7, 1, &value);
    *enablePtr = BIT2BOOL_MAC(value);

    return rc;
}

/*******************************************************************************
* cpssDxChIpUcRoutingVid1AssignEnableGet
*
* DESCRIPTION:
*       Get the enabling status of VID1 assignment by the unicast routing
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; xCat2; DxCh2; DxCh3; xCat; xCat3; Lion; Lion2.
*
* INPUTS:
*       devNum    - the device number
*
* OUTPUTS:
*       enablePtr - (pointer to) VID1 unicast routing assignment enabling status
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PARAM             - on wrong devNum
*
* COMMENTS:
*       When VID1 assignment is enabled QoS attributes can't be set by the
*       router and the following fields in the unicast nexthop entries are not
*       applicable:
*       qosProfileMarkingEnable, qosProfileIndex, qosPrecedence, modifyUp,
*       modifyDscp.
*       When VID1 assignment is disabled QoS attributes are applicable and
*       nextHopVlanId1 field in the unicast nexthop entries is not applicable.
*
*******************************************************************************/
GT_STATUS cpssDxChIpUcRoutingVid1AssignEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpUcRoutingVid1AssignEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpUcRoutingVid1AssignEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperBaselineSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set Token Bucket Baseline.
*       The Token Bucket Baseline is the "zero" level of the token bucket.
*       When the token bucket fill level < Baseline,
*       the respective packet is not served.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum   - device number.
*       baseline - Token Bucket Baseline value in bytes
*                   (APPLICABLE RANGES: 0..0xFFFFFF).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range baseline
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Token Bucket Baseline must be configured as follows:
*        1. At least MTU (the maximum expected packet size in the system).
*        2. When packet based shaping is enabled, the following used as
*           shaper's MTU:
*           cpssDxChIpMllMultiTargetShaperMtuSet.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperBaselineSet
(
    IN GT_U8    devNum,
    IN GT_U32   baseline
)
{
    GT_U32      regAddr;    /* register address             */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if (baseline > 0xFFFFFF)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* Set Token Bucket Base Line */
    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.tokenBucketBaseLine;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, baseline);
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperBaselineSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set Token Bucket Baseline.
*       The Token Bucket Baseline is the "zero" level of the token bucket.
*       When the token bucket fill level < Baseline,
*       the respective packet is not served.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum   - device number.
*       baseline - Token Bucket Baseline value in bytes
*                   (APPLICABLE RANGES: 0..0xFFFFFF).
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range baseline
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       Token Bucket Baseline must be configured as follows:
*        1. At least MTU (the maximum expected packet size in the system).
*        2. When packet based shaping is enabled, the following used as
*           shaper's MTU:
*           cpssDxChIpMllMultiTargetShaperMtuSet.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperBaselineSet
(
    IN GT_U8    devNum,
    IN GT_U32   baseline
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperBaselineSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, baseline));

    rc = internal_cpssDxChIpMllMultiTargetShaperBaselineSet(devNum, baseline);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, baseline));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperBaselineGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get Token Bucket Baseline.
*       The Token Bucket Baseline is the "zero" level of the token bucket.
*       When the token bucket fill level < Baseline, the respective packet
*       is not served.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - device number.
*
* OUTPUTS:
*       baselinePtr - (pointer to) Token Bucket Baseline value in bytes.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_BAD_PTR               - on NULL pointer
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperBaselineGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *baselinePtr
)
{
    GT_U32      regAddr;    /* register address                */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(baselinePtr);

    /* Get Token Bucket Base Line */
    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.tokenBucketBaseLine;

    return prvCpssHwPpGetRegField(devNum, regAddr, 0, 24, baselinePtr);
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperBaselineGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get Token Bucket Baseline.
*       The Token Bucket Baseline is the "zero" level of the token bucket.
*       When the token bucket fill level < Baseline, the respective packet
*       is not served.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - device number.
*
* OUTPUTS:
*       baselinePtr - (pointer to) Token Bucket Baseline value in bytes.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_BAD_PTR               - on NULL pointer
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperBaselineGet
(
    IN  GT_U8    devNum,
    OUT GT_U32   *baselinePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperBaselineGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, baselinePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperBaselineGet(devNum, baselinePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, baselinePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}


/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperMtuSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set the packet length in bytes for updating the shaper token bucket.
*       Valid when <Token Bucket Mode>=Packets.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum   - physical device number
*       mtu      - MTU for egress rate shaper
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperMtuSet
(
    IN GT_U8   devNum,
    IN GT_U32  mtu
)
{
    GT_U32      regAddr;     /* register address */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if(mtu>0xFFFFFF)
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 24, mtu);
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperMtuSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set the packet length in bytes for updating the shaper token bucket.
*       Valid when <Token Bucket Mode>=Packets.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum   - physical device number
*       mtu      - MTU for egress rate shaper
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range parameter
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperMtuSet
(
    IN GT_U8   devNum,
    IN GT_U32  mtu
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperMtuSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtu));

    rc = internal_cpssDxChIpMllMultiTargetShaperMtuSet(devNum, mtu);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtu));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperMtuGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get the packet length in bytes for updating the shaper token bucket.
*       Valid when <Token Bucket Mode>=Packets.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum   - physical device number
*
* OUTPUTS:
*       mtuPtr   -  pointer to MTU for egress rate shaper
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperMtuGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mtuPtr
)
{
    GT_U32      regAddr;    /* register address                */
    GT_U32      value;      /* value to read from register     */
    GT_STATUS   rc;         /* function return value           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(mtuPtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 24, &value);

    if (rc != GT_OK)
        return rc;

    *mtuPtr = value;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperMtuGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get the packet length in bytes for updating the shaper token bucket.
*       Valid when <Token Bucket Mode>=Packets.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum   - physical device number
*
* OUTPUTS:
*       mtuPtr   -  pointer to MTU for egress rate shaper
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_BAD_STATE             - on invalid hardware value read
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       <Token Bucket Mode> is configured in cpssDxChIpMllMultiTargetShaperConfigurationSet
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperMtuGet
(
    IN  GT_U8   devNum,
    OUT GT_U32  *mtuPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperMtuGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, mtuPtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperMtuGet(devNum, mtuPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, mtuPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set Token Bucket Mode Mll shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum           - device number.
*      tokenBucketMode  -   Defines the packet length used to decrease the shaper token bucket.
*                           In Byte mode, the token bucket rate shaper is decreased according to the
*                           packet length as received by the switch.
*                           In Packet mode, the token bucket rate shaper is decreased by the packet
*                           length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
* OUTPUTS:
*      None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range value
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*        None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeSet
(
    IN  GT_U8                                        devNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            tokenBucketMode
)
{
    GT_U32      regAddr;     /* register address */
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    switch(tokenBucketMode)
    {
    case  CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E:
        value = 0;
        break;
    case  CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        value = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 25, 1,value);
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperTokenBucketModeSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set Token Bucket Mode Mll shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum           - device number.
*      tokenBucketMode  -   Defines the packet length used to decrease the shaper token bucket.
*                           In Byte mode, the token bucket rate shaper is decreased according to the
*                           packet length as received by the switch.
*                           In Packet mode, the token bucket rate shaper is decreased by the packet
*                           length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
* OUTPUTS:
*      None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range value
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperTokenBucketModeSet
(
    IN  GT_U8                                        devNum,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            tokenBucketMode
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperTokenBucketModeSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketMode));

    rc = internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeSet(devNum, tokenBucketMode);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketMode));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get Token Bucket Mode Mll shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum     - device number.
*
* OUTPUTS:
*      tokenBucketModePtr  - (pointer to)Defines the packet length used to decrease the shaper token bucket.
*                           In Byte mode, the token bucket rate shaper is decreased according to the
*                           packet length as received by the switch.
*                           In Packet mode, the token bucket rate shaper is decreased by the packet
*                           length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       none.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeGet
(
    IN  GT_U8                                        devNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            *tokenBucketModePtr
)
{
    GT_U32      regAddr;    /* register address                */
    GT_U32      value;      /* value to read from register     */
    GT_STATUS   rc;         /* function return value           */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(tokenBucketModePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 25, 1, &value);

    if (rc != GT_OK)
        return rc;

    switch(value)
    {
    case  0:
        *tokenBucketModePtr = CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
        break;
    case  1:
        *tokenBucketModePtr = CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperTokenBucketModeGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get Token Bucket Mode Mll shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum     - device number.
*
* OUTPUTS:
*      tokenBucketModePtr  - (pointer to)Defines the packet length used to decrease the shaper token bucket.
*                           In Byte mode, the token bucket rate shaper is decreased according to the
*                           packet length as received by the switch.
*                           In Packet mode, the token bucket rate shaper is decreased by the packet
*                           length specified in cpssDxChIpMllMultiTargetShaperMtuSet.
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       none.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperTokenBucketModeGet
(
    IN  GT_U8                                        devNum,
    OUT CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            *tokenBucketModePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperTokenBucketModeGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketModePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperTokenBucketModeGet(devNum, tokenBucketModePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketModePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperEnableSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Enable/Disable Token Bucket rate shaping.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - physical device number
*       enable  - GT_TRUE, enable Shaping
*                 GT_FALSE, disable Shaping
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong port number or device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_U32      regAddr;
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    value = BOOL2BIT_MAC(enable);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    return prvCpssHwPpSetRegField(devNum, regAddr, 0, 1, value);

}

/*******************************************************************************
*  cpssDxChIpMllMultiTargetShaperEnableSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Enable/Disable Token Bucket rate shaping.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - physical device number
*       enable  - GT_TRUE, enable Shaping
*                 GT_FALSE, disable Shaping
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong port number or device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS  cpssDxChIpMllMultiTargetShaperEnableSet
(
    IN  GT_U8     devNum,
    IN  GT_BOOL   enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpMllMultiTargetShaperEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperEnableGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get Enable/Disable Token Bucket rate shaping status
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - physical device number
*
* OUTPUTS:
*       enablePtr - Pointer to Token Bucket rate shaping status.
*                   - GT_TRUE, enable Shaping
*                   - GT_FALSE, disable Shaping
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong port number or device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters in NULL pointer.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS   rc;
    GT_U32      regAddr;    /* register address for token bucket*/
    GT_U32      value;      /* register field value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    regAddr =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 0, 1, &value);

    if (rc != GT_OK)
        return rc;

    *enablePtr = BIT2BOOL_MAC(value);

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperEnableGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get Enable/Disable Token Bucket rate shaping status
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - physical device number
*
* OUTPUTS:
*       enablePtr - Pointer to Token Bucket rate shaping status.
*                   - GT_TRUE, enable Shaping
*                   - GT_FALSE, disable Shaping
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong port number or device
*       GT_HW_ERROR              - on hardware error
*       GT_BAD_PTR               - one of the parameters in NULL pointer.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperEnableGet
(
    IN  GT_U8     devNum,
    OUT GT_BOOL  *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate
*
* DESCRIPTION:
*       Calculate shaping rate parameters for given tokenBucketRate:
*          1. TB refill value
*          2. slow rate enable value
*          3. TB interval update ratio value
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum                             - physical device number
*       tokenBucketIntervalSlowUpdateRatio - Increases the token bucket update interval to
*                                           <TokenBucketIntervalSlowUpdateRatio>+1> * <TokenBucketUpdateInterval> *
*                                           (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                           Enabled by setting SlowRateEn = GT_TRUE.
*                                           (APPLICABLE RANGES: 1...16)
*       tokenBucketUpdateInterval   - Defines the token update interval for the egress rate shapers.
*                                     The update interval = <TokenBucketIntervalSlowUpdateRatio>+1> *
*                                     <TokenBucketUpdateInterval> * (64 or 1024 depends on
*                                     <TokenBucketIntervalUpdateRatio>)*2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                     Upon every interval expiration, a configured amount of tokens is added to the
*                                     token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                     NOTE:
*                                     - This field must not be 0.
*                                     - The inclusion of <TokenBucketIntervalSlowUpdateRatio>+1> is enabled per shaper.
*                                     (APPLICABLE RANGES: 1...15)
*       tokenBucketIntervalUpdateRatio - Token Bucket Interval Update Ratio : 64 or 1024
*       tokenBucketMode                - Defines the packet length used to decrease the shaper token bucket.
*       tokenBucketRate                - the shaping rate - actual Rate in Kbps.
*
* OUTPUTS:
*       slowRateEnPtr       - (pointer to) slow rate enable value
*       tbUpdateRatioPtr    - (pointer to) TB interval update ratio value
*       tokenRefillValuePtr - (pointer to) TB refill value
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong port number or device
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT               tokenBucketMode,
    IN  GT_U32                                          tokenBucketRate,
    OUT GT_BOOL                                         *slowRateEnPtr,
    OUT GT_U32                                          *tbUpdateRatioPtr,
    OUT GT_U32                                          *tokenRefillValuePtr
)
{
    GT_STATUS                             rc = GT_OK;
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   txShaperConfig;
    GT_U32                                multiTargetMtu;

    /* emulate a txq shaper struct from MLL Multi Target shaper struct */
    txShaperConfig.tokensRate = tokenBucketUpdateInterval;

    txShaperConfig.slowRateRatio = tokenBucketIntervalSlowUpdateRatio;

    switch(tokenBucketIntervalUpdateRatio)
    {
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
            break;
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg,
                                0, 24, &multiTargetMtu);

    if(rc != GT_OK)
        return rc;

    txShaperConfig.portsPacketLength = multiTargetMtu;
    txShaperConfig.cpuPacketLength   = multiTargetMtu;


    return prvCpssDxChPortTxReCalcShaperTokenBucketRate_rev1(devNum,
                                                          0,
                                                          GT_TRUE,
                                                          &txShaperConfig,
                                                          tokenBucketMode,
                                                          tokenBucketRate,
                                                          slowRateEnPtr,
                                                          tbUpdateRatioPtr,
                                                          tokenRefillValuePtr);
}

/*******************************************************************************
* prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate
*
* DESCRIPTION:
*       Get shaper parameters for token bucket:
*       - Token refill value.
*       - slow-rate mode.
*       - tokens rate
*       - slow rate ratio.
*  The Formula is:
*                 <Core Clock Frequency in Kbps> * <Token refill value in bits>
*  Rate in Kbps = -------------------------------------------------------------
*                               <Refill period in clock cycles>
*
*  Refill period in clock cycles when slow rate is enabled =
*    <tokensRate> * <tokensRateGran> * <Slow Rate>
*  Refill period in clock cycles when slow rate is disabled =
*    <tokensRate> * <tokensRateGran> * 2 ^ < tbUpdateRatio >
*
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum             - physical device number
*       tokenBucketIntervalSlowUpdateRatio - Increases the token bucket update interval to
*                                           <TokenBucketIntervalSlowUpdateRatio>+1> * <TokenBucketUpdateInterval> *
*                                           (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                           Enabled by setting SlowRateEn = GT_TRUE.
*                                           (APPLICABLE RANGES: 1...16)
*       tokenBucketUpdateInterval   - Defines the token update interval for the egress rate shapers.
*                                     The update interval = <TokenBucketIntervalSlowUpdateRatio>+1> *
*                                     <TokenBucketUpdateInterval> * (64 or 1024 depends on
*                                     <TokenBucketIntervalUpdateRatio>)*2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                     Upon every interval expiration, a configured amount of tokens is added to the
*                                     token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                     NOTE:
*                                     - This field must not be 0.
*                                     - The inclusion of <TokenBucketIntervalSlowUpdateRatio>+1> is enabled per shaper.
*                                     (APPLICABLE RANGES: 1...15)
*       tokenBucketIntervalUpdateRatio  - Token Bucket Interval Update Ratio : 64 or 1024
*       tokenBucketMode                 - Defines the packet length used to decrease the shaper token bucket.
*       slowRateEn                      - slow rate enable value
*       tbUpdateRatio                   - TB interval update ratio value
*       tokenRefillValue                - TB refill value
*
* OUTPUTS:
*       tokenBucketRatePtr - (pointer to) the actual Rate in Kbps or pps.
*
* RETURNS:
*       GT_OK        - on success
*
* COMMENTS:
*      None
*
*******************************************************************************/
static GT_STATUS prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio,
    IN  CPSS_PORT_TX_DROP_SHAPER_MODE_ENT               tokenBucketMode,
    IN  GT_BOOL                                         slowRateEn,
    IN  GT_U32                                          tbUpdateRatio,
    IN  GT_U32                                          tokenRefillValue,
    OUT GT_U32                                          *tokenBucketRatePtr
)
{
    GT_STATUS                             rc = GT_OK;
    CPSS_DXCH_PORT_TX_SHAPER_CONFIG_STC   txShaperConfig;
    GT_U32                                multiTargetMtu;

    /* emulate a txq shaper struct from MLL Multi Target shaper struct */
    txShaperConfig.tokensRate = tokenBucketUpdateInterval;

    txShaperConfig.slowRateRatio = tokenBucketIntervalSlowUpdateRatio;

    switch(tokenBucketIntervalUpdateRatio)
    {
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
            break;
        case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
            txShaperConfig.tokensRateGran=CPSS_DXCH_PORT_TX_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetMTUReg,
                                0, 24, &multiTargetMtu);

    if(rc != GT_OK)
        return rc;

    txShaperConfig.portsPacketLength = multiTargetMtu;
    txShaperConfig.cpuPacketLength   = multiTargetMtu;

    return prvDxChPortTxCalcShaperTokenBucketRate_rev1(devNum,
                                                     0,
                                                     &txShaperConfig,
                                                     tokenBucketMode,
                                                     slowRateEn,
                                                     tbUpdateRatio,
                                                     tokenRefillValue,
                                                     tokenBucketRatePtr);
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperConfigurationSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set configuration for Mll shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum           - device number.
*      maxBucketSize    - Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                         The actual burst size is approximately
*                         <MaxBucketSize>*4096 - <Token Bucket Base Line>
*                         When the CPU writes to this field, the value is also written
*                         to the Token Bucket counter.
*                         <MaxBucketSize>*4096 must be set to be greater than both <Tokens>
*                         and <Token Bucket Base Line>.
*                         0 means 4k and 0xFFF means 16M
*                         The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                         (APPLICABLE RANGES: 0...0xFFF)
*      maxRatePtr       - Requested Rate in Kbps or packets per second
*                         according to shaper mode.
* OUTPUTS:
*      maxRatePtr   - (pointer to) the actual Rate value in Kbps or packets per second.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range value
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*        When packet based shaping is enabled, the following used as shaper's MTU:
*        see:
*        cpssDxChIpMllMultiTargetShaperMtuSet
*        cpssDxChIpMllMultiTargetShaperBaselineSet.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperConfigurationSet
(
    IN  GT_U8                                        devNum,
    IN  GT_U32                                       maxBucketSize,
    INOUT GT_U32                                     *maxRatePtr
)
{
    GT_U32      value1, value2;     /* value to write into register */
    GT_U32      hwData1, hwData2;   /* hwData from register */
    GT_STATUS   rc;                 /* return code */
    GT_U32      regAddr1, regAddr2; /* register address             */
    GT_U32      mask1, mask2;       /* register mask */
    GT_U32      hwTokenBucketMode;
    GT_U32      hwTokenBucketIntervalUpdateRatio;
    GT_U32      tokenBucketBaseLine;
    GT_U32      tokenRefillValue;
    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT            tokenBucketMode;

    GT_U32 tokenBucketIntervalSlowUpdateRatio;/* Increases the token bucket update interval (1-16)*/
    GT_U32 tokenBucketUpdateInterval;/* Defines the token update interval for the egress rate shapers (1-15) */
    CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT tokenBucketIntervalUpdateRatio;/* Token Bucket Interval Update Ratio : 64 or 1024*/


    GT_U32      tbUpdateRatio;    /* TB interval update ratio value */
    GT_BOOL     slowRateEnable;   /* slow rate enable value */

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);


    if(maxBucketSize > CPSS_DXCH_MULTI_TARGET_SHAPER_MAX_BUCKET_SIZE_CNS)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    /* MaxBucketSize*4096 must be set to be greater than both <Tokens> and <Token Bucket Base Line>.
       number of tokens equal to (Token Refill Value + 1) --> this validation will be done in
       prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate  */
    rc = prvCpssHwPpGetRegField(devNum,
                                PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.tokenBucketBaseLine,
                                0, 24, &tokenBucketBaseLine);
    if (rc != GT_OK)
    {
        return rc;
    }
    /* maxBucketSize=0 --> means maxBucketSize is 4K
       maxBucketSize=1 --> means maxBucketSize is 8K
       and so on .... until 16M */
    if(((maxBucketSize+1) * _4KB) <= tokenBucketBaseLine)
    {
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);
    }

    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    /* read data from HW used for calculation of slowRateEnable, tbUpdateRatio
       and tokenRefillValue according to the maxRatePtr input parameter. */
    rc = prvCpssHwPpReadRegister(devNum,regAddr1,&hwData1);
    if (rc != GT_OK)
    {
        return rc;
    }

    switch(U32_GET_FIELD_MAC(hwData1, 25, 1))
    {
        case 0:
            tokenBucketMode=CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
            break;
        case 1:
            tokenBucketMode=CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_VALUE, LOG_ERROR_NO_MSG);
    }

    tokenBucketIntervalSlowUpdateRatio = U32_GET_FIELD_MAC(hwData1, 27, 4) + 1;

    rc = prvCpssHwPpReadRegister(devNum,regAddr2,&hwData2);
    if (rc != GT_OK)
    {
        return rc;
    }

    tokenBucketUpdateInterval = U32_GET_FIELD_MAC(hwData2, 0, 4);
    switch(U32_GET_FIELD_MAC(hwData2, 8, 1))
    {
    case 0:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
        break;
    case 1:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    /* calulate per TB configurations */
    rc = prvCpssDxChIpMllMultiTargetReCalcShaperTokenBucketRate(devNum,
                                                                tokenBucketIntervalSlowUpdateRatio,
                                                                tokenBucketUpdateInterval,
                                                                tokenBucketIntervalUpdateRatio,
                                                                tokenBucketMode,
                                                                *maxRatePtr,
                                                                &slowRateEnable,
                                                                &tbUpdateRatio,
                                                                &tokenRefillValue);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* calulate the actual Rate value */
    rc = prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate(devNum,
                                                        tokenBucketIntervalSlowUpdateRatio,
                                                        tokenBucketUpdateInterval,
                                                        tokenBucketIntervalUpdateRatio,
                                                        tokenBucketMode,
                                                        slowRateEnable,
                                                        tbUpdateRatio,
                                                        tokenRefillValue,
                                                        maxRatePtr);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* for value 1:
       bits [1:12] maxBucketSize, [13:24] tokenRefillValue, [25]tokenBucketMode
       bits [26] slowRateEn, [27:30] tokenBucketIntervalSlowUpdateRatio, [31] tbScanEn */
    value1 = (((maxBucketSize & 0xFFF) << 1) |
              ((tokenRefillValue & 0xFFF) << 13));

    switch(tokenBucketMode)
    {
    case CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E:
        hwTokenBucketMode = 0;
        break;
    case CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E:
        hwTokenBucketMode = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    value1 |= (hwTokenBucketMode << 25) | (BOOL2BIT_MAC(slowRateEnable) << 26) |
              (((tokenBucketIntervalSlowUpdateRatio - 1) & 0xF) << 27);

    mask1  = 0x7FFFFFFE;

    rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr1, mask1, value1);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* for value 2:
       bits [0:3] tokenBucketUpdateInterval, [4:7] tbIntervalUpdateRatio,
       bits [8] tokenBucketIntervalUpdateRatio*/
    value2 = (tokenBucketUpdateInterval & 0xF) |
             ((tbUpdateRatio & 0xF) << 4);

    switch(tokenBucketIntervalUpdateRatio)
    {
    case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
        hwTokenBucketIntervalUpdateRatio = 0;
        break;
    case CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        hwTokenBucketIntervalUpdateRatio = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_PARAM, LOG_ERROR_NO_MSG);

    }

    value2 |= (hwTokenBucketIntervalUpdateRatio << 8);
    mask2  = 0x1FF;

    rc = prvCpssHwPpWriteRegBitMask(devNum, regAddr2, mask2, value2);
    if (rc != GT_OK)
    {
        return rc;
    }

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperConfigurationSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set configuration for Mll shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum           - device number.
*      maxBucketSize    - Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                         The actual burst size is approximately
*                         <MaxBucketSize>*4096 - <Token Bucket Base Line>
*                         When the CPU writes to this field, the value is also written
*                         to the Token Bucket counter.
*                         <MaxBucketSize>*4096 must be set to be greater than both <Tokens>
*                         and <Token Bucket Base Line>.
*                         0 means 4k and 0xFFF means 16M
*                         The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                         (APPLICABLE RANGES: 0...0xFFF)
*      maxRatePtr       - Requested Rate in Kbps or packets per second
*                         according to shaper mode.
* OUTPUTS:
*      maxRatePtr   - (pointer to) the actual Rate value in Kbps or packets per second.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range value
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*        When packet based shaping is enabled, the following used as shaper's MTU:
*        see:
*        cpssDxChIpMllMultiTargetShaperMtuSet
*        cpssDxChIpMllMultiTargetShaperBaselineSet.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperConfigurationSet
(
    IN  GT_U8                                        devNum,
    IN  GT_U32                                       maxBucketSize,
    INOUT GT_U32                                     *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperConfigurationSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maxBucketSize, maxRatePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperConfigurationSet(devNum, maxBucketSize, maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maxBucketSize, maxRatePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperConfigurationGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get configuration for shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum     - device number.
*
* OUTPUTS:
*     maxBucketSizePtr    - (pointer to) Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                         The actual burst size is approximately
*                         <MaxBucketSize>*4096 - <Token Bucket Base Line>
*                         When the CPU writes to this field, the value is also written
*                         to the Token Bucket counter.
*                         <MaxBucketSize>*4096 must be set to be greater than both <Tokens>
*                         and <Token Bucket Base Line>.
*                         0 equal 4k all 12'bFFF equal 16M
*                         The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                         (APPLICABLE RANGES: 0...0xFFF)
*      maxRatePtr          - (pointer to) the actual Rate value in Kbps or packets per second.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       none.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperConfigurationGet
(
    IN  GT_U8                                        devNum,
    OUT GT_U32                                       *maxBucketSizePtr,
    OUT GT_U32                                       *maxRatePtr
)
{
    GT_U32      value1, value2;     /* value to write into register */
    GT_STATUS   rc;                 /* return code                  */
    GT_U32      regAddr1,regAddr2;  /* register address             */
    GT_BOOL     slowRateEn;
    GT_U32      tbIntervalUpdateRatio;
    GT_U32      tokenRefillValue;
    GT_U32      tokenBucketRate;

    GT_U32 tokenBucketIntervalSlowUpdateRatio;/* Increases the token bucket update interval (1-16)*/
    GT_U32 tokenBucketUpdateInterval;/* Defines the token update interval for the egress rate shapers (1-15) */
    CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT tokenBucketIntervalUpdateRatio;/* Token Bucket Interval Update Ratio : 64 or 1024*/
    CPSS_PORT_TX_DROP_SHAPER_MODE_ENT             tokenBucketMode;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(maxBucketSizePtr);
    CPSS_NULL_PTR_CHECK_MAC(maxRatePtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);


    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    rc = prvCpssHwPpReadRegister(devNum, regAddr1, &value1);
    if (rc != GT_OK)
    {
        return rc;
    }
    rc = prvCpssHwPpReadRegister(devNum, regAddr2, &value2);
    if (rc != GT_OK)
    {
        return rc;
    }

    /* for value 1:
       bits [1:12] maxBucketSize, [13:24] tokenRefillValue, [25]tokenBucketMode
       bits [26] slowRateEn, [27:30] tokenBucketIntervalSlowUpdateRatio, [31] tbScanEn */
    *maxBucketSizePtr = U32_GET_FIELD_MAC(value1, 1, 12);
    tokenRefillValue = U32_GET_FIELD_MAC(value1, 13, 12);

    switch(U32_GET_FIELD_MAC(value1, 25, 1))
    {
    case 0:
        tokenBucketMode = CPSS_PORT_TX_DROP_SHAPER_BYTE_MODE_E;
        break;
    case 1:
        tokenBucketMode = CPSS_PORT_TX_DROP_SHAPER_PACKET_MODE_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }

    slowRateEn = BIT2BOOL_MAC(U32_GET_FIELD_MAC(value1, 26, 1));

    tokenBucketIntervalSlowUpdateRatio = U32_GET_FIELD_MAC(value1, 27, 4) + 1;

    /* for value 2:
       bits [0:3] tokenBucketUpdateInterval, [4:7] tbIntervalUpdateRatio,
       bits [8] tokenBucketIntervalUpdateRatio */

    tokenBucketUpdateInterval = U32_GET_FIELD_MAC(value2, 0, 4);
    tbIntervalUpdateRatio = U32_GET_FIELD_MAC(value2, 4, 4);

    switch(U32_GET_FIELD_MAC(value2, 8, 1))
    {
    case 0:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
        break;
    case 1:
        tokenBucketIntervalUpdateRatio = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_BAD_STATE, LOG_ERROR_NO_MSG);
    }



    rc = prvCpssDxChIpMllMultiTargetCalcShaperTokenBucketRate(devNum,
                                                              tokenBucketIntervalSlowUpdateRatio,
                                                              tokenBucketUpdateInterval,
                                                              tokenBucketIntervalUpdateRatio,
                                                              tokenBucketMode,
                                                              slowRateEn,
                                                              tbIntervalUpdateRatio,
                                                              tokenRefillValue,
                                                              &tokenBucketRate);
    if (rc != GT_OK)
    {
        return rc;
    }
    *maxRatePtr = tokenBucketRate;

    return GT_OK;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperConfigurationGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get configuration for shaper.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum     - device number.
*
* OUTPUTS:
*     maxBucketSizePtr    - (pointer to) Maximum bucket size in bytes. The field resolution is 4096 bytes.
*                         The actual burst size is approximately
*                         <MaxBucketSize>*4096 - <Token Bucket Base Line>
*                         When the CPU writes to this field, the value is also written
*                         to the Token Bucket counter.
*                         <MaxBucketSize>*4096 must be set to be greater than both <Tokens>
*                         and <Token Bucket Base Line>.
*                         0 equal 4k all 12'bFFF equal 16M
*                         The bucket size ranges from 4 KB to 16 MB, in steps of 4K.
*                         (APPLICABLE RANGES: 0...0xFFF)
*      maxRatePtr          - (pointer to) the actual Rate value in Kbps or packets per second.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       none.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperConfigurationGet
(
    IN  GT_U8                                        devNum,
    OUT GT_U32                                       *maxBucketSizePtr,
    OUT GT_U32                                       *maxRatePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperConfigurationGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, maxBucketSizePtr, maxRatePtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperConfigurationGet(devNum, maxBucketSizePtr, maxRatePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, maxBucketSizePtr, maxRatePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set configuration for Mll shaper Interval.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum                               - device number.
*      tokenBucketIntervalSlowUpdateRatio   - Increases the token bucket update interval to
*                                                <TokenBucketIntervalSlowUpdateRatio>+1> * <TokenBucketUpdateInterval> *
*                                                (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                                Enabled by setting SlowRateEn = GT_TRUE.
*                                                (APPLICABLE RANGES: 1...16)
*
*       tokenBucketUpdateInterval           -   Defines the token update interval for the egress rate shapers.
*                                         The update interval = <TokenBucketIntervalSlowUpdateRatio>+1> *
*                                        <TokenBucketUpdateInterval> * (64 or 1024 depends on
*                                        <TokenBucketIntervalUpdateRatio>)*2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                        Upon every interval expiration, a configured amount of tokens is added to the
*                                        token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                        NOTE:
*                                        - This field must not be 0.
*                                          (APPLICABLE RANGES: 1...15)
*      tokenBucketIntervalUpdateRatio  - Token Bucket Interval Update Ratio : 64 or 1024
*
* OUTPUTS:
*      None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range value
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio
)
{
    GT_STATUS rc = GT_OK;
    GT_U32      regAddr1,regAddr2;     /* register address */
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    if((tokenBucketIntervalSlowUpdateRatio < PRV_CPSS_DXCH_TXQREV1_SLOW_TOKEN_BCKT_UPD_RATIO_MIN_CNS) ||
        (tokenBucketIntervalSlowUpdateRatio > PRV_CPSS_DXCH_TXQREV1_SLOW_TOKEN_BCKT_UPD_RATIO_MAX_CNS))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    if((tokenBucketUpdateInterval < PRV_CPSS_DXCH_TXQREV1_TOKEN_BCKT_UPD_RATE_MIN_CNS)||
       (tokenBucketUpdateInterval > PRV_CPSS_DXCH_TXQREV1_TOKEN_BCKT_UPD_RATE_MAX_CNS))
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);

    switch(tokenBucketIntervalUpdateRatio)
    {
    case  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E:
        value = 0;
        break;
    case  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E:
        value = 1;
        break;
    default:
        CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }

    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    rc = prvCpssHwPpSetRegField(devNum, regAddr1, 27, 4, (tokenBucketIntervalSlowUpdateRatio-1));
    if(rc != GT_OK)
        return rc;

    rc = prvCpssHwPpSetRegField(devNum, regAddr2, 0, 4, tokenBucketUpdateInterval);
    if(rc != GT_OK)
        return rc;

     rc = prvCpssHwPpSetRegField(devNum, regAddr2, 8, 1, value);
    if(rc != GT_OK)
        return rc;

    return rc;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Set configuration for Mll shaper Interval.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum                               - device number.
*      tokenBucketIntervalSlowUpdateRatio   - Increases the token bucket update interval to
*                                                <TokenBucketIntervalSlowUpdateRatio>+1> * <TokenBucketUpdateInterval> *
*                                                (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                                Enabled by setting SlowRateEn = GT_TRUE.
*                                                (APPLICABLE RANGES: 1...16)
*
*       tokenBucketUpdateInterval           -   Defines the token update interval for the egress rate shapers.
*                                         The update interval = <TokenBucketIntervalSlowUpdateRatio>+1> *
*                                        <TokenBucketUpdateInterval> * (64 or 1024 depends on
*                                        <TokenBucketIntervalUpdateRatio>)*2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                        Upon every interval expiration, a configured amount of tokens is added to the
*                                        token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                        NOTE:
*                                        - This field must not be 0.
*                                          (APPLICABLE RANGES: 1...15)
*      tokenBucketIntervalUpdateRatio  - Token Bucket Interval Update Ratio : 64 or 1024
*
* OUTPUTS:
*      None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_OUT_OF_RANGE          - on out of range value
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet
(
    IN  GT_U8                                           devNum,
    IN  GT_U32                                          tokenBucketIntervalSlowUpdateRatio,
    IN  GT_U32                                          tokenBucketUpdateInterval,
    IN  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   tokenBucketIntervalUpdateRatio
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketIntervalSlowUpdateRatio, tokenBucketUpdateInterval, tokenBucketIntervalUpdateRatio));

    rc = internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationSet(devNum, tokenBucketIntervalSlowUpdateRatio, tokenBucketUpdateInterval, tokenBucketIntervalUpdateRatio);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketIntervalSlowUpdateRatio, tokenBucketUpdateInterval, tokenBucketIntervalUpdateRatio));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get configuration for shaper Interval.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum     - device number.
*
* OUTPUTS:
*      tokenBucketIntervalSlowUpdateRatioPtr   - (pointer to) Increases the token bucket update interval to
*                                                <TokenBucketIntervalSlowUpdateRatio>+1> * <TokenBucketUpdateInterval> *
*                                                (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                                Enabled by setting SlowRateEn = GT_TRUE.
*                                                (APPLICABLE RANGES: 1...16)
*
*       tokenBucketUpdateIntervalPtr    -   (pointer to) the token update interval for the egress rate shapers.
*                                         The update interval = <TokenBucketIntervalSlowUpdateRatio>+1> *
*                                        <TokenBucketUpdateInterval> * (64 or 1024 depends on
*                                        <TokenBucketIntervalUpdateRatio>)*2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                        Upon every interval expiration, a configured amount of tokens is added to the
*                                        token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                        NOTE:
*                                        - This field must not be 0.
*                                          (APPLICABLE RANGES: 1...15)
*      tokenBucketIntervalUpdateRatioPtr  - (pointer to) Token Bucket Interval Update Ratio : 64 or 1024
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       none.
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet
(
    IN   GT_U8                                           devNum,
    OUT  GT_U32                                          *tokenBucketIntervalSlowUpdateRatioPtr,
    OUT  GT_U32                                          *tokenBucketUpdateIntervalPtr,
    OUT  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   *tokenBucketIntervalUpdateRatioPtr
)
{
    GT_STATUS   rc = GT_OK;
    GT_U32      regAddr1,regAddr2;     /* register address */
    GT_U32      value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
         CPSS_CH1_E | CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E |
         CPSS_XCAT_E | CPSS_XCAT3_E | CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    CPSS_NULL_PTR_CHECK_MAC(tokenBucketIntervalSlowUpdateRatioPtr);
    CPSS_NULL_PTR_CHECK_MAC(tokenBucketUpdateIntervalPtr);
    CPSS_NULL_PTR_CHECK_MAC(tokenBucketIntervalUpdateRatioPtr);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);



    regAddr1 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig;
    regAddr2 =  PRV_DXCH_REG1_UNIT_MLL_MAC(devNum).multiTargetRateShape.multiTargetRateShapeConfig2;

    rc = prvCpssHwPpGetRegField(devNum, regAddr1, 27, 4, &value);
    if(rc != GT_OK)
        return rc;

    *tokenBucketIntervalSlowUpdateRatioPtr = value + 1;

    rc = prvCpssHwPpGetRegField(devNum, regAddr2, 0, 4, &value);
    if(rc != GT_OK)
        return rc;

    *tokenBucketUpdateIntervalPtr = value;

    rc = prvCpssHwPpGetRegField(devNum, regAddr2, 8, 1,  &value);
    if(rc != GT_OK)
        return rc;

    switch(value)
    {
        case  0:
            *tokenBucketIntervalUpdateRatioPtr = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_64_CORE_CLOCKS_E;
            break;
        case  1:
            *tokenBucketIntervalUpdateRatioPtr = CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_1024_CORE_CLOCKS_E;
            break;
        default:
            CPSS_LOG_ERROR_AND_RETURN_MAC(GT_OUT_OF_RANGE, LOG_ERROR_NO_MSG);
    }
    return rc;
}

/*******************************************************************************
* cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet
*
* DESCRIPTION:
*       Relevant for L2 and L3 MLL.
*       Get configuration for shaper Interval.
*
* APPLICABLE DEVICES:
*        Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*      devNum     - device number.
*
* OUTPUTS:
*      tokenBucketIntervalSlowUpdateRatioPtr   - (pointer to) Increases the token bucket update interval to
*                                                <TokenBucketIntervalSlowUpdateRatio>+1> * <TokenBucketUpdateInterval> *
*                                                (64 or 1024 depends on <TokenBucketIntervalUpdateRatio>) core clock cycles.
*                                                Enabled by setting SlowRateEn = GT_TRUE.
*                                                (APPLICABLE RANGES: 1...16)
*
*       tokenBucketUpdateIntervalPtr    -   (pointer to) the token update interval for the egress rate shapers.
*                                         The update interval = <TokenBucketIntervalSlowUpdateRatio>+1> *
*                                        <TokenBucketUpdateInterval> * (64 or 1024 depends on
*                                        <TokenBucketIntervalUpdateRatio>)*2^(Port/PriorityTokenBucketEntry<TBIntervalUpdateRatio>) core clock cycles.
*                                        Upon every interval expiration, a configured amount of tokens is added to the
*                                        token bucket. The amount of tokens is configured in Port/PriorityTokenBucketEntry<Tokens>.
*                                        NOTE:
*                                        - This field must not be 0.
*                                          (APPLICABLE RANGES: 1...15)
*      tokenBucketIntervalUpdateRatioPtr  - (pointer to) Token Bucket Interval Update Ratio : 64 or 1024
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       none.
*
*******************************************************************************/
GT_STATUS cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet
(
    IN   GT_U8                                           devNum,
    OUT  GT_U32                                          *tokenBucketIntervalSlowUpdateRatioPtr,
    OUT  GT_U32                                          *tokenBucketUpdateIntervalPtr,
    OUT  CPSS_DXCH_MULTI_TARGET_SHAPER_GRANULARITY_ENT   *tokenBucketIntervalUpdateRatioPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, tokenBucketIntervalSlowUpdateRatioPtr, tokenBucketUpdateIntervalPtr, tokenBucketIntervalUpdateRatioPtr));

    rc = internal_cpssDxChIpMllMultiTargetShaperIntervalConfigurationGet(devNum, tokenBucketIntervalSlowUpdateRatioPtr, tokenBucketUpdateIntervalPtr, tokenBucketIntervalUpdateRatioPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, tokenBucketIntervalSlowUpdateRatioPtr, tokenBucketUpdateIntervalPtr, tokenBucketIntervalUpdateRatioPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet
*
* DESCRIPTION:
*       Enable/disable bypassing the router triggering requirements for policy
*       based routing packets
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum     - device number
*       enable     - enable bypassing the router triggering requirements for PBR
*                    packets:
*                    GT_FALSE: Policy based routing uses the normal router
*                              triggering requirements
*                    GT_TRUE:  Policy based routing bypasses the router triggering
*                              requirement for the FDB DA entry <DA Route> to be
*                              set for UC routing
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_U32    regAddr;
    GT_U32      hwData;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
          CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);

    /* Get address of register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;

    hwData = BOOL2BIT_MAC(enable);
    return prvCpssHwPpSetRegField(devNum, regAddr, 7, 1, hwData);
}

/*******************************************************************************
* cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet
*
* DESCRIPTION:
*       Enable/disable bypassing the router triggering requirements for policy
*       based routing packets
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum     - device number
*       enable     - enable bypassing the router triggering requirements for PBR
*                    packets:
*                    GT_FALSE: Policy based routing uses the normal router
*                              triggering requirements
*                    GT_TRUE:  Policy based routing bypasses the router triggering
*                              requirement for the FDB DA entry <DA Route> to be
*                              set for UC routing
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet
(
    IN  GT_U8       devNum,
    IN  GT_BOOL     enable
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enable));

    rc = internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableSet(devNum, enable);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enable));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet
*
* DESCRIPTION:
*       Get the enabling status of bypassing the router triggering requirements
*       for policy based routing packets
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum     - device number
*
* OUTPUTS:
*       enablePtr  - the router triggering requirements enabling status for PBR
*                    packets:
*                    GT_FALSE: Policy based routing uses the normal router
*                              triggering requirements
*                    GT_TRUE:  Policy based routing bypasses the router triggering
*                              requirement for the FDB DA entry <DA Route> to be
*                              set for UC routing
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_U32      regAddr;
    GT_U32      hwData;
    GT_STATUS   rc;

    /* check parameters */
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
          CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
          CPSS_XCAT2_E | CPSS_LION_E | CPSS_LION2_E);

    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    CPSS_NULL_PTR_CHECK_MAC(enablePtr);

    /* Get address of register */
    regAddr = PRV_CPSS_DXCH_DEV_REGS_VER1_MAC(devNum)->IPvX.routerGlobalCtrl.routerGlobalCtrl1;

    rc = prvCpssHwPpGetRegField(devNum, regAddr, 7, 1, &hwData);
    if (rc == GT_OK)
    {
        *enablePtr = BIT2BOOL_MAC(hwData);
    }
    return rc;
}

/*******************************************************************************
* cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet
*
* DESCRIPTION:
*       Get the enabling status of bypassing the router triggering requirements
*       for policy based routing packets
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum     - device number
*
* OUTPUTS:
*       enablePtr  - the router triggering requirements enabling status for PBR
*                    packets:
*                    GT_FALSE: Policy based routing uses the normal router
*                              triggering requirements
*                    GT_TRUE:  Policy based routing bypasses the router triggering
*                              requirement for the FDB DA entry <DA Route> to be
*                              set for UC routing
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PTR               - on NULL pointer
*       GT_BAD_PARAM             - on wrong device number
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet
(
    IN  GT_U8       devNum,
    OUT GT_BOOL     *enablePtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, enablePtr));

    rc = internal_cpssDxChIpPbrBypassRouterTriggerRequirementsEnableGet(devNum, enablePtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, enablePtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpVlanMrstBitmapSet
*
* DESCRIPTION:
*       Set the next-hop MSRT state bitmap per eVLAN.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - device number
*       vlanId  - VLAN ID
*       mrstBmp - Multicast Routing Shared Tree ID 64 bit bitmap
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong input parameter
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS internal_cpssDxChIpVlanMrstBitmapSet
(
    IN  GT_U8                           devNum,
    IN  GT_U16                          vlanId,
    IN  GT_U64                          mrstBmp
)
{
    GT_STATUS rc = GT_OK;
    GT_U32    word;
    GT_U32    offset;
    GT_U32    length;
    GT_U32    value;

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
            CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
            CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vlanId);

    for (word = 0; word < 3; word++)
    {
        if (word == 0)
        {
            offset = 2;
            length = 30;
            value = mrstBmp.l[0] & 0x3FFFFFFF;
        }
        else if(word == 1)
        {
            offset = 0;
            length = 32;
            value = (mrstBmp.l[1] << 2) | (mrstBmp.l[0] >> 30);
        }
        else /*word == 2*/
        {
            offset = 0;
            length = 2;
            value = mrstBmp.l[1] >> 30;
        }
        rc = prvCpssDxChWriteTableEntryField(devNum,
                                             PRV_CPSS_DXCH_LION3_TABLE_IPVX_EVLAN_E,
                                             vlanId,
                                             word,
                                             offset,
                                             length,
                                             value);
    }
    return rc;
}

/*******************************************************************************
* cpssDxChIpVlanMrstBitmapSet
*
* DESCRIPTION:
*       Set the next-hop MSRT state bitmap per eVLAN.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum  - device number
*       vlanId  - VLAN ID
*       mrstBmp - Multicast Routing Shared Tree ID 64 bit bitmap
*
* OUTPUTS:
*       None
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong input parameter
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpVlanMrstBitmapSet
(
    IN  GT_U8     devNum,
    IN  GT_U16    vlanId,
    IN  GT_U64    mrstBmp
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpVlanMrstBitmapSet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlanId, mrstBmp));

    rc = internal_cpssDxChIpVlanMrstBitmapSet(devNum, vlanId, mrstBmp);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlanId, mrstBmp));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

/*******************************************************************************
* internal_cpssDxChIpVlanMrstBitmapGet
*
* DESCRIPTION:
*       Get the next-hop MSRT state bitmap per eVLAN.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum - device number
*       vlanId - VLAN ID
*
* OUTPUTS:
*       mrstBmpPtr - pointer to Multicast Routing Shared Tree ID 64 bit bitmap
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong input parameter
*       GT_BAD_PTR               - on NULL pointer
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS internal_cpssDxChIpVlanMrstBitmapGet
(
    IN  GT_U8     devNum,
    IN  GT_U16    vlanId,
    OUT GT_U64    *mrstBmpPtr
)
{
    GT_STATUS rc = GT_OK;
    GT_U32    word;
    GT_U32    offset;
    GT_U32    length;
    GT_U32    value[3];

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum,
            CPSS_CH1_E| CPSS_CH1_DIAMOND_E | CPSS_CH2_E | CPSS_CH3_E | CPSS_XCAT_E | CPSS_XCAT3_E |
            CPSS_LION_E | CPSS_XCAT2_E | CPSS_LION2_E);
    PRV_CPSS_DXCH_PP_HW_INFO_E_ARCH_SUPPORTED_CHECK_MAC(devNum);
    PRV_CPSS_DXCH_VLAN_INDEX_CHECK_MAC(devNum, vlanId);
    CPSS_NULL_PTR_CHECK_MAC(mrstBmpPtr);

    for (word = 0; word < 3; word++)
    {
        if (word == 0)
        {
            offset = 2;
            length = 30;
        }
        else if(word == 1)
        {
            offset = 0;
            length = 32;
        }
        else /*word == 2*/
        {
            offset = 0;
            length = 2;
        }
        rc = prvCpssDxChReadTableEntryField (devNum,
                                             PRV_CPSS_DXCH_LION3_TABLE_IPVX_EVLAN_E,
                                             vlanId,
                                             word,
                                             offset,
                                             length,
                                             &value[word]);
    }
    mrstBmpPtr->l[0] = value[0] | (value[1] << 30);
    mrstBmpPtr->l[1] = (value[1] >> 2) | (value[2] << 30);
    return rc;
}

/*******************************************************************************
* cpssDxChIpVlanMrstBitmapGet
*
* DESCRIPTION:
*       Get the next-hop MSRT state bitmap per eVLAN.
*
* APPLICABLE DEVICES:
*       Bobcat2; Caelum; Bobcat3.
*
* NOT APPLICABLE DEVICES:
*       DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat3; xCat2; Lion; Lion2.
*
* INPUTS:
*       devNum - device number
*       vlanId - VLAN ID
*
* OUTPUTS:
*       mrstBmpPtr - pointer to Multicast Routing Shared Tree ID 64 bit bitmap
*
* RETURNS:
*       GT_OK                    - on success
*       GT_FAIL                  - on error
*       GT_BAD_PARAM             - on wrong input parameter
*       GT_BAD_PTR               - on NULL pointer
*       GT_HW_ERROR              - on hardware error
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       None
*
*******************************************************************************/
GT_STATUS cpssDxChIpVlanMrstBitmapGet
(
    IN  GT_U8     devNum,
    IN  GT_U16    vlanId,
    OUT GT_U64    *mrstBmpPtr
)
{
    GT_STATUS rc;
    CPSS_LOG_FUNC_VARIABLE_DECLARE_MAC(funcId, cpssDxChIpVlanMrstBitmapGet);

    CPSS_API_LOCK_MAC(0,0);
    CPSS_LOG_API_ENTER_MAC((funcId, devNum, vlanId, mrstBmpPtr));

    rc = internal_cpssDxChIpVlanMrstBitmapGet(devNum, vlanId, mrstBmpPtr);

    CPSS_LOG_API_EXIT_MAC(funcId, rc);
    CPSS_APP_SPECIFIC_CB_MAC((funcId, rc, devNum, vlanId, mrstBmpPtr));
    CPSS_API_UNLOCK_MAC(0,0);

    return rc;
}

