#include <Copyright.h>

/*******************************************************************************
* gtMisc.c
*
* DESCRIPTION:
*       API definitions for Ip Mapping Table
*                            EEPROM access
*                            Scratch and Misc Control
* DEPENDENCIES:
*
* FILE REVISION NUMBER:
*******************************************************************************/

#include <msApi.h>
#include <gtSem.h>
#include <gtHwCntl.h>
#include <gtDrvSwRegs.h>


/*******************************************************************************
* gsysSetUseIpMappingTable
*
* DESCRIPTION:
*        This API set to use IP Frame Priorities from this table. 
*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frame’s 
*            initial IP_FPRI.
*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
*            frame’s initial IP_FPRI is generated by using the frame’s IP_QPRI
*            as the IP_FPRI’s upper two bits, and the IP_FPRI’s lowest bit comes 
*            from bit 0 of the frame’s source port’s Default PRI (Port offset 0x07).
*
* INPUTS:
*        en    - [GT_TRUE] / [GT_FALSE]
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetUseIpMappingTable
(
    IN  GT_QD_DEV         *dev,
    IN  GT_BOOL            en
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16        data;

    DBG_INFO(("gsysSetUseIpMappingTable Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    data = (en==GT_TRUE)?1:0;

    retVal = hwSetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,14,1,data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}


/*******************************************************************************
* gsysGetUseIpMappingTable
*
* DESCRIPTION:
*        This API get to use IP Frame Priorities from this table. 
*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frame’s 
*            initial IP_FPRI.
*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
*            frame’s initial IP_FPRI is generated by using the frame’s IP_QPRI
*            as the IP_FPRI’s upper two bits, and the IP_FPRI’s lowest bit comes 
*            from bit 0 of the frame’s source port’s Default PRI (Port offset 0x07).
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        en    - [GT_TRUE] / [GT_FALSE]
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetUseIpMappingTable
(
    IN  GT_QD_DEV         *dev,
    IN  GT_BOOL            *en
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16        data;

    DBG_INFO(("gsysGetUseIpMappingTable Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }


    retVal = hwGetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,14,1,&data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    *en= (data==1)?GT_TRUE:GT_FALSE;

    return GT_OK;
}



/*******************************************************************************
* gsysSetIpMappingPrio
*
* DESCRIPTION:
*        Set IPv4 and IPv6 Frame Priority Mapping, and 
*        IPv4 and IPv6 Queue Priority Mapping.
*       The ipFpri value is used as the frame's initial FPRI when the frame is 
*        an IPv4 or an IPv6 frame, and the port’s InitialPri (Port offset 0x04) 
*        is configured to use IP FPri’s.
*       The ipQpri value is used as the frame’s initial QPRI when the frame is 
*        an IPv4 or an IPv6 frame, and the port’s InitialPri and TagIfBoth 
*        registers (Port offset 0x04) are configured to use IP QPri’s.
*
* INPUTS:
*        point - Pointer to the Ip Mapping Table.
*                0 - 0x3f;
*        ipFpri -  The value is 0 - 7
*        ipQpri -  The value is 0 - 3.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetIpMappingPrio
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32             point,
    IN  GT_U8            ipFpri,
    IN  GT_U8            ipQpri
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16        data;

    DBG_INFO(("gsysSetIpMappingPrio Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if ((point>0x3f)||(ipFpri>7)||(ipQpri>3))
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* Wait until the Scratch and Misc control is ready. */
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 1;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = QD_REG_IP_MAPPING_TABLE;
      regAccess.rw_reg_list[0].data = 15;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
      }
    }
#else
       data = 1;
    while(data == 1)
       {
        retVal = hwGetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,15,1,&data);
           if(retVal != GT_OK)
           {
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
           }
    }
#endif

    data = (((ipFpri&7)<<4) | (ipQpri&3));
    data |=  ((GT_U16)((1 << 15) | (point << 8)));

    retVal = hwWriteGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
        gtSemGive(dev,dev->tblRegsSem);
           return retVal;
    }



    gtSemGive(dev,dev->tblRegsSem);

    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}


/*******************************************************************************
* gsysGetIpMappingPrio
*
* DESCRIPTION:
*        Get IPv4 and IPv6 Frame Priority Mapping, and 
*        IPv4 and IPv6 Queue Priority Mapping.
*       The ipFpri value is used as the frame's initial FPRI when the frame is 
*        an IPv4 or an IPv6 frame, and the port’s InitialPri (Port offset 0x04) 
*        is configured to use IP FPri’s.
*        The ipQpri value is used as the frame’s initial QPRI when the frame is 
*        an IPv4 or an IPv6 frame, and the port’s InitialPri and TagIfBoth 
*        registers (Port offset 0x04) are configured to use IP QPri’s.
*
* INPUTS:
*        point - Pointer to the Ip Mapping Table.
*                0 - 0x3f;
*
* OUTPUTS:
*        ipFpri -  The value is 0 - 7
*        ipQpri -  The value is 0 - 3.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None.
*
*******************************************************************************/
GT_STATUS gsysGetIpMappingPrio
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32             point,
    OUT  GT_U8            *ipFpri,
    OUT  GT_U8            *ipQpri
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16        data;
    int count=0x10;

    DBG_INFO(("gsysGetIpMappingPrio Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if (point > 0x3f)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 2;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = QD_REG_IP_MAPPING_TABLE;
      regAccess.rw_reg_list[0].data = 15;
      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
      regAccess.rw_reg_list[1].reg = QD_REG_IP_MAPPING_TABLE;
      regAccess.rw_reg_list[1].data = 0;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
      }
      data = qdLong2Short(regAccess.rw_reg_list[1].data);
    }
#else
    do {
        retVal = hwReadGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, &data);
        if(retVal != GT_OK)
           {
               DBG_INFO(("Failed.\n"));
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
        }
		if((count--)==0) return GT_FAIL;
    } while (data&0x8000);
#endif


    *ipFpri = (data >> 4) & 7;
    *ipQpri = (data) & 3;

    gtSemGive(dev,dev->tblRegsSem);

    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}


/*******************************************************************************
* eepromOperationPerform
*
* DESCRIPTION:
*       This function accesses EEPROM Command Register and Data Register.
*       The device supports the following EEPROM 
*            operations
*            GT_EEPROM_NO_OP = No Operation
*            GT_EEPROM_WRITE_DATA = Write EEPROM at Addr.
*            GT_EEPROM_READ_DATA = Read EEPROM from Addr.
*            GT_EEPROM_RESTART = Restart Register Loader execution at Addr 
*                (eepromData = don’t care in this case)
*            GT_EEPROM_HALT = Halt (stop executing the EEPROM if its not already 
*                stopped)
*
* INPUTS:
*       eepromOp      - EEPROM Opcode.
*       eepromData    - Data to be written to the EEPROM 
*
* OUTPUTS:
*       eepromData    - Data that was read back from the EEPROM. 
*
Command register above.
*
* RETURNS:
*       GT_OK on success,
*       GT_FAIL otherwise.
*       GT_BAD_PARAM - if input parameters are beyond range.
*
* COMMENTS:
*
*******************************************************************************/
static GT_STATUS eepromOperationPerform
(
    IN    GT_QD_DEV             *dev,
    IN    GT_EEPROM_OPERATION    eepromOp,
    INOUT GT_EEPROM_OP_DATA        *opData
)
{
    GT_STATUS       retVal;    /* Functions return value */
    GT_U16          data;     /* temporary Data storage */
    DBG_INFO(("eepromOperationPerform Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if (eepromOp>GT_EEPROM_HALT)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->eepromRegsSem,OS_WAIT_FOREVER);


    /* Wait until the eeprom in ready. */
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 1;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
      regAccess.rw_reg_list[0].data = 15;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
      }
    }
#else
    data = 1;
    while(data == 1)
    {
        retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
        if(retVal != GT_OK)
        {
            gtSemGive(dev,dev->eepromRegsSem);
            return retVal;
        }
    }
#endif

  if (IS_IN_DEV_GROUP(dev,DEV_EEPROM_1))
  {

    /* Set the EEPROM Operation register */
    switch (eepromOp)
    {
        case GT_EEPROM_WRITE_DATA:
            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,10,1,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            if (data==0)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                DBG_INFO(("EEPROM is not writablen"));
                return GT_FAIL;
            }

            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            if (data==1)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                DBG_INFO(("EEPROM Loader is running"));
                return GT_FAIL;
            }

            data = (GT_U16)opData->eepromAddr;
			data &= 0x8fff;
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            data = (GT_U16)((1 << 15) | (GT_EEPROM_WRITE_DATA << 12) | 0x0400 |
                    (opData->eepromData & 0xFF));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            break;

        case GT_EEPROM_READ_DATA:
            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            if (data==1)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                DBG_INFO(("EEPROM Loader is running"));
                return GT_FAIL;
            }

            data = (GT_U16)opData->eepromAddr;
			data &= 0x8fff;
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            data = (GT_U16)((1 << 15) | (GT_EEPROM_READ_DATA << 12));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            
#ifdef GT_RMGMT_ACCESS
            {
              HW_DEV_REG_ACCESS regAccess;

              regAccess.entries = 1;
  
              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
              regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
              regAccess.rw_reg_list[0].data = 15;
              retVal = hwAccessMultiRegs(dev, &regAccess);
              if(retVal != GT_OK)
              {
                gtSemGive(dev,dev->vtuRegsSem);
                return retVal;
              }
            }
#else
            data = 1;
            while(data == 1)
            {
                retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
                if(retVal != GT_OK)
                {
                    gtSemGive(dev,dev->eepromRegsSem);
                    return retVal;
                }
            }
#endif
            
            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,0,8,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            opData->eepromData = (GT_U16)data&0xff;

            break;

        case GT_EEPROM_RESTART:
            data = (GT_U16)opData->eepromAddr;
			data &= 0x8fff;
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            data = (GT_U16)((1 << 15) | (GT_EEPROM_RESTART << 12) );
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }


            break;

        case GT_EEPROM_HALT:
            data = (GT_U16)opData->eepromAddr;
 			data &= 0x8fff;
           retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            data = (GT_U16)((1 << 15) | (GT_EEPROM_HALT << 12));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            break;
        default:
            gtSemGive(dev,dev->eepromRegsSem);
            return GT_FAIL;
    }
  }
  else
  {

    /* Set the EEPROM Operation register */
    switch (eepromOp)
    {
        case GT_EEPROM_WRITE_DATA:
            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,10,1,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            if (data==0)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                DBG_INFO(("EEPROM is not writablen"));
                return GT_FAIL;
            }

            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            if (data==1)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                DBG_INFO(("EEPROM Loader is running"));
                return GT_FAIL;
            }

            data = (GT_U16)opData->eepromData;
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            data = (GT_U16)((1 << 15) | (GT_EEPROM_WRITE_DATA << 12) | 
                    (opData->eepromAddr & 0xFF));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            break;

        case GT_EEPROM_READ_DATA:
            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }
            if (data==1)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                DBG_INFO(("EEPROM Loader is running"));
                return GT_FAIL;
            }

            data = (GT_U16)((1 << 15) | (GT_EEPROM_READ_DATA << 12) | 
                    (opData->eepromAddr & 0xFF));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            
#ifdef GT_RMGMT_ACCESS
            {
              HW_DEV_REG_ACCESS regAccess;

              regAccess.entries = 1;
  
              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
              regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
              regAccess.rw_reg_list[0].data = 15;
              retVal = hwAccessMultiRegs(dev, &regAccess);
              if(retVal != GT_OK)
              {
                gtSemGive(dev,dev->vtuRegsSem);
                return retVal;
              }
            }
#else
            data = 1;
            while(data == 1)
            {
                retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
                if(retVal != GT_OK)
                {
                    gtSemGive(dev,dev->eepromRegsSem);
                    return retVal;
                }
            }
#endif
            

            retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_DATA,&data);
            opData->eepromData = (GT_U16)data;

            break;

        case GT_EEPROM_RESTART:
            data = (GT_U16)((1 << 15) | (GT_EEPROM_RESTART << 12) | 
                    (opData->eepromAddr & 0xFF));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }


            break;

        case GT_EEPROM_HALT:
            data = (GT_U16)((1 << 15) | (GT_EEPROM_HALT << 12) | 
                    (opData->eepromAddr & 0xFF));
            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
            if(retVal != GT_OK)
            {
                gtSemGive(dev,dev->eepromRegsSem);
                return retVal;
            }

            break;
        default:
            gtSemGive(dev,dev->eepromRegsSem);
            return GT_FAIL;
    }
  }
    gtSemGive(dev,dev->eepromRegsSem);
    return GT_OK;
}


/*******************************************************************************
* gsysReadEeprom
*
* DESCRIPTION:
*        Read EEPROM from EEPROM’s address where the EEOp is performed.
*
* INPUTS:
*        addr - EEPROM Address. 
*
* OUTPUTS:
*        data -  Data that was read back from the EEPROM.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysReadEeprom
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U16            addr,
    OUT  GT_U16            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_EEPROM_OPERATION    eepromOp;
    GT_EEPROM_OP_DATA    opData;
    DBG_INFO(("gsysReadEeprom Called.\n"));
 
    eepromOp = GT_EEPROM_READ_DATA;
    opData.eepromAddr = addr;

    retVal = eepromOperationPerform(dev,eepromOp,&opData);
    if(retVal != GT_OK)
    {
      return retVal;
    }
    *data = opData.eepromData;
    return GT_OK;

}

/*******************************************************************************
* gsysWriteEeprom
*
* DESCRIPTION:
*        Write EEPROM at the EEPROM’s address where the EEOp is performed.
*
* INPUTS:
*        addr - EEPROM Address. 
*        data - Data to be written to the EEPROM
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysWriteEeprom
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U16            addr,
    IN  GT_U16            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_EEPROM_OPERATION    eepromOp;
    GT_EEPROM_OP_DATA    opData;
    DBG_INFO(("gsysWriteEeprom Called.\n"));
 
    eepromOp = GT_EEPROM_WRITE_DATA;
    opData.eepromAddr = addr;
    opData.eepromData = data;

    retVal = eepromOperationPerform(dev,eepromOp,&opData);
    if(retVal != GT_OK)
    {
      return retVal;
    }
    return GT_OK;

}


/*******************************************************************************
* gsysRestartEeprom
*
* DESCRIPTION:
*        Restart Register Loader execution at the EEPROM’s address where the EEOp 
*        is performed
*
* INPUTS:
*        addr - EEPROM Address. .
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysRestartEeprom
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            addr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_EEPROM_OPERATION    eepromOp;
    GT_EEPROM_OP_DATA    opData;
    DBG_INFO(("gsysRestartEeprom Called.\n"));
 
    eepromOp = GT_EEPROM_RESTART;
    opData.eepromAddr = addr;

    retVal = eepromOperationPerform(dev,eepromOp,&opData);
    if(retVal != GT_OK)
    {
      return retVal;
    }
    return GT_OK;

}


/*******************************************************************************
* gsysHaltEeprom
*
* DESCRIPTION:
*        Halt (stop executing the EEPROM if its not already stopped)
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysHaltEeprom
(
    IN  GT_QD_DEV         *dev
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_EEPROM_OPERATION    eepromOp;
    GT_EEPROM_OP_DATA    opData;
    DBG_INFO(("gsysHaltEeprom Called.\n"));
 
    eepromOp = GT_EEPROM_HALT;

    retVal = eepromOperationPerform(dev,eepromOp,  &opData);
    if(retVal != GT_OK)
    {
      return retVal;
    }
    return GT_OK;

}


/*******************************************************************************
* gsysGetStEeprom
*
* DESCRIPTION:
*        Get EEPROM status. They are Register Loader Running status and EEPROM 
*        Write Enable status
*        runSt is GT_TRUE: Register Loader Running, whenever the register loader 
*            is busy executing the instructions contained in the EEPROM.
*        writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to 
*            the EEPROM is possible. 
*        writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
*            This reflects the value of the EE_WE configuration pin after Reset.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        runSt   -   [GT_TRUE] / [GT_FALSE)
*        writeEn -   [GT_TRUE] / [GT_FALSE)
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetStEeprom
(
    IN  GT_QD_DEV         *dev,
    OUT GT_BOOL            *writeEn,
    OUT GT_BOOL            *runSt
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16      data;             /* temporary Data storage */
    DBG_INFO(("gsysGetStEeprom Called.\n"));
 
    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_COMMAND, &data);
    if(retVal != GT_OK)
    {
           return retVal;
    }


    *runSt   = (data&GT_EEPROM_OP_ST_RUNNING_MASK)?GT_TRUE:GT_FALSE;
    *writeEn = (data&GT_EEPROM_OP_ST_WRITE_EN_MASK)?GT_TRUE:GT_FALSE;

    return GT_OK;

}


/*******************************************************************************
* gsysSetScratchMiscCtrl
*
* DESCRIPTION:
*        Set Scratch and Misc control data to the Scratch and Misc Control register. 
*        The registers of Scratch and Misc control are.
*                Scratch Byte 0
*                Scratch Byte 1
*                GPIO Configuration
*                Reserved for future use
*                GPIO Direction
*                GPIO Data
*                CONFIG Data 0
*                CONFIG Data 1
*                CONFIG Data 2
*                CONFIG Data 3
*                SyncE & TAICLK125’s Drive
*                P5’s & CLK125’s Clock Drive
*                P6’s Clock Drive
*                EEPROM Pad drive
*
* INPUTS:
*        point - Pointer to the Scratch and Misc. Control register.
*        data  - Scratch and Misc. Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetScratchMiscCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    IN  GT_U16   count, tmpData;
    DBG_INFO(("gsysSetScratchMiscCtrl Called.\n"));

    if (point > GT_SCRAT_MISC_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    if (data &0xffffff00)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* program QoS Weight Table, 4 sequences at a time */

    /* Wait until the Scratch and Misc control is ready. */
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 1;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = QD_REG_SCRATCH_MISC;
      regAccess.rw_reg_list[0].data = 15;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
      }
    }
#else
    count = 5;
    tmpData = 1;
    while(tmpData ==1)
    {
        retVal = hwGetGlobal2RegField(dev,QD_REG_SCRATCH_MISC,15,1,&tmpData);
           if(retVal != GT_OK)
           {
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
           }
	  if(--count==0) break;
    }
#endif

  tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);

  retVal = hwWriteGlobal2Reg(dev, QD_REG_SCRATCH_MISC, tmpData);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     gtSemGive(dev,dev->tblRegsSem);
     return retVal;
  }

  gtSemGive(dev,dev->tblRegsSem);

  return retVal;

}



/*******************************************************************************
* gsysGetScratchMiscCtrl
*
* DESCRIPTION:
*        Get Scratch and Misc control data from the Scratch and Misc Control register. 
*        The register of Scratch and Misc control are.
*                Scratch Byte 0
*                Scratch Byte 1
*                GPIO Configuration
*                Reserved for future use
*                GPIO Direction
*                GPIO Data
*                CONFIG Data 0
*                CONFIG Data 1
*                CONFIG Data 2
*                CONFIG Data 3
*                SyncE & TAICLK125’s Drive
*                P5’s & CLK125’s Clock Drive
*                P6’s Clock Drive
*                EEPROM Pad drive

*
* INPUTS:
*        point - Pointer to the Scratch and Misc. Control register.
*
* OUTPUTS:
*        data - Scratch and Misc. Control data read from the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetScratchMiscCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16       count, tmpData;
    DBG_INFO(("gsysGetScratchMiscCtrl Called.\n"));

    if (point > GT_SCRAT_MISC_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    if (point>0x7f)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* program QoS Weight Table, 4 sequences at a time */

	tmpData =  (GT_U16)((point << 8) | 0);
	retVal = hwWriteGlobal2Reg(dev, QD_REG_SCRATCH_MISC, tmpData);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("Failed.\n"));
	   gtSemGive(dev,dev->tblRegsSem);
	   return retVal;
	}
	
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 2;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = QD_REG_SCRATCH_MISC;
      regAccess.rw_reg_list[0].data = 15;
      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[1].reg = QD_REG_SCRATCH_MISC;
      regAccess.rw_reg_list[1].data = 0;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
     }
     tmpData = qdLong2Short(regAccess.rw_reg_list[1].data);
    }
#else
    count = 5;
    do {
        retVal = hwReadGlobal2Reg(dev, QD_REG_SCRATCH_MISC, &tmpData);
        if(retVal != GT_OK)
           {
               DBG_INFO(("Failed.\n"));
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
        }
		if((count--)==0) return GT_FAIL;
   } while (tmpData&0x8000);
#endif

    *data = tmpData&0xff;

    gtSemGive(dev,dev->tblRegsSem);


    return retVal;
}




/*******************************************************************************
* gsysSetScratchBits
*
* DESCRIPTION:
*        Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
*        These bits are 100% available to software for whatever purpose desired. 
*        These bits do not connect to any hardware function.
*
* INPUTS:
*        scritch - written bits.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetScratchBits
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U16            scratch
)
{
    GT_STATUS    retVal;         /* Functions return value.      */

    DBG_INFO(("gsysSetScratchBits Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_BYTE))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, (GT_U8)(scratch&0xff));
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, (GT_U8)((scratch>>8)&0xff));
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;

}

/*******************************************************************************
* gsysGetScratchBits
*
* DESCRIPTION:
*        Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
*        These bits are 100% available to software for whatever purpose desired. 
*        These bits do not connect to any hardware function.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        scritch - read bits.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetScratchBits
(
    IN  GT_QD_DEV         *dev,
    OUT  GT_U16            *scratch
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetScratchBits Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_BYTE))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    *scratch = data;
    *scratch = *scratch<<8;
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    
    *scratch |= data;

    return GT_OK;

}


/*******************************************************************************
* gsysSetGpioConfigMod
*
* DESCRIPTION:
*        Set bits to the Scratch and Misc Control register <GPIO Configuration>
*        to configure GPIO mode.
*        The bits are shared General Purpose Input Output mode Bits:
*        Bit 15 - GT_GPIO_BIT_14:    1:GPIO[14]    0:P5_OUTCLK
*          ...
*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
*        Now,  bits are read only, except for 0, and 7. 
*
* INPUTS:
*        mode - OR [GT_GPIO_BIT_x]
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetGpioConfigMod
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32            mode
)
{
    GT_STATUS    retVal=GT_OK;         /* Functions return value.      */

    DBG_INFO(("gsysSetGpioConfigMod Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    DBG_INFO(("GpioConfigMod is read only now.\n"));
	return(GT_FAIL);

	/*cqiu changes*/
#if 1 
	if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
	{
	  retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG_1, (GT_U8)(mode&0xff));
	  if(retVal != GT_OK)
	  {
		 DBG_INFO(("Failed.\n"));
		 return retVal;
	  }
	  retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG_2, (GT_U8)((mode>>8)&0x7f));
	  if(retVal != GT_OK)
	  {
		 DBG_INFO(("Failed.\n"));
		 return retVal;
	  }
	}
	else
	{
      retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, (GT_U8)(mode&0x7f));
      if(retVal != GT_OK)
      {
        DBG_INFO(("Failed.\n"));
        return retVal;
      }
	}
#endif

    return retVal;

}


/*******************************************************************************
* gsysGetGpioConfigMod
*
* DESCRIPTION:
*        Get mode from the Scratch and Misc Control register <GPIO Configuration>.
*        The bits are shared General Purpose Input Output mode Bits:
*        Bit 15 - GT_GPIO_BIT_14:    1:GPIO[14]    0:P5_OUTCLK
*          ...
*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
*        Now,  bits are read only, except for 0, and 7. 
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        mode - OR [GT_GPIO_BIT_x]
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetGpioConfigMod
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32            *mode
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetGpioConfigMod Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

	if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
	{
	  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG_2, &data);
	  if(retVal != GT_OK)
	  {
			 DBG_INFO(("Failed.\n"));
			 return retVal;
	  }
	  *mode = data;
	  *mode <<= 8;
	  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG_1, &data);
	  if(retVal != GT_OK)
	  {
			 DBG_INFO(("Failed.\n"));
			 return retVal;
	  }
	  *mode |= data;
	}
	else
	{
      retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, &data);
      if(retVal != GT_OK)
      {
        DBG_INFO(("Failed.\n"));
        return retVal;
      }
	  *mode = 0x7f&data;
	}
    

    return GT_OK;

}

/*******************************************************************************
* gsysSetGpioPinControl
*
* DESCRIPTION:
*        Set GPIO pin control to the Scratch and Misc Control register <GPIO pin control>
*        General Purpose Input Output Interface pin x Control. This control is 
*        used to control alternate functions of the GPIO[x] pin when it is not 
*        being used as part of some other interface. This control has an effect 
*        only if the pin is enabled to be a GPIO pin, i.e., the GPIO[x] Mode bit
*        is a one (Register Index 0x60 of Scratch and Misc., Control). 
*        The options are as follows:
*            GT_GPIO_PIN_GPIO        
*            GT_GPIO_PIN_PTP_TRIG    
*            GT_GPIO_PIN_PTP_EVREQ   
*            GT_GPIO_PIN_PTP_EXTCLK  
*            GT_GPIO_PIN_RX_CLK0     
*            GT_GPIO_PIN_RX_CLK1     
*            GT_GPIO_PIN_SDET        
*            GT_GPIO_PIN_CLK125    
*  
* INPUTS:
*        pinNum  - pin number.
*        pinCtrl - pin control.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetGpioPinControl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            pinNum,
    IN  GT_U8            pinCtrl
)
{
    GT_STATUS    retVal=GT_OK;         /* Functions return value.      */
	GT_U8 data;

    DBG_INFO(("gsysSetGpioPinControl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CTRL_0+(pinNum/2), &data);
    if(retVal != GT_OK)
    {
      DBG_INFO(("Failed.\n"));
      return retVal;
    }
	if (pinNum&1)
	{
       data &= 0x8f;
	   data |= pinCtrl<<4;
	}
    else
	{
       data &= 0xf8;
	   data |= pinCtrl;
	}

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CTRL_0+(pinNum/2), data);
    if(retVal != GT_OK)
    {
      DBG_INFO(("Failed.\n"));
      return retVal;
    }

    return retVal;

}


/*******************************************************************************
* gsysGetGpioPinControl
*
* DESCRIPTION:
*        Get GPIO pin control to the Scratch and Misc Control register <GPIO pin control>.
*        General Purpose Input Output Interface pin x Control. This control is 
*        used to control alternate functions of the GPIO[x] pin when it is not 
*        being used as part of some other interface. This control has an effect 
*        only if the pin is enabled to be a GPIO pin, i.e., the GPIO[x] Mode bit
*        is a one (Register Index 0x60 of Scratch and Misc., Control). 
*        The options are as follows:
*            GT_GPIO_PIN_GPIO        
*            GT_GPIO_PIN_PTP_TRIG    
*            GT_GPIO_PIN_PTP_EVREQ   
*            GT_GPIO_PIN_PTP_EXTCLK  
*            GT_GPIO_PIN_RX_CLK0     
*            GT_GPIO_PIN_RX_CLK1     
*            GT_GPIO_PIN_SDET        
*            GT_GPIO_PIN_CLK125    
*  
* INPUTS:
*        pinNum  - pin number.
*
* OUTPUTS:
*        pinCtrl - pin control.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetGpioPinControl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            pinNum,
    OUT GT_U8            *pinCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetGpioPinControl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CTRL_0+(pinNum/2), &data);
    if(retVal != GT_OK)
    {
      DBG_INFO(("Failed.\n"));
      return retVal;
    }
	if (pinNum&1)
	{
       *pinCtrl = (data >> 4)&0x7;
	}
    else
	{
       *pinCtrl = data&0x7;
	}

    return GT_OK;

}


/*******************************************************************************
* gsysSetGpioDirection
*
* DESCRIPTION:
*        Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
*        The bits are used to control the direction of GPIO[6:0] or GPIO{14:0]. 
*        When a GPIO’s bit is set to a one that GPIO will become an input. When a
*        GPIO’s bit is cleared to a zero that GPIO will become an output
*        General Purpose Input Output direction bits are:
*        Bit 15 - GT_GPIO_BIT_14
*          ...
*        Bit 6 - GT_GPIO_BIT_6
*          ...
*        Bit 1 - GT_GPIO_BIT_1
*        Bit 0 - GT_GPIO_BIT_0
*
* INPUTS:
*        dir - OR [GT_GPIO_BIT_x]
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetGpioDirection
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32            dir
)
{
  GT_STATUS    retVal;         /* Functions return value.      */

  DBG_INFO(("gsysSetGpioDirection Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
  {
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR_1, (GT_U8)(dir&0xff));
    if(retVal != GT_OK)
    {
       DBG_INFO(("Failed.\n"));
       return retVal;
	}
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR_2, (GT_U8)((dir>>8)&0x7f));
    if(retVal != GT_OK)
    {
       DBG_INFO(("Failed.\n"));
       return retVal;
	}
  }
  else
  {
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, (GT_U8)(dir&0x7f));
    if(retVal != GT_OK)
    {
       DBG_INFO(("Failed.\n"));
       return retVal;
	}
  }


  return GT_OK;

}


/*******************************************************************************
* gsysGetGpioDirection
*
* DESCRIPTION:
*        Get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
*        The bits are used to control the direction of GPIO[6:0] or GPIO{14:0]. 
*        When a GPIO’s bit is set to a one that GPIO will become an input. When a
*        GPIO’s bit is cleared to a zero that GPIO will become an output
*        General Purpose Input Output direction bits are:
*        Bit 15 - GT_GPIO_BIT_14
*          ...
*        Bit 6 - GT_GPIO_BIT_6
*          ...
*        Bit 1 - GT_GPIO_BIT_1
*        Bit 0 - GT_GPIO_BIT_0
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        dir - OR [GT_GPIO_BIT_x]
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetGpioDirection
(
    IN  GT_QD_DEV         *dev,
    OUT  GT_U32            *dir
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8        data;

  DBG_INFO(("gsysGetGpioDirection Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
  {
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR_2, &data);
    if(retVal != GT_OK)
    {
           DBG_INFO(("Failed.\n"));
           return retVal;
	}
	*dir = data;
	*dir <<= 8;
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR_1, &data);
    if(retVal != GT_OK)
    {
           DBG_INFO(("Failed.\n"));
           return retVal;
	}
	*dir |= data;
  }
  else
  {
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, &data);
    if(retVal != GT_OK)
    {
           DBG_INFO(("Failed.\n"));
           return retVal;
	}
    *dir = data;
  }

  return GT_OK;

}

/*******************************************************************************
* gsysSetGpioSMI
*
* DESCRIPTION:
*        Set Normal SMI to the Scratch and Misc Control register <GPIO Direction>.
*        The bit is used to control the  Normal SMI vs. GPIO mode. 
*        When P5_MODE is not equal to 0x1 or 0x2 the P5_COL and P5_CRS pins are 
*        not needed. In this case, when this bit is set to a one, the P5_COL and 
*        P5_CRS pins become MDIO_PHY and MDC_PHY, respectively, if the NO_CPU 
*        configuration pin was a one during reset. Else the pins become GPIO pins 7 and 8.
*
* INPUTS:
*        smi - SMI OR GT_GPIO
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetGpioSMI
(
    IN  GT_QD_DEV         *dev,
    IN  GT_BOOL           smi
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;
	GT_U8		 point;

    DBG_INFO(("gsysSetGpioSMI Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_SMI_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

	if (IS_IN_DEV_GROUP(dev,DEV_88E6390_FAMILY))
		point = 0x02;
	else
		point = GT_SCRAT_MISC_REG_GPIO_DIR_2;
    retVal = gsysGetScratchMiscCtrl(dev, point, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	if (smi==GT_FALSE)
	  data |= 0x80;
	else
	  data &= ~0x80;

    retVal = gsysSetScratchMiscCtrl(dev, point, (GT_U8)(data&0xff));
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }


    return GT_OK;

}


/*******************************************************************************
* gsysGetGpioSMI
*
* DESCRIPTION:
*        Get Normal SMI from the Scratch and Misc Control register <GPIO Direction>.
*        The bit is used to control the  Normal SMI vs. GPIO mode. 
*        When P5_MODE is not equal to 0x1 or 0x2 the P5_COL and P5_CRS pins are 
*        not needed. In this case, when this bit is set to a one, the P5_COL and 
*        P5_CRS pins become MDIO_PHY and MDC_PHY, respectively, if the NO_CPU 
*        configuration pin was a one during reset. Else the pins become GPIO pins 7 and 8.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        smi - SMI OR GT_GPIO
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetGpioSMI
(
    IN  GT_QD_DEV         *dev,
    OUT GT_BOOL           *smi
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;
	GT_U8		 point;

    DBG_INFO(("gsysGetGpioSMI Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_SMI_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

	if (IS_IN_DEV_GROUP(dev,DEV_88E6390_FAMILY))
		point = 0x02;
	else
		point = GT_SCRAT_MISC_REG_GPIO_DIR_2;

    retVal = gsysGetScratchMiscCtrl(dev, point, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

	if (data & 0x80)
      *smi=GT_FALSE;
	else
      *smi=GT_TRUE;

    return GT_OK;

}


/*******************************************************************************
* gsysSetGpioData
*
* DESCRIPTION:
*        Set Gpio data to the Scratch and Misc Control register <GPIO data>.
*        When a GPIO’s bit is set to be an input, data written to this bit will go 
*        to a holding register but will not appear on the pin nor in this register. 
*        Reads of this register will return the actual, real-time, data that is 
*        appearing on the GPIO’s pin.
*        When a GPIO’s bit is set to be an output, data written to this bit will go 
*        to a holding register and will appear on the GPIO’s pin. Reads of this register 
*        will return the actual, real-time, data that is appearing on the GPIO’s pin 
*        (which in this case should be the data written, but if its isn’t that would 
*        be an indication of a conflict).
*        When a pin’s direction changes from input to output, the data last written 
*        to the holding register appears on the GPIO’s pin
*        General Purpose Input Output data bits are:
*        Bit 15 - GT_GPIO_BIT_14
*          ...
*        Bit 6 - GT_GPIO_BIT_6
*          ...
*        Bit 5 - GT_GPIO_BIT_5
*        Bit 4 - GT_GPIO_BIT_4
*        Bit 3 - GT_GPIO_BIT_3
*        Bit 2 - GT_GPIO_BIT_2
*        Bit 1 - GT_GPIO_BIT_1
*        Bit 0 - GT_GPIO_BIT_0
*
* INPUTS:
*        data - OR [GT_GPIO_BIT_x]
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetGpioData
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32            data
)
{
  GT_STATUS    retVal;         /* Functions return value.      */

  DBG_INFO(("gsysSetGpioData Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
  {
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT_1, (GT_U8)(data&0xff));
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT_2, (GT_U8)((data>>8)&0x7f));
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
  }
  else
  {
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, (GT_U8)(data&0x7f));
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
  }


  return GT_OK;

}

/*******************************************************************************
* gsysGetGpioData
*
* DESCRIPTION:
*        get Gpio data to the Scratch and Misc Control register <GPIO data>.
*        When a GPIO’s bit is set to be an input, data written to this bit will go 
*        to a holding register but will not appear on the pin nor in this register. 
*        Reads of this register will return the actual, real-time, data that is 
*        appearing on the GPIO’s pin.
*        When a GPIO’s bit is set to be an output, data written to this bit will go 
*        to a holding register and will appear on the GPIO’s pin. Reads of this register 
*        will return the actual, real-time, data that is appearing on the GPIO’s pin 
*        (which in this case should be the data written, but if its isn’t that would 
*        be an indication of a conflict).
*        When a pin’s direction changes from input to output, the data last written 
*        to the holding register appears on the GPIO’s pin
*        General Purpose Input Output data bits are:
*        Bit 15 - GT_GPIO_BIT_14
*          ...
*        Bit 6 - GT_GPIO_BIT_6
*          ...
*        Bit 5 - GT_GPIO_BIT_5
*        Bit 4 - GT_GPIO_BIT_4
*        Bit 3 - GT_GPIO_BIT_3
*        Bit 2 - GT_GPIO_BIT_2
*        Bit 1 - GT_GPIO_BIT_1
*        Bit 0 - GT_GPIO_BIT_0
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        data - OR [GT_GPIO_BIT_x]
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetGpioData
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U32            *data
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8        tmpData;

  DBG_INFO(("gsysGetGpioData Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_CTRL_1))
  {
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT_2, &tmpData);
    if(retVal != GT_OK)
    {
      DBG_INFO(("Failed.\n"));
      return retVal;
    }
    *data = tmpData;
	*data <<= 8;
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT_1, &tmpData);
    if(retVal != GT_OK)
    {
      DBG_INFO(("Failed.\n"));
      return retVal;
    }
    *data |= tmpData;

  }
  else
  {
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, &tmpData);
    if(retVal != GT_OK)
    {
      DBG_INFO(("Failed.\n"));
      return retVal;
    }
    *data = tmpData;
  }

    return GT_OK;

}


/*******************************************************************************
* gsysGetConfigData
*
* DESCRIPTION:
*        Get Reset Configuration Pin Data 0-3. 
*        These registers return the values observed after a hardware Reset on the 
*        listed CONFIG data listed below.
*            Config data 0:
*              Bit    Config    Pin's Primary Name
*                0    USER[0]        P6_OUTD[5]
*                1    USER[1]        P6_OUTD[6]
*                2    USER[2]        P6_OUTD[7]
*                3    ADDR[0]        P5_OUTD[0]
*                4    ADDR[1]        P5_OUTD[5]
*                5    ADDR[2]        P5_OUTD[6]
*                6    ADDR]3]        P5_OUTD[7]
*                7    ADDR[4]        P5_OUTD[1]
*            Config data 1:
*                0    LED_SEL[0]    P1_LED
*                1    LED_SEL[1]    P2_LED
*                2    4COL P3_LED
*                3    NormCx        P4_LED
*                4    Jumbo        P0_LED
*                5    EE_WE        EE_CS/C2_LED
*                6    FD_FLOW        EE_CLK/C1_LED
*                7    HD_FLOW        EE_DIN/C0_LED
*            Config data 2:
*                0    P5_MODE[0]    P5_OUTD[2]
*                1    P5_MODE[1]    P5_OUTD[3]
*                2    P5_MODE[2]    P5_OUTD[4]
*                3    Reserved for future use
*                4    P6_MODE[0]    P6_OUTD[2]
*                5    P6_MODE[1]    P6_OUTD[3]
*                6    P6_MODE[2]    P6_OUTD[4]
*                7    Reserved for future use
*            Config data 3:
*                0    RMU_MODE[0] P6_OUTD[0]
*                1    RMU_MODE[1] P6_OUTD[1]
*                2    S_VDDOS[0]    PTP_TRIG 
*                3    CLK125EN    CLK125
*                4    P5_VDDOS[0] P5_GTXCLK
*                5    P5_VDDOS[1] P5_OUTEN
*                6    P6_VDDOS[0] P5_GTXCLK
*                7    P6_VDDOS[1] P6_OUTEN
* INPUTS:
*        None.
*
* OUTPUTS:
*       cfgDat - GT_CONFIG_DTTA
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetConfigData
(
    IN  GT_QD_DEV             *dev,
    OUT  GT_CONFIG_DATA        *cfgData
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        tmpData;

    DBG_INFO(("gsysGetConfigData Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ_PAD_DRV))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT0, &tmpData);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    cfgData->cfgData0.Byte = tmpData;

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT1, &tmpData);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    cfgData->cfgData1.Byte = tmpData;

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT2, &tmpData);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    cfgData->cfgData2.Byte = tmpData;

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT3, &tmpData);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    cfgData->cfgData3.Byte = tmpData;

    return GT_OK;

}



/*******************************************************************************
* gsysSetSyncETai
*
* DESCRIPTION:
*        Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
*
* INPUTS:
*        zpr - ZPR for SyncE and TAI
*        znr - ZNR for SyncE and TAI
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetSyncETai
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            zpr,
    IN  GT_U8            znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysSetSyncETai Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if ((zpr>0x7) || (znr>0x7))
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    data = ((zpr&0x7)<<3) | (znr&0x7);

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;

}



/*******************************************************************************
* gsysGetSyncETai
*
* DESCRIPTION:
*        Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        zpr - ZPR for SyncE and TAI
*        znr - ZNR for SyncE and TAI*
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetSyncETai
(
    IN  GT_QD_DEV         *dev,
    OUT  GT_U8            *zpr,
    OUT  GT_U8            *znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetSyncETai Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    
    *zpr = 0x7 &(data>>3);
    *znr = 0x7 &(data);

    return GT_OK;

}


/*******************************************************************************
* gsysSetP6_Clock
*
* DESCRIPTION:
*        Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
*
* INPUTS:
*        zpr - ZPR for P6_Clock
*        znr - ZNR for P6_Clock
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetP6_Clock
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            zpr,
    IN  GT_U8            znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysSetP6_Clock Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if ((zpr>0x7) || (znr>0x7))
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    data = ((zpr&0x7)<<3) | (znr&0x7);

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;

}

/*******************************************************************************
* gsysGetP6_Clock
*
* DESCRIPTION:
*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        zpr - ZPR for P6_Clock
*        znr - ZNR for P6_Clock
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetP6_Clock
(
    IN  GT_QD_DEV         *dev,
    OUT  GT_U8            *zpr,
    OUT  GT_U8            *znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetP6_Clock Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    
    *zpr = 0x7 &(data>>3);
    *znr = 0x7 &(data);

    return GT_OK;

}




/*******************************************************************************
* gsysSetP5_Clock
*
* DESCRIPTION:
*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
*
* INPUTS:
*        zpr - ZPR for P5_Clock
*        znr - ZNR for P5_Clock
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetP5_Clock
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            zpr,
    IN  GT_U8            znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysSetP5_Clock Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if ((zpr>0x7) || (znr>0x7))
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    data = ((zpr&0x7)<<3) | (znr&0x7);

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;

}

/*******************************************************************************
* gsysGetP5_Clock
*
* DESCRIPTION:
*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        zpr - ZPR for P5_Clock
*        znr - ZNR for P5_Clock
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetP5_Clock
(
    IN  GT_QD_DEV         *dev,
    OUT  GT_U8            *zpr,
    OUT  GT_U8            *znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetP6_Clock Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    
    *zpr = 0x7 &(data>>3);
    *znr = 0x7 &(data);

    return GT_OK;

}


/*******************************************************************************
* gsysSetEEPROM
*
* DESCRIPTION:
*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
*
* INPUTS:
*        dsm - DSM for EEPROM cycle
*        zpr - ZPR for EEPROM cycle
*        znr - ZNR for EEPROM cycle
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetEEPROM
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            dsm,
    IN  GT_U8            zpr,
    IN  GT_U8            znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysSetEEPROM Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    if ((zpr>0x7) || (znr>0x7))
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    data = ((dsm&0x3)<<6) | ((zpr&0x7)<<3) | (znr&0x7);

    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;

}

/*******************************************************************************
* gsysGetEEPROM
*
* DESCRIPTION:
*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        dsm - DSM for EEPROM cycle
*        zpr - ZPR for EEPROM cycle
*        znr - ZNR for EEPROM cycle
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetEEPROM
(
    IN  GT_QD_DEV         *dev,
    OUT  GT_U8            *dsm,
    OUT  GT_U8            *zpr,
    OUT  GT_U8            *znr
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U8        data;

    DBG_INFO(("gsysGetEEPROM Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_CFG_READ))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    
    *dsm = 0x3 &(data>>6);
    *zpr = 0x7 &(data>>3);
    *znr = 0x7 &(data);

    return GT_OK;

}


/*******************************************************************************
* gsysSetGpioxPortStallVect
*
* DESCRIPTION:
*     Set GPIO X’s Port Stall Vector. The value in this register is sent to the transmit
*     portion of all the ports in the device when GPIO X’s Port Stall En (below) is set
*     to a one and the value on the device’s GPIO pin matches the value in GPIO
*     X’s Port Stall Value (below) and the GPIO pin is a GPIO input. The assertion
*     of this vector to the ports persists as long as the function is enabled (i.e., GPIO
*     X Port Stall En equals a one) and as long as the value on the pin matches the
*     programmed stall value (GPIO X Port Stall Value) and as long as the pin
*     remains a GPIO input.
*     When a port’s bit is set to a one in this vector, that port or ports will stop
*     tranmitting their next frame (the current frame is not affected) until this vector
*     is deasserted. Port 0 is controlled by bit 0, port 1 by bit 1, etc.
*
* INPUTS:
*        gpioNum - GPIO number.
*        portStallVec - GPIO Num’s Port Stall Vector.
*        portStallEn - GPIO Num’s Port Stall Enable.
*        portStallValue - GPIO Num’s Port Stall Value.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetGpioxPortStallVect
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            gpioNum,
    IN  GT_U8            portStallVec,
    IN  GT_U8            portStallEn,
    IN  GT_U8            portStallValue
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8  data;

  DBG_INFO(("gsysSetGpioxPortStallVect Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_GPIO_PORT_STALL_VECT))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  data = portStallVec&0x7f;
  retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO0_STALL_VEC0+gpioNum*2, data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  data = (portStallEn&0x1);
  data = data<<1;
  data = data | (portStallValue&1);
  data<<=5;
  retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO0_STALL_VEC1+gpioNum*2, data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
 
  return GT_OK;

}

/*******************************************************************************
* gsysGetGpioxPortStallVect
*
* DESCRIPTION:
*     Get GPIO X’s Port Stall Vector. The value in this register is sent to the transmit
*     portion of all the ports in the device when GPIO X’s Port Stall En (below) is set
*     to a one and the value on the device’s GPIO pin matches the value in GPIO
*     X’s Port Stall Value (below) and the GPIO pin is a GPIO input. The assertion
*     of this vector to the ports persists as long as the function is enabled (i.e., GPIO
*     X Port Stall En equals a one) and as long as the value on the pin matches the
*     programmed stall value (GPIO X Port Stall Value) and as long as the pin
*     remains a GPIO input.
*     When a port’s bit is set to a one in this vector, that port or ports will stop
*     tranmitting their next frame (the current frame is not affected) until this vector
*     is deasserted. Port 0 is controlled by bit 0, port 1 by bit 1, etc.
*
* INPUTS:
*        gpioNum - GPIO number.
*
* OUTPUTS:
*        portStallVec - GPIO Num’s Port Stall Vector.
*        portStallEn - GPIO Num’s Port Stall Enable.
*        portStallValue - GPIO Num’s Port Stall Value.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetGpioxPortStallVect
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            gpioNum,
    OUT  GT_U8           *portStallVec,
    OUT  GT_U8           *portStallEn,
    OUT  GT_U8           *portStallValue
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8  data;

  DBG_INFO(("gsysGetGpioxPortStallVect Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev, DEV_SCRATCH_GPIO_PORT_STALL_VECT))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO0_STALL_VEC0+gpioNum*2, &data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  *portStallVec = data&0x7f;
  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO0_STALL_VEC1+gpioNum*2, &data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  *portStallEn = (data >> 6)&1;
  *portStallValue = (data >> 5)&1;

  return GT_OK;

}


/*******************************************************************************
* gsysClearxEEERxStatusCounter
*
* DESCRIPTION:
*     Clear Receive Low Power Idle Count. The counter tracks number of low
*     power idle command that Port 0 received. This counter will wrap.
*
* INPUTS:
*        port - port number.
*
* OUTPUTS:
*        None
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysClearxEEERxStatusCounter
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            port,
    OUT  GT_U8           *eeeStCount
)
{
  GT_STATUS    retVal;         /* Functions return value.      */

  DBG_INFO(("gsysClearxEEERxStatusCounter Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev, DEV_SCRATCH_EEE_RECV_ST_COUNTER))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_STAT_RX_CNT_P0+port, 0);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }

  if(eeeStCount != NULL)
      *eeeStCount = 0; 

  return GT_OK;

}

/*******************************************************************************
* gsysGetxEEERxStatusCounter
*
* DESCRIPTION:
*     Get Receive Low Power Idle Count. The counter tracks number of low
*     power idle command that Port 0 received. This counter will wrap.
*
* INPUTS:
*        port - port number.
*
* OUTPUTS:
*        eeeStCount - EEE receive status counter.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetxEEERxStatusCounter
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            port,
    OUT  GT_U8           *eeeStCount
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8  data;

  DBG_INFO(("gsysGetxEEERxStatusCounter Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev, DEV_SCRATCH_EEE_RECV_ST_COUNTER))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_STAT_RX_CNT_P0+port, &data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  *eeeStCount = data&0xff;

  return GT_OK;

}

/*******************************************************************************
* gsysGetxEEETrStatusCounter
*
* DESCRIPTION:
*     Get Transmit Low Power Idle Count. The counter tracks number of low
*     power idle command that Port 0 initiated. This counter will wrap.
*
* INPUTS:
*        port - port number.
*
* OUTPUTS:
*        eeeStCount - EEE Transmit status counter.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetxEEETrStatusCounter
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            port,
    OUT  GT_U8           *eeeStCount
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8  data;

  DBG_INFO(("gsysGetxEEETrStatusCounter Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev, DEV_SCRATCH_EEE_TRSM_ST_COUNTER))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_STAT_TX_CNT_P0+port, &data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  *eeeStCount = data&0xff;

  return GT_OK;

}

/*******************************************************************************
* gsysClearxEEETrStatusCounter
*
* DESCRIPTION:
*     Clear Transmit Low Power Idle Count. The counter tracks number of low
*     power idle command that Port 0 initiated. This counter will wrap.
*
* INPUTS:
*        port - port number.
*
* OUTPUTS:
*        None
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysClearxEEETrStatusCounter
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            port
)
{
  GT_STATUS    retVal;         /* Functions return value.      */

  DBG_INFO(("gsysClearxEEETrStatusCounter Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev, DEV_SCRATCH_EEE_TRSM_ST_COUNTER))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_STAT_TX_CNT_P0+port, 0);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  return GT_OK;

}

/*******************************************************************************
* gsysGetxEEERxStates
*
* DESCRIPTION:
*     Get all Ports Receive Low Power Idle State. This bit indicates the receiving
*     port is in the state of low power idle mode.
*
* INPUTS:
*        port - port number.
*
* OUTPUTS:
*        eeeStR - EEE receive state.
*        eeeStT - EEE Transmitr state.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetxEEERxStates
(
    IN  GT_QD_DEV        *dev,
    IN  GT_U8            port,
    OUT  GT_U8           *eeeStR,
    OUT  GT_U8           *eeeStT
)
{
  GT_STATUS    retVal;         /* Functions return value.      */
  GT_U8  data;

  DBG_INFO(("gsysGetxEEERxStates Called.\n"));

  /* Check if Switch supports this feature. */
  if (!IS_IN_DEV_GROUP(dev, DEV_SCRATCH_EEE_ST_REG))
  {
    DBG_INFO(("GT_NOT_SUPPORTED\n"));
    return GT_NOT_SUPPORTED;
  }

  retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_STAT_LPI_P0_P3+(port/3), &data);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     return retVal;
  }
  *eeeStR = (data>>((port%3)*2))&0x1;
  *eeeStT = (data>>((port%3)*2+1))&0x1;

  return GT_OK;

}


/*******************************************************************************
* gsysSetPowerCtrl
*
* DESCRIPTION:
*        Set Power Management Control. These bits are used to control the power
*        management of the switch core (this works in conjunction with the EEE
*        features of this device). When these bits are zero, core power
*        management is disabled (EEE can still be used in this mode to save PHY
*        power).
*        When these bits are non zero, core power management is enabled and
*        will take effect ‘n’ core clocks or ‘n’ uSec or ‘n’ mSec (where ‘n’ = the
*        value of this register and the selection of the rate is controlled by the
*        PwrRate bits in index 0x0B) after all of the following have occurred:
*        o All Tx Queues on all ports are empty.
*        o All MAC’s Tx and Rx paths are idle.
*        o The MDC/MDIO bus is idle and all pending write data has been  written.
*        o All blocks with I/O Busy bits (ATU, VTU, etc.) need to idle (i.e., not  busy).
*        The RMU is idle
*
* INPUTS:
*        pwCtrl - Power Management Control
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetPowerCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8           pwCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetPowerCtrl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    data = pwCtrl;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MANAGEMENT, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }


    return GT_OK;

}

/*******************************************************************************
* gsysGetPowerCtrl
*
* DESCRIPTION:
*        Get Power Management Control. These bits are used to control the power
*        management of the switch core (this works in conjunction with the EEE
*        features of this device). When these bits are zero, core power
*        management is disabled (EEE can still be used in this mode to save PHY
*        power).
*        When these bits are non zero, core power management is enabled and
*        will take effect ‘n’ core clocks or ‘n’ uSec or ‘n’ mSec (where ‘n’ = the
*        value of this register and the selection of the rate is controlled by the
*        PwrRate bits in index 0x0B) after all of the following have occurred:
*        o All Tx Queues on all ports are empty.
*        o All MAC’s Tx and Rx paths are idle.
*        o The MDC/MDIO bus is idle and all pending write data has been  written.
*        o All blocks with I/O Busy bits (ATU, VTU, etc.) need to idle (i.e., not  busy).
*        The RMU is idle
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        pwCtrl - Power Management Control
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetPowerCtrl
(
    IN  GT_QD_DEV         *dev,
    OUT GT_U8           *pwCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetPowerCtrl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MANAGEMENT, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    *pwCtrl= data;


    return GT_OK;

}

/*******************************************************************************
* gsysSetWakeTimeGE
*
* DESCRIPTION:
*        Set EEE Wake Time for Gigabit Ethernet ports. In order for PHY to exit low power
*        mode and return back to normal mode, a wake up period is needed. These
*        bits determine the time that switch must wait for the PHY to completely exit
*        low power mode before the switch can start to transmit a packet. The value in
*        this register is in micro seconds (uSec), mille seconds (mSec) or seconds as
*        determined by WakeRate in Index 0x0B above. The default value of 0x11 is
*        17uSec. This register supports the full range of 0us to 255us
*
* INPUTS:
*        wakeTime - EEE Wake Time
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetWakeTimeGE
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8           wakeTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetWakeTimeGE Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    data = wakeTime;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_WAKE_TIME_GE, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }


    return GT_OK;

}

/*******************************************************************************
* gsysGetWakeTimeGE
*
* DESCRIPTION:
*        Get EEE Wake Time for Gigabit Ethernet ports. In order for PHY to exit low power
*        mode and return back to normal mode, a wake up period is needed. These
*        bits determine the time that switch must wait for the PHY to completely exit
*        low power mode before the switch can start to transmit a packet. The value in
*        this register is in micro seconds (uSec), mille seconds (mSec) or seconds as
*        determined by WakeRate in Index 0x0B above. The default value of 0x11 is
*        17uSec. This register supports the full range of 0us to 255us
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        wakeTime - EEE Wake Time
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetWakeTimeGE
(
    IN  GT_QD_DEV         *dev,
    OUT GT_U8           *wakeTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetWakeTimeGE Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_WAKE_TIME_GE, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    *wakeTime = data;

    return GT_OK;

}

/*******************************************************************************
* gsysSetAsrtTime
*
* DESCRIPTION:
*        Set EEE Assertion Time. When the PHY is asked to enter low power mode it
*        cannot immediately leave this mode. This timer determines the time
*        requirement for the PHY to fully power down before a wake up request can be
*        processed. The value in this register is in micro seconds (uSec), mille
*        seconds (mSec) or seconds as determined by AsrtRate in Index 0x0B above.
*        An AsrtTime of 0x0 has the low power idle code deasserted immediately when
*        an idle request is deasserted.
*
* INPUTS:
*        asrtTime - EEE Assertion Time
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetAsrtTime
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8           asrtTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetAsrtTime Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    data = asrtTime;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_ASERT_TIME, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }


    return GT_OK;

}

/*******************************************************************************
* gsysGetAsrtTime
*
* DESCRIPTION:
*        Get EEE Assertion Time. When the PHY is asked to enter low power mode it
*        cannot immediately leave this mode. This timer determines the time
*        requirement for the PHY to fully power down before a wake up request can be
*        processed. The value in this register is in micro seconds (uSec), mille
*        seconds (mSec) or seconds as determined by AsrtRate in Index 0x0B above.
*        An AsrtTime of 0x0 has the low power idle code deasserted immediately when
*        an idle request is deasserted.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        asrtTime - EEE Assertion Time
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetAsrtTime
(
    IN  GT_QD_DEV         *dev,
    OUT GT_U8           *asrtTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetAsrtTime Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_ASERT_TIME, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    *asrtTime =data;


    return GT_OK;

}

/*******************************************************************************
* gsysSetWakeTimeFE
*
* DESCRIPTION:
*        Set EEE Wake Time for Fast Ethernet ports. In order for PHY to exit low power
*        mode and return back to normal mode, a wake up period is needed. These
*        bits determine the time that switch must wait for the PHY to completely exit
*        low power mode before the switch can start to transmit a packet. The value in
*        this register is in micro seconds (uSec), mille seconds (mSec) or seconds as
*        determined by WakeRate in Index 0x0B above. The default value of 0x11 is
*        17uSec. This register supports the full range of 0us to 255us
*
* INPUTS:
*        wakeTime - EEE Wake Time
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetWakeTimeFE
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8           wakeTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetWakeTimeFE Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    data = wakeTime;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_WAKE_TIME_FE, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }


    return GT_OK;

}

/*******************************************************************************
* gsysGetWakeTimeFE
*
* DESCRIPTION:
*        Get EEE Wake Time for Fast Ethernet ports. In order for PHY to exit low power
*        mode and return back to normal mode, a wake up period is needed. These
*        bits determine the time that switch must wait for the PHY to completely exit
*        low power mode before the switch can start to transmit a packet. The value in
*        this register is in micro seconds (uSec), mille seconds (mSec) or seconds as
*        determined by WakeRate in Index 0x0B above. The default value of 0x11 is
*        17uSec. This register supports the full range of 0us to 255us
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        wakeTime - EEE Wake Time
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetWakeTimeFE
(
    IN  GT_QD_DEV         *dev,
    OUT GT_U8           *wakeTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetWakeTimeFE Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_WAKE_TIME_FE, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    *wakeTime = data;

    return GT_OK;

}

/*******************************************************************************
* gsysSetTxIdleTime
*
* DESCRIPTION:
*        Set EEE Transmit Idle Time. These bits determine the time that each TX port
*        must remain idle before telling the PHY to entering its low power state. The
*        value in this register is in micro seconds (uSec), mille seconds (mSec) or
*        seconds as determined by TxIdleRate in Index 0x0B above. If the Transmit
*        Idle Time is set to 0x0 then automatic low power mode is entered as soon as
*        the port’s egress queue is empty and has nothing more to send. 0x0 is a
*        special test case that will cause EEE power saving mode to be entered
*        right away when port’s EEE mode is enabled.
*
* INPUTS:
*        idleTime - EEE Transmit Idle Time
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetTxIdleTime
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8           idleTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetTxIdleTime Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    data = idleTime;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_TR_IDLE_TIME, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }


    return GT_OK;

}

/*******************************************************************************
* gsysGetTxIdleTime
*
* DESCRIPTION:
*        Get EEE Transmit Idle Time. These bits determine the time that each TX port
*        must remain idle before telling the PHY to entering its low power state. The
*        value in this register is in micro seconds (uSec), mille seconds (mSec) or
*        seconds as determined by TxIdleRate in Index 0x0B above. If the Transmit
*        Idle Time is set to 0x0 then automatic low power mode is entered as soon as
*        the port’s egress queue is empty and has nothing more to send. 0x0 is a
*        special test case that will cause EEE power saving mode to be entered
*        right away when port’s EEE mode is enabled.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        idleTime - EEE Transmit Idle Time
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetTxIdleTime
(
    IN  GT_QD_DEV         *dev,
    OUT GT_U8           *idleTime
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetTxIdleTime Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_TR_IDLE_TIME, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    *idleTime = data;


    return GT_OK;

}


/*******************************************************************************
* gsysSetEEETimeRate
*
* DESCRIPTION:
*    Set EEE Timer rate:
*                PowerCtrl Timer. 
*                Assertion Timer Rate. 
*                Wake Timer Rate.
*                TxIdle Timer Rate.
*
* INPUTS:
*        eeeTimeRate - EEE  Time rate.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetEEETimeRate
(
    IN  GT_QD_DEV         *dev,
    IN  GT_EEE_TIME_RATE  *eeeTimeRate
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetEEETimeRate Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    data = eeeTimeRate->pwrRate;
	data <<=2;
	data |= eeeTimeRate->asrtRate;
	data <<=2;
	data |= eeeTimeRate->wakeRate ;
	data <<=2;
	data |= eeeTimeRate->txIdleRate;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_TIMER_RATE, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}

/*******************************************************************************
* gsysGetEEETimeRate
*
* DESCRIPTION:
*    Set EEE Timer rate:
*                PowerCtrl Timer. 
*                Assertion Timer Rate. 
*                Wake Timer Rate.
*                TxIdle Timer Rate.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        eeeTimeRate - EEE  Time rate.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetEEETimeRate
(
    IN  GT_QD_DEV         *dev,
    OUT GT_EEE_TIME_RATE  *eeeTimeRate
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetEEETimeRate Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEE_TIMER_RATE, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	eeeTimeRate->txIdleRate = data&3;
	data >>=2;
	eeeTimeRate->wakeRate = data&3;
	data >>=2;
	eeeTimeRate->asrtRate = data&3;
	data >>=2;
	eeeTimeRate->pwrRate = data&3;

    return GT_OK;
}

/*******************************************************************************
* gsysSetPowerMonitorCtrl
*
* DESCRIPTION:
*    Set Power Monitor Control:
*                Disable the Reset Monitor. 
*                Disable the Voltage Monitor..
*                Reset Time.
*
* INPUTS:
*        pwMonitCtrl - Power Monitor Control structure.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetPowerMonitorCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_PW_MONIT_CTRL  *pwMonitCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetPowerMonitorCtrl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    data = pwMonitCtrl->disable_reset_monit;
	data <<=1;
	data |= pwMonitCtrl->disable_volt_monit;
	data <<=6;
	data |= pwMonitCtrl->reset_time;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MONIT_CTRL, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}

/*******************************************************************************
* gsysGetPowerMonitorCtrl
*
* DESCRIPTION:
*    Get Power Monitor Control:
*                Disable the Reset Monitor. 
*                Disable the Voltage Monitor..
*                Reset Time.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        pwMonitCtrl - Power Monitor Control structure.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetPowerMonitorCtrl
(
    IN  GT_QD_DEV         *dev,
    OUT GT_PW_MONIT_CTRL  *pwMonitCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetPowerMonitorCtrl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MONIT_CTRL, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	pwMonitCtrl->reset_time = data&3;
	data >>=6;
	pwMonitCtrl->disable_volt_monit = data&1;
	data >>=1;
	pwMonitCtrl->disable_reset_monit = data&1;

    return GT_OK;
}

/*******************************************************************************
* gsysSetPowerMonitorThreshold
*
* DESCRIPTION:
*    Set Power Monitor Threshold:
*                AVDD Voltage Trip Threshold. 
*                Core Voltage Trip Threshold.
*                I/O Voltate Selection range.
*                I/O Voltage Trip Threshold.
*
* INPUTS:
*        pwMonitThresh - Power Monitor Threshold structure.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetPowerMonitorThreshold
(
    IN  GT_QD_DEV         *dev,
    IN  GT_PW_MONIT_THRESHOLD  *pwMonitThresh
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetPowerMonitorThreshold Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    data = pwMonitThresh->avdd_trip&7;
	data <<=4;
	data |= pwMonitThresh->core_trip&7;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MONIT_THR_0, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
    data = pwMonitThresh->io_sel&3;
	data <<=4;
	data |= pwMonitThresh->io_trip&7;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MONIT_THR_1, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}

/*******************************************************************************
* gsysGetPowerMonitorThreshold
*
* DESCRIPTION:
*    Get Power Monitor Threshold:
*                AVDD Voltage Trip Threshold. 
*                Core Voltage Trip Threshold.
*                I/O Voltate Selection range.
*                I/O Voltage Trip Threshold.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        pwMonitThresh - Power Monitor Threshold structure.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetPowerMonitorThreshold
(
    IN  GT_QD_DEV         *dev,
    OUT GT_PW_MONIT_THRESHOLD  *pwMonitThresh
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetPowerMonitorThreshold Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MONIT_THR_0, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	pwMonitThresh->core_trip = data&7;
	data >>=4;
	pwMonitThresh->avdd_trip = data&7;

    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_PWR_MONIT_THR_1, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	pwMonitThresh->io_trip = data&7;
	data >>=4;
	pwMonitThresh->io_sel = data&3;

    return GT_OK;
}

/*******************************************************************************
* gsysSetVoltageRegulatCtrl
*
* DESCRIPTION:
*    Set Voltage Regulator Control:
*                1.5 Volt Regulator Selection range. 
*                1.1 Volt Regulator Selection range.
*
* INPUTS:
*        voltRegulCtrl - Voltage Regulator Control structure.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetVoltageRegulatCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_VOLT_REGUL_CTRL  *voltRegulCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetVoltageRegulatCtrl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    data = voltRegulCtrl->v15_sel&7;
	data <<=4;
	data |= voltRegulCtrl->v11_sel&0xf;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_VOLTAGE_CTRL, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}

/*******************************************************************************
* gsysGetVoltageRegulatCtrl
*
* DESCRIPTION:
*    Get Voltage Regulator Control:
*                1.5 Volt Regulator Selection range. 
*                1.1 Volt Regulator Selection range.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        voltRegulCtrl - Voltage Regulator Control structure.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetVoltageRegulatCtrl
(
    IN  GT_QD_DEV         *dev,
    OUT GT_VOLT_REGUL_CTRL  *voltRegulCtrl
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetVoltageRegulatCtrl Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_VOLTAGE_CTRL, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	voltRegulCtrl->v11_sel = data&0xf ;
	data >>=4;
	voltRegulCtrl->v15_sel = data&7;

    return GT_OK;
}

/*******************************************************************************
* gsysSetVoltageRegulatCtrl_2
*
* DESCRIPTION:
*    Set Voltage Regulator Control 2:
*                Delay. Change the delay between switch control signals in SCR. 
*                Dither. Dither is enabled when this bit is set to a one.
*                Select Clock. Select the internal clock frequency.
*                Select K. Select the feed forward coefficient.
*                Select N. Select the integrator size.
*
* INPUTS:
*        voltRegulCtrl_2 - Voltage Regulator Control 2 structure.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetVoltageRegulatCtrl_2
(
    IN  GT_QD_DEV         *dev,
    IN  GT_VOLT_REGUL_CTRL_2  *voltRegulCtrl_2
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetVoltageRegulatCtrl_2 Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    data = voltRegulCtrl_2->delay&3;
	data <<=1;
    data |= voltRegulCtrl_2->dither&1;
	data <<=1;
    data |= voltRegulCtrl_2->selClk&1;
	data <<=2;
	data |= voltRegulCtrl_2->selK&0x3;
	data <<=2;
	data |= voltRegulCtrl_2->selN&0x3;
    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_VOLTAGE_CTRL_2, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}

/*******************************************************************************
* gsysGetVoltageRegulatCtrl_2
*
* DESCRIPTION:
*    Get Voltage Regulator Control 2:
*                Delay. Change the delay between switch control signals in SCR. 
*                Dither. Dither is enabled when this bit is set to a one.
*                Select Clock. Select the internal clock frequency.
*                Select K. Select the feed forward coefficient.
*                Select N. Select the integrator size.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        voltRegulCtrl_2 - Voltage Regulator Control 2 structure.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetVoltageRegulatCtrl_2
(
    IN  GT_QD_DEV         *dev,
    OUT GT_VOLT_REGUL_CTRL_2  *voltRegulCtrl_2
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetVoltageRegulatCtrl_2 Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_VOLTAGE_CTRL_2, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	voltRegulCtrl_2->selN = data&0x3 ;
	data >>=2;
	voltRegulCtrl_2->selK = data&0x3 ;
	data >>=2;
	voltRegulCtrl_2->selClk = data&0x1 ;
	data >>=1;
	voltRegulCtrl_2->dither = data&0x1 ;
	data >>=1;
	voltRegulCtrl_2->delay = data&0x3 ;

    return GT_OK;
}

/*******************************************************************************
* gsysSetVoltageRegulatTest
*
* DESCRIPTION:
*    Set Voltage Regulator Test:
*                SFGD enable. Enable the safe guard circuit when set to a one. 
*                Test enable. Enable test when this bit is set to a one.
*                Test Select. Selects the test point.
*
* INPUTS:
*        voltRegulTest - Voltage Regulator Test structure.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetVoltageRegulatTest
(
    IN  GT_QD_DEV         *dev,
    IN  GT_VOLT_REGUL_TEST  *voltRegulTest
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysSetVoltageRegulatTest Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    data = voltRegulTest->SFGD&1;
	data <<=1;
    data |= voltRegulTest->testEn&1;
	data <<=3;
	data |= voltRegulTest->testSel&0x7;
   retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_VOLTAGE_TEST, data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }

    return GT_OK;
}

/*******************************************************************************
* gsysGetVoltageRegulatTest
*
* DESCRIPTION:
*    Get Voltage Regulator Test:
*                SFGD enable. Enable the safe guard circuit when set to a one. 
*                Test enable. Enable test when this bit is set to a one.
*                Test Select. Selects the test point.
*
* INPUTS:
*        None.
*
* OUTPUTS:
*        voltRegulTest - Voltage Regulator Test structure.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetVoltageRegulatTest
(
    IN  GT_QD_DEV         *dev,
    OUT GT_VOLT_REGUL_TEST  *voltRegulTest
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
	GT_U8        data;

    DBG_INFO(("gsysGetVoltageRegulatTest Called.\n"));

    /* Check if Switch supports this feature. */
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_PWR_VOLT_REGUL_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_VOLTAGE_TEST, &data);
    if(retVal != GT_OK)
       {
           DBG_INFO(("Failed.\n"));
           return retVal;
    }
	voltRegulTest->testSel = data&0x7 ;
	data >>=3;
	voltRegulTest->testEn = data&0x1 ;
	data >>=1;
	voltRegulTest->SFGD = data&0x1 ;

    return GT_OK;
}


/* gsysGlobal2PointDataSet  */

/*******************************************************************************
* gsysGlobal2PointDataSet
*
* DESCRIPTION:
*        Common set indirect register pointer control data from the Global2 
*        function registers. The function register are.
*          Scratch & Misc
*          Energy Management
*          IMP Comm/Debug
*          Watch Dog Control
*          QoS Weights
*
* INPUTS:
*        funcReg - Global 2 function register.
*        point - Pointer to following Control register.
*          Scratch & Misc
*          Energy Management
*          IMP Comm/Debug
*          Watch Dog Control
*          QoS Weights
*        data  - Scratch and Misc. Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGlobal2PointDataSet
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             funcReg,
    IN  GT_U8             point,
    IN  GT_U8             data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    IN  GT_U16   count, tmpData;
    DBG_INFO(("gsysGlobal2PointDataSet Called.\n"));

    if (data &0xffffff00)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* program QoS Weight Table, 4 sequences at a time */

    /* Wait until the Scratch and Misc control is ready. */
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 1;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = funcReg;
      regAccess.rw_reg_list[0].data = 15;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
      }
    }
#else
    count = 5;
    tmpData = 1;
    while(tmpData ==1)
    {
        retVal = hwGetGlobal2RegField(dev,funcReg,15,1,&tmpData);
           if(retVal != GT_OK)
           {
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
           }
	  if(--count==0) break;
    }
#endif

  tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);

  retVal = hwWriteGlobal2Reg(dev, funcReg, tmpData);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     gtSemGive(dev,dev->tblRegsSem);
     return retVal;
  }

  gtSemGive(dev,dev->tblRegsSem);

  return retVal;

}



/*******************************************************************************
* gsysGlobal2PointDataGet
*
* DESCRIPTION:
*        Common get indirect register pointer control data from the Global2 
*        function registers. The function register are.
*          Scratch & Misc
*          Energy Management
*          IMP Comm/Debug
*          Watch Dog Control
*          QoS Weights
*
* INPUTS:
*        funcReg - Global 2 function register.
*        point - Pointer to following Control register.
*          Scratch & Misc
*          Energy Management
*          IMP Comm/Debug
*          Watch Dog Control
*          QoS Weights
* OUTPUTS:
*        data -  Control data read from the indirect register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGlobal2PointDataGet
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             funcReg,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16            tmpData;
    int count=0x10;
    DBG_INFO(("gsysGlobal2PointDataGet Called.\n"));

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* program QoS Weight Table, 4 sequences at a time */

	tmpData =  (GT_U16)((point << 8) | 0);
	retVal = hwWriteGlobal2Reg(dev, funcReg, tmpData);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("Failed.\n"));
	   gtSemGive(dev,dev->tblRegsSem);
	   return retVal;
	}
	
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 2;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = funcReg;
      regAccess.rw_reg_list[0].data = 15;
      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
      regAccess.rw_reg_list[1].reg = funcReg;
      regAccess.rw_reg_list[1].data = 0;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
     }
     tmpData = qdLong2Short(regAccess.rw_reg_list[1].data);
    }
#else
    do {
        retVal = hwReadGlobal2Reg(dev, funcReg, &tmpData);
        if(retVal != GT_OK)
           {
               DBG_INFO(("Failed.\n"));
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
        }
		if((count--)==0) return GT_FAIL;
    } while (tmpData&0x8000);
#endif

    *data = tmpData&0xff;

    gtSemGive(dev,dev->tblRegsSem);


    return retVal;
}


/*******************************************************************************
* gdevSetScratchMiscCtrl
*
* DESCRIPTION:
*        Set Scratch and Misc control data to the Scratch and Misc Control register. 
*        The registers of Scratch and Misc control are.
*                Scratch Byte 0
*                Scratch Byte 1
*                GPIO Configuration
*                Reserved for future use
*                GPIO Direction
*                GPIO Data
*                CONFIG Data 0
*                CONFIG Data 1
*                CONFIG Data 2
*                CONFIG Data 3
*                SyncE & TAICLK125’s Drive
*                P5’s & CLK125’s Clock Drive
*                P6’s Clock Drive
*                EEPROM Pad drive
*
* INPUTS:
*        point - Pointer to the Scratch and Misc. Control register.
*        data  - Scratch and Misc. Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevSetScratchMiscCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8            point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevSetScratchMiscCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_SCRAT_MISC_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataSet(dev, QD_REG_SCRATCH_MISC, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataSet Failed.\n"));
	   return retVal;
	}


  return retVal;

}



/*******************************************************************************
* gdevGetScratchMiscCtrl
*
* DESCRIPTION:
*        Get Scratch and Misc control data from the Scratch and Misc Control register. 
*        The register of Scratch and Misc control are.
*                Scratch Byte 0
*                Scratch Byte 1
*                GPIO Configuration
*                Reserved for future use
*                GPIO Direction
*                GPIO Data
*                CONFIG Data 0
*                CONFIG Data 1
*                CONFIG Data 2
*                CONFIG Data 3
*                SyncE & TAICLK125’s Drive
*                P5’s & CLK125’s Clock Drive
*                P6’s Clock Drive
*                EEPROM Pad drive

*
* INPUTS:
*        point - Pointer to the Scratch and Misc. Control register.
*
* OUTPUTS:
*        data - Scratch and Misc. Control data read from the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevGetScratchMiscCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevGetScratchMiscCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_SCRAT_MISC_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataGet(dev, QD_REG_SCRATCH_MISC, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataGet Failed.\n"));
	   return retVal;
	}

    return retVal;
}

/*******************************************************************************
* gdevSetEnergeManagementCtrl
*
* DESCRIPTION:
*        Set Energe management control data to the Energe management Control register. 
*        The registers of Energe management control are.
*            Per port EEE receive status counters  
*            EEE status registers – Ports 0 to 15 
*            Per port EEE transmit status counters 
*            EEE status registers – Ports 16 to 26 
*
* INPUTS:
*        point - Pointer to the Energe management Control register.
*        data  - Energe management Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevSetEnergeManagementCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevSetEnergeManagementCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_ENERGE_MGMT))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_ENERGE_MANAGMENT_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataSet(dev, QD_REG_ENERGE_MNT, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataSet Failed.\n"));
	   return retVal;
	}


  return retVal;

}



/*******************************************************************************
* gdevGetEnergeManagementCtrl
*
* DESCRIPTION:
*        Get Energe management control data from the Energe management Control register. 
*        The register of Energe management control are.
*            Per port EEE receive status counters  
*            EEE status registers – Ports 0 to 15 
*            Per port EEE transmit status counters 
*            EEE status registers – Ports 16 to 26 

*
* INPUTS:
*        point - Pointer to the Energe management Control register.
*
* OUTPUTS:
*        data - Energe management Control data read from the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevGetEnergeManagementCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevGetEnergeManagementCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_ENERGE_MGMT))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_ENERGE_MANAGMENT_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataGet(dev, QD_REG_ENERGE_MNT, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataGet Failed.\n"));
	   return retVal;
	}

    return retVal;
}

/*******************************************************************************
* gdevSetImpCommCtrl
*
* DESCRIPTION:
*        Set IMP Communication/Debug control data from the IMP Communication/Debug Control register. 
*        The register of IMP Communication/Debug control are.
*           Communication Interface to/from the CPU 
*           Debug Control & Status 
*           CPU’s Main and Alternate Registers 
*           CPU’s Special Purpose Registers 
*           Hidden Debug Pointer 
*           Hidden Debug Data 
*           IMP I/O Page Register 
*           Break Point Control 
*           Break Point Status 
*           Break Point 0 
*           Break Point 1 
*           Break Point 2 
*           Break Point 3 
*           IMP I/O Registers 
*
* INPUTS:
*        point - Pointer to the IMP Communication/Debug Control register.
*        data  - IMP Communication/Debug Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevSetImpCommCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevSetImpCommCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_IMP_COMM_DEBUG))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_IMP_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataSet(dev, QD_REG_IMP_COMM_DEBUG, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataSet Failed.\n"));
	   return retVal;
	}


  return retVal;

}



/*******************************************************************************
* gdevGetImpCommCtrl
*
* DESCRIPTION:
*        Get IMP Communication/Debug control data from the IMP Communication/Debug Control register. 
*        The register of IMP Communication/Debug control are.
*           Communication Interface to/from the CPU 
*           Debug Control & Status 
*           CPU’s Main and Alternate Registers 
*           CPU’s Special Purpose Registers 
*           Hidden Debug Pointer 
*           Hidden Debug Data 
*           IMP I/O Page Register 
*           Break Point Control 
*           Break Point Status 
*           Break Point 0 
*           Break Point 1 
*           Break Point 2 
*           Break Point 3 
*           IMP I/O Registers 
*
* INPUTS:
*        point - Pointer to the IMP Communication/Debug register.
*
* OUTPUTS:
*        data - IMP Communication/Debug Control data read from the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevGetImpCommCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevGetImpCommCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_IMP_COMM_DEBUG))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_IMP_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataGet(dev, QD_REG_IMP_COMM_DEBUG, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataGet Failed.\n"));
	   return retVal;
	}

    return retVal;
}

/*******************************************************************************
* gdevSetWatchDogCtrl
*
* DESCRIPTION:
*        Set Watch Dog control data from the Watch Dog Control register. 
*        The register of Watch Dog control are.
*          Watch Dog Interrupt Source 
*          Data Path Watch Dog Interrupts, Masks, Events & History 
*          Policy Interrupts, Masks, Events & History 
*          Auto Fixing Enables 
*
* INPUTS:
*        point - Pointer to the Watch Dog register.
*        data  - Watch Dog Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevSetWatchDogCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevSetWatchDogCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_WD_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataSet(dev, QD_REG_WD_CONTROL, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataSet Failed.\n"));
	   return retVal;
	}


  return retVal;

}



/*******************************************************************************
* gdevGetWatchDogCtrl
*
* DESCRIPTION:
*        Get Watch Dog control data from the Watch Dog Control register. 
*        The register of Watch Dog control are.
*          Watch Dog Interrupt Source 
*          Data Path Watch Dog Interrupts, Masks, Events & History 
*          Policy Interrupts, Masks, Events & History 
*          Auto Fixing Enables 
*
* INPUTS:
*        point - Pointer to the Watch Dog Control register.
*
* OUTPUTS:
*        data - Watch Dog. Control data read from the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevGetWatchDogCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevGetWatchDogCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > GT_IMP_REG_MAX)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal2PointDataGet(dev, QD_REG_WD_CONTROL, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataGet Failed.\n"));
	   return retVal;
	}

    return retVal;
}

/*******************************************************************************
* gdevSetQosWeightCtrl
*
* DESCRIPTION:
*        Set QoS Weight control data from the QoS Weight Control register. 
*        The register of QoS Weight control are one of 64 possible QoS Weight 
*        Data registers and the QoS Weight Length register.
*         
* INPUTS:
*        point - Pointer to the QoS Weight register.
*        data  - QoS Weight Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevSetQosWeightCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevSetQosWeightCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL_1))
	{
      if (point > 127)
	  {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
	  }
	}
	else
	{
      if (point > 63)
	  {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
	  }
	}

	retVal = gsysGlobal2PointDataSet(dev, QD_REG_QOS_WEIGHT, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataSet Failed.\n"));
	   return retVal;
	}


  return retVal;

}



/*******************************************************************************
* gdevGetQosWeightCtrl
*
* DESCRIPTION:
*        Set QoS Weight control data from the QoS Weight Control register. 
*        The register of QoS Weight control are one of 64 possible QoS Weight 
*        Data registers and the QoS Weight Length register.
*         
* INPUTS:
*        point - Pointer to the QoS Weight register.
*
* OUTPUTS:
*        data  - QoS Weight Control data written to the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gdevGetQosWeightCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gdevGetQosWeightCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL_1))
	{
      if (point > 127)
	  {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
	  }
	}
	else
	{
      if (point > 63)
	  {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
	  }
	}

	retVal = gsysGlobal2PointDataGet(dev, QD_REG_QOS_WEIGHT, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal2PointDataGet Failed.\n"));
	   return retVal;
	}

    return retVal;
}


/* gsysGlobal1PointDataSet  */

/*******************************************************************************
* gsysGlobal1PointDataSet
*
* DESCRIPTION:
*        Common set indirect register pointer control data from the Global1 
*        function registers. The function register are.
*          Monitor and Management Control
*
* INPUTS:
*        funcReg - Global 1 function register.
*        point - Pointer to following Control register.
*          Monitor and Management Control
*
*        data  - Scratch and Misc. Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGlobal1PointDataSet
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             funcReg,
    IN  GT_U8             point,
    IN  GT_U8             data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    IN  GT_U16   count, tmpData;
    DBG_INFO(("gsysGlobal1PointDataSet Called.\n"));

    if (data &0xffffff00)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* program QoS Weight Table, 4 sequences at a time */

    /* Wait until the Scratch and Misc control is ready. */
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 1;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL1_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = funcReg;
      regAccess.rw_reg_list[0].data = 15;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
      }
    }
#else
    count = 5;
    tmpData = 1;
    while(tmpData ==1)
    {
        retVal = hwGetGlobalRegField(dev,funcReg,15,1,&tmpData);
           if(retVal != GT_OK)
           {
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
           }
	  if(--count==0) break;
    }
#endif

  tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);

  retVal = hwWriteGlobalReg(dev, funcReg, tmpData);
  if(retVal != GT_OK)
  {
     DBG_INFO(("Failed.\n"));
     gtSemGive(dev,dev->tblRegsSem);
     return retVal;
  }

  gtSemGive(dev,dev->tblRegsSem);

  return retVal;

}



/*******************************************************************************
* gsysGlobal1PointDataGet
*
* DESCRIPTION:
*        Common get indirect register pointer control data from the Global1 
*        function registers. The function register are.
*          Monitor and Management Control
*
* INPUTS:
*        funcReg - Global 1 function register.
*        point - Pointer to following Control register.
*          Monitor and Management Control
*
* OUTPUTS:
*        data -  Control data read from the indirect register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGlobal1PointDataGet
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             funcReg,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    GT_U16            tmpData;
    int count=0x10;
    DBG_INFO(("gsysGlobal1PointDataGet Called.\n"));

    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);

    /* program QoS Weight Table, 4 sequences at a time */

	tmpData =  (GT_U16)((point << 8) | 0);
	retVal = hwWriteGlobalReg(dev, funcReg, tmpData);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("Failed.\n"));
	   gtSemGive(dev,dev->tblRegsSem);
	   return retVal;
	}
	
#ifdef GT_RMGMT_ACCESS
    {
      HW_DEV_REG_ACCESS regAccess;

      regAccess.entries = 2;
  
      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL1_REG_ACCESS);
      regAccess.rw_reg_list[0].reg = funcReg;
      regAccess.rw_reg_list[0].data = 15;
      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL1_REG_ACCESS);
      regAccess.rw_reg_list[1].reg = funcReg;
      regAccess.rw_reg_list[1].data = 0;
      retVal = hwAccessMultiRegs(dev, &regAccess);
      if(retVal != GT_OK)
      {
        gtSemGive(dev,dev->vtuRegsSem);
        return retVal;
     }
     tmpData = qdLong2Short(regAccess.rw_reg_list[1].data);
    }
#else
    do {
        retVal = hwReadGlobalReg(dev, funcReg, &tmpData);
        if(retVal != GT_OK)
           {
               DBG_INFO(("Failed.\n"));
            gtSemGive(dev,dev->tblRegsSem);
               return retVal;
        }
		if((count--)==0) return GT_FAIL;
    } while (tmpData&0x8000);
#endif

    *data = tmpData&0xff;

    gtSemGive(dev,dev->tblRegsSem);


    return retVal;
}


/*******************************************************************************
* gsysSetMonitorMgmtCtrl
*
* DESCRIPTION:
*        Set Monitor and mgmt control data. 
*         
* INPUTS:
*        point - Pointer to the Monitor and mgmt control register.
*           The Pointer bits are used to access the Index registers as follows:
*              0x00 to 0x01: Rsvd2Cpu Enables for 01:C2:80:00:00:0x
*              0x02 to 0x03: Rsvd2Cpu Enables for 01:C2:80:00:00:2x
*              0x04 to 0x05: Rsvd2IntCpu Enables for 01:C2:80:00:00:0x
*              0x06 to 0x07: Rsvd2IntCpu Enables for 01:C2:80:00:00:2x
*              0x04 to 0x1F: Reserved for future use.
*              0x20 to 0x2F: Mirror Destination Port Settings
*              0x30 to 0x3F: Trap Destination Port Settings
*        data  - Monitor and mgmt Control data written to the register 
*                pointed to by the point above.
*
* OUTPUTS:
*        None.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysSetMonitorMgmtCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    IN  GT_U8            data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gsysSetMonitorMgmtCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_MONIT_MGMT_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > 64)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal1PointDataSet(dev, QD_REG_MONITOR_CONTROL, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobalPointDataSet Failed.\n"));
	   return retVal;
	}


  return retVal;

}



/*******************************************************************************
* gsysGetMonitorMgmtCtrl
*
* DESCRIPTION:
*        Get Monitor and mgmt control data. 
*         
* INPUTS:
*        point - Pointer to the Monitor and mgmt control register.
*           The Pointer bits are used to access the Index registers as follows:
*              0x00 to 0x01: Rsvd2Cpu Enables for 01:C2:80:00:00:0x
*              0x02 to 0x03: Rsvd2Cpu Enables for 01:C2:80:00:00:2x
*              0x04 to 0x05: Rsvd2IntCpu Enables for 01:C2:80:00:00:0x
*              0x06 to 0x07: Rsvd2IntCpu Enables for 01:C2:80:00:00:2x
*              0x04 to 0x1F: Reserved for future use.
*              0x20 to 0x2F: Mirror Destination Port Settings
*              0x30 to 0x3F: Trap Destination Port Settings
*
* OUTPUTS:
*        data  - Monitor and mgmt Control data written to the register 
*                pointed to by the point above.
*
* RETURNS:
*        GT_OK      - on success
*        GT_FAIL    - on error
*        GT_BAD_PARAM - if input parameters are beyond range.
*        GT_NOT_SUPPORTED - if current device does not support this feature.
*
* COMMENTS:
*        None
*
*******************************************************************************/
GT_STATUS gsysGetMonitorMgmtCtrl
(
    IN  GT_QD_DEV         *dev,
    IN  GT_U8             point,
    OUT  GT_U8            *data
)
{
    GT_STATUS    retVal;         /* Functions return value.      */
    DBG_INFO(("gsysGetMonitorMgmtCtrl Called.\n"));

    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (!IS_IN_DEV_GROUP(dev,DEV_MONIT_MGMT_CTRL))
    {
        DBG_INFO(("GT_NOT_SUPPORTED\n"));
        return GT_NOT_SUPPORTED;
    }
    if (point > 64)
    {
        DBG_INFO(("GT_BAD_PARAM\n"));
        return GT_BAD_PARAM;
    }

	retVal = gsysGlobal1PointDataGet(dev, QD_REG_MONITOR_CONTROL, point, data);
	if(retVal != GT_OK)
	{
	   DBG_INFO(("gsysGlobal1PointDataGet Failed.\n"));
	   return retVal;
	}

    return retVal;
}










