/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.notify.conf 10110 2004-04-15 12:29:19Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "jwsTrapPortRateThreshold.h"

#include "jws_ubus_if.h"
#include "jwslog.h"
#include "stdio.h"
#include "jwsDevBaseInfo.h"
#include "jwsUciTrapConf.h"

static oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};

#define DEFAULT_TRAFFIC_INTERVAL (3) /* seconds */

enum alarmFlag{
    ALRAM_SEND_NONE = 0,
    ALARM_SEND_DONE = 1,
};

struct traffic_info
{
    /* send alarm message only one time */
    enum alarmFlag alarm_rxdone;
    enum alarmFlag alarm_txdone;
    /* save rx byte interval DEFAULT_TRAFFIC_INTERVAL time */
    unsigned int interval_rxOctets;
    unsigned int threshold_rxOctets;
    /* save tx byte interval DEFAULT_TRAFFIC_INTERVAL time */
    unsigned int interval_txOctets;
    unsigned int threshold_txOctets;
};

static struct trap_cfg trapPortCfgEntry[PORT_MAX_NUM];
static struct traffic_info gTrafficInfo[PORT_MAX_NUM]={0};
static fal_mib_info_t curStatsTable[PORT_MAX_NUM]={0};
static fal_mib_info_t preStatsTable[PORT_MAX_NUM];
static struct stJwsDevBaseInfo jwsDevBaseInfo;

void init_jwsTrapPortRateThreshold(void)
{
    int i;
    int status;

    LogWrite(INF, "file:%s line:%d func:%s\n",
                                __FILENAME__, __LINE__, __FUNCTION__);

    trapCfgLoad();

    getJwsDevBaseInfo(&jwsDevBaseInfo);

    for(i=0; i<jwsDevBaseInfo.port_num; i++){
        status = trap_get_cfg_entry(i, &trapPortCfgEntry[i]);
        if(0 != status){
            LogWrite(ERROR, "file:%s line:%d func:%s, get trap cfg failed\n",
                                __FILENAME__, __LINE__, __FUNCTION__);
            return;
        }
    }

    for (i = 0; i < jwsDevBaseInfo.port_num; i++)
    {
        if(0 == strncmp(jwsDevBaseInfo.port_name[i], "Gex", 3)){
            /* (1000000000/8)*(trap->tx_percentage/100)*DEFAULT_TRAFFIC_INTERVAL  */
            gTrafficInfo[i].threshold_txOctets = 1250000 * (trapPortCfgEntry[i].tx_percentage) * DEFAULT_TRAFFIC_INTERVAL;
        } else if (0 == strncmp(jwsDevBaseInfo.port_name[i], "Fex", 3)){
            /* (100000000/8)*(trap->tx_percentage/100)*DEFAULT_TRAFFIC_INTERVAL  */
            gTrafficInfo[i].threshold_txOctets = 125000 * (trapPortCfgEntry[i].tx_percentage) * DEFAULT_TRAFFIC_INTERVAL;
        }

        if(0 == strncmp(jwsDevBaseInfo.port_name[i], "Gex", 3)){
            /* (1000000000/8)*(trap->rx_percentage/100)*DEFAULT_TRAFFIC_INTERVAL  */
            gTrafficInfo[i].threshold_rxOctets = 1250000 * (trapPortCfgEntry[i].rx_percentage) * DEFAULT_TRAFFIC_INTERVAL;
        } else if (0 == strncmp(jwsDevBaseInfo.port_name[i], "Fex", 3)){
            /* (100000000/8)*(trap->rx_percentage/100)*DEFAULT_TRAFFIC_INTERVAL  */
            gTrafficInfo[i].threshold_rxOctets = 125000 * (trapPortCfgEntry[i].rx_percentage) * DEFAULT_TRAFFIC_INTERVAL;
        }
    }

#if 0
    for(i=0; i<jwsDevBaseInfo.port_num; i++){
        LogWrite(DEBUG, "file:%s line:%d func:%s,\n%s threshold: tx %u bps, rx %u bps\n",
                __FILENAME__, __LINE__, __FUNCTION__, 
                jwsDevBaseInfo.port_name[i], 
                8*gTrafficInfo[i].threshold_txOctets/DEFAULT_TRAFFIC_INTERVAL,
                8*gTrafficInfo[i].threshold_rxOctets/DEFAULT_TRAFFIC_INTERVAL);
    }
#endif

    DEBUGMSGTL(("jwsPortRateThreshold_notification",
                "initializing (setting callback alarm)\n"));
    snmp_alarm_register(DEFAULT_TRAFFIC_INTERVAL,     /* seconds */
                        SA_REPEAT,      /* repeat (every 3 seconds). */
                        send_jwsPortRateThreshold_notification,      /* our callback */
                        NULL    /* no callback data needed */
        );
}

void send_jwsPortRateThreshold_notification(unsigned int clientreg, void *clientarg)
{
    int status = 0;
    int i;
    static int skipfirst = 0;
    struct trap_msg trap_msg;

    /* get nic statistics */
    for(i=0; i<jwsDevBaseInfo.port_num; i++){
        status = get_port_entry_statistics(i+1, &curStatsTable[i]);
        if(status != 0){
            LogWrite(ERROR, "file:%s line:%d func:%s, get statistics , ifname: %s error code:%d\n",
                    __FILENAME__, __LINE__, __FUNCTION__, jwsDevBaseInfo.port_name[i], status);
            return;
        }
    }

#if 0
   for(i=0; i<jwsDevBaseInfo.port_num; i++){
            LogWrite(INF, "file:%s line:%d func:%s, statistics: %s\n"
                    "RxGoodByteLo:%u\n"
                    "RxGoodByteHi:%u\n"
                    "RxUnicastPkts:%u\n"
                    "RxBroadcastPkts:%u\n"
                    "RxMulticastPkts:%u\n"
                    "RxPausePkts:%u\n"
                    "TxByteLo:%u\n"
                    "TxByteHi:%u\n"
                    "TxUnicastPkts:%u\n"
                    "TxBroadcastPkts:%u\n"
                    "TxMulticastPkts:%u\n"
                    "TxPausePkts:%u\n",
                    __FILENAME__, __LINE__, __FUNCTION__,
                    jwsDevBaseInfo.port_name[i],
                    curStatsTable[i].RxGoodByteLo,
                    curStatsTable[i].RxGoodByteHi,
                    curStatsTable[i].RxUnicastPkts,
                    curStatsTable[i].RxBroadcastPkts,
                    curStatsTable[i].RxMulticastPkts,
                    curStatsTable[i].RxPausePkts,

                    curStatsTable[i].TxByteLo,
                    curStatsTable[i].TxByteHi,
                    curStatsTable[i].TxUnicastPkts,
                    curStatsTable[i].TxBroadcastPkts,
                    curStatsTable[i].TxMulticastPkts,
                    curStatsTable[i].TxPausePkts);
    }
#endif

    /* skip first call interface statistics */
    if (0 == skipfirst) {
        for (i = 0; i < jwsDevBaseInfo.port_num; i++) {
            preStatsTable[i] = curStatsTable[i];
        }

        skipfirst = 1;
        return;
    }

    /* fetch receive interval packets number */
    for (i = 0; i < jwsDevBaseInfo.port_num; i++)
    {
        if( (unsigned int)curStatsTable[i].RxGoodByteLo < (unsigned int)preStatsTable[i].RxGoodByteLo ){
            gTrafficInfo[i].interval_rxOctets = 0xffffffff - (unsigned int)curStatsTable[i].RxGoodByteLo + (unsigned int)preStatsTable[i].RxGoodByteLo;
        }else{
            gTrafficInfo[i].interval_rxOctets = (unsigned int)curStatsTable[i].RxGoodByteLo - (unsigned int)preStatsTable[i].RxGoodByteLo;
        }
    }
    
    /* fetch transmit interval packets number */
    for (i = 0; i < jwsDevBaseInfo.port_num; i++)
    {
        if( (unsigned int)curStatsTable[i].TxByteLo < (unsigned int)preStatsTable[i].TxByteLo ){
            gTrafficInfo[i].interval_txOctets = 0xffffffff - (unsigned int)curStatsTable[i].TxByteLo + (unsigned int)preStatsTable[i].TxByteLo;
        }else{
            gTrafficInfo[i].interval_txOctets = (unsigned int)curStatsTable[i].TxByteLo - (unsigned int)preStatsTable[i].TxByteLo;
        }

    }
    
    /* send alarm message */
    for (i = 0; i < jwsDevBaseInfo.port_num; i++)
    {
        if(gTrafficInfo[i].alarm_txdone == ALARM_SEND_DONE){
            if (gTrafficInfo[i].interval_txOctets < gTrafficInfo[i].threshold_txOctets)
            {
                gTrafficInfo[i].alarm_txdone = ALRAM_SEND_NONE;
            }
        }

        if(gTrafficInfo[i].alarm_rxdone == ALARM_SEND_DONE){
            if (gTrafficInfo[i].interval_rxOctets < gTrafficInfo[i].threshold_rxOctets)
            {
                gTrafficInfo[i].alarm_rxdone = ALRAM_SEND_NONE;
            }
        }
#if 0
        LogWrite(DEBUG, "file:%s line:%d func:%s, \n%s:rxdone %d txdone %d\n",
            __FILENAME__, __LINE__, __FUNCTION__, 
            jwsDevBaseInfo.port_name[i], 
            gTrafficInfo[i].alarm_rxdone, 
            gTrafficInfo[i].alarm_txdone);
#endif

        if( (ENABLE == trapPortCfgEntry[i].tx_enable) &&
            (ALRAM_SEND_NONE == gTrafficInfo[i].alarm_txdone) &&
            (gTrafficInfo[i].interval_txOctets > gTrafficInfo[i].threshold_txOctets)
        )
        {
            trap_msg.port_id = i + 1;
            trap_msg.direction = DOWNSTREAM;
            trap_msg.percentage = trapPortCfgEntry[i].tx_percentage;
            send_jwsTrapPortRateThreshold_trap( &trap_msg );
            gTrafficInfo[i].alarm_txdone = ALARM_SEND_DONE;
            LogWrite(DEBUG, "file:%s line:%d func:%s"
                "\nPortRateThreshold alarm: %s DOWNSTREAM %d%%\n",
                __FILENAME__, __LINE__, __FUNCTION__,
                jwsDevBaseInfo.port_name[i], trap_msg.percentage);
        }

        if( (ENABLE == trapPortCfgEntry[i].rx_enable) &&
            (ALRAM_SEND_NONE == gTrafficInfo[i].alarm_rxdone) &&
            (gTrafficInfo[i].interval_rxOctets > gTrafficInfo[i].threshold_rxOctets)
        )
        {
            trap_msg.port_id = i + 1;
            trap_msg.direction = UPSTREAM;
            trap_msg.percentage = trapPortCfgEntry[i].rx_percentage;
            send_jwsTrapPortRateThreshold_trap( &trap_msg);
            gTrafficInfo[i].alarm_rxdone = ALARM_SEND_DONE;
            LogWrite(DEBUG, "file:%s line:%d func:%s"
                "\nPortRateThreshold alarm: %s UPSTREAM %d%%\n",
                __FILENAME__, __LINE__, __FUNCTION__, 
                jwsDevBaseInfo.port_name[i], trap_msg.percentage);
        }

    }

#if 0
    for(i=0; i<jwsDevBaseInfo.port_num; i++){
        LogWrite(DEBUG, "file:%s line:%d func:%s,\n %s:\n\
         alarm: tx %d, rx %d  \n\
         statistics: tx %u bps, rx %u bps \n\
         threshold: tx %u bps, rx %u bps\n",
                __FILENAME__, __LINE__, __FUNCTION__, 
                jwsDevBaseInfo.port_name[i], 
                trapPortCfgEntry[i].tx_enable,
                trapPortCfgEntry[i].rx_enable,
                8*gTrafficInfo[i].interval_txOctets/DEFAULT_TRAFFIC_INTERVAL, 
                8*gTrafficInfo[i].interval_rxOctets/DEFAULT_TRAFFIC_INTERVAL,
                8*gTrafficInfo[i].threshold_txOctets/DEFAULT_TRAFFIC_INTERVAL,
                8*gTrafficInfo[i].threshold_rxOctets/DEFAULT_TRAFFIC_INTERVAL);
    }
#endif

    /* save current statistics table data */
    for (i = 0; i < jwsDevBaseInfo.port_num; i++) {
        preStatsTable[i] = curStatsTable[i];
    }

    return;
}

int
send_jwsTrapPortRateThreshold_trap( struct trap_msg *msg )
{
    netsnmp_variable_list  *var_list = NULL;
    oid jwsTrapPortRateThreshold_oid[] = { 1,3,6,1,4,1,33444,2,2,100,3,1002 };
    oid jwsTrapObjPortId_oid[] = { 1,3,6,1,4,1,33444,2,2,100,2,2, 0 };
    oid jwsTrapObjPortRateDirection_oid[] = { 1,3,6,1,4,1,33444,2,2,100,2,4, 0 };
    oid jwsTrapObjPortRatePercentage_oid[] = { 1,3,6,1,4,1,33444,2,2,100,2,5, 0 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        (u_char *) jwsTrapPortRateThreshold_oid, sizeof(jwsTrapPortRateThreshold_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        jwsTrapObjPortId_oid, OID_LENGTH(jwsTrapObjPortId_oid),
        ASN_INTEGER,
        /* Set an appropriate value for jwsTrapObjPortId */
        (u_char *) &(msg->port_id), sizeof(msg->port_id));
    snmp_varlist_add_variable(&var_list,
        jwsTrapObjPortRateDirection_oid, OID_LENGTH(jwsTrapObjPortRateDirection_oid),
        ASN_INTEGER,
        /* Set an appropriate value for jwsTrapObjPortRateDirection */
        (u_char *) &(msg->direction), sizeof(msg->direction));
    snmp_varlist_add_variable(&var_list,
        jwsTrapObjPortRatePercentage_oid, OID_LENGTH(jwsTrapObjPortRatePercentage_oid),
        ASN_INTEGER,
        /* Set an appropriate value for jwsTrapObjPortRatePercentage */
        (u_char *) &(msg->percentage), sizeof(msg->percentage));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
