/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "jwsTrapPortStatus.h"
#include "jws_ubus_if.h"
#include "jwslog.h"
#include "jwsDevBaseInfo.h"
#include "jwsUciTrapConf.h"

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/if.h>

enum eLinkStatus
{
    LINK_UP = 1,
    LINK_DOWN,
};

struct stPortLink
{
    enum eLinkStatus curStats[PORT_MAX_NUM];
    enum eLinkStatus preStats[PORT_MAX_NUM];
};

static oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};
static struct stPortLink portLink;
static struct stJwsDevBaseInfo jwsDevBaseInfo;
static struct trap_cfg trapPortCfgEntry[PORT_MAX_NUM];

/*
 * our initialization routine
 * (to get called, the function name must match init_FILENAME() 
 */
void
init_jwsTrapPortStatus(void)
{
    int status;
    int i;

    LogWrite(INF, "file:%s line:%d func:%s\n",
                                __FILENAME__, __LINE__, __FUNCTION__);
    trapCfgLoad();
    getJwsDevBaseInfo(&jwsDevBaseInfo);

    for(i = 0; i < jwsDevBaseInfo.port_num; i++){
        portLink.curStats[i] = LINK_DOWN;
        portLink.preStats[i] = LINK_DOWN;
    }

    for(i=0; i<jwsDevBaseInfo.port_num; i++){
        status = trap_get_cfg_entry(i, &trapPortCfgEntry[i]);
        if(0 != status){
            LogWrite(ERROR, "file:%s line:%d func:%s, get trap cfg failed\n",
                                __FILENAME__, __LINE__, __FUNCTION__);
            return;
        }
    }

    DEBUGMSGTL(("jwsTrapPortStatus_notification",
                "initializing (setting callback alarm)\n"));
    snmp_alarm_register(1,     /* seconds */
                        SA_REPEAT,      /* repeat (every 1 seconds). */
                        send_jwsTrapPortStatus_notification,      /* our callback */
                        NULL    /* no callback data needed */
        );
}

static int
send_jwsTrapPortStatus_trap(int portNum, enum eLinkStatus status)
{
    netsnmp_variable_list  *var_list = NULL;

    const oid jwsTrapPortStatus_oid[] = { 1,3,6,1,4,1,33444,2,2,100,3,1001 };
    const oid jwsTrapObjPortId_oid[] = { 1,3,6,1,4,1,33444,2,2,100,2,2, 0 };
    const oid jwsTrapObjPortStatus_oid[] = { 1,3,6,1,4,1,33444,2,2,100,2,3, 0 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        (u_char *) jwsTrapPortStatus_oid, sizeof(jwsTrapPortStatus_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        jwsTrapObjPortId_oid, OID_LENGTH(jwsTrapObjPortId_oid),
        ASN_INTEGER,
        /* Set an appropriate value for jwsTrapObjPortId */
        (u_char *) &portNum, sizeof(portNum));

    snmp_varlist_add_variable(&var_list,
        jwsTrapObjPortStatus_oid, OID_LENGTH(jwsTrapObjPortStatus_oid),
        ASN_INTEGER,
        /* Set an appropriate value for jwsTrapObjPortStatus */
        (u_char *) &status, sizeof(status));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}

void
send_jwsTrapPortStatus_notification(unsigned int clientreg, void *clientarg)
{

    int fd, i;
    struct ifreq ifrq;
    static int skiptime = 2;

    /* skip 2 seconds so filter wave */
    if (skiptime) {
        skiptime--;
        return;
    }

    /* open socket */ 
    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0){
         LogWrite(ERROR, "file:%s line:%d func:%s, open socket failed\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    /* get port link status */
    for (i = 0; i < jwsDevBaseInfo.port_num; i++)
    {
        strcpy(ifrq.ifr_name, jwsDevBaseInfo.port_name[i]);

        if(ioctl(fd, SIOCGIFFLAGS, (char *)&ifrq) >= 0)
        {
            if(IFF_RUNNING & ifrq.ifr_flags)
            {
                portLink.curStats[i] = LINK_UP;
            }else{
                portLink.curStats[i] = LINK_DOWN;
            }
        }else{
            LogWrite(ERROR, "file:%s line:%d func:%s, get interface SIOCGIFFLAGS failed\n",
                __FILENAME__, __LINE__, __FUNCTION__);
        }
    }
    /* close socket */
    shutdown(fd, SHUT_RDWR);
    close(fd);

    /* checking port link status change and sending alarm */
    for(i = 0; i < jwsDevBaseInfo.port_num; i++){
        if(ENABLE != trapPortCfgEntry[i].port_en)
            continue;

        if (portLink.curStats[i] != portLink.preStats[i]) {
            LogWrite(DEBUG, "file:%s line:%d func:%s, %s link status:%d\n",
                    __FILENAME__, __LINE__, __FUNCTION__, 
                    jwsDevBaseInfo.port_name[i], portLink.curStats[i]);
            send_jwsTrapPortStatus_trap(i+1, portLink.curStats[i]);
            /* save current port link status */
            portLink.preStats[i] = portLink.curStats[i];
        }
    }

    return;
}