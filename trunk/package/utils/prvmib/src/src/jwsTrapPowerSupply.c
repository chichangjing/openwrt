/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.notify.conf 10110 2004-04-15 12:29:19Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "jwsTrapPowerSupply.h"

#include "jws_convert.h"
#include "jws_ubus_if.h"
#include "jwslog.h"
#include "jwsDevBaseInfo.h"
#include "jwsUciTrapConf.h"

static oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};
static enum PW_ALARM_STATUS powEnable;

int
send_jwsTrapPowerSupply_trap( enum PWSTATUS pwStatus );

/*
 * our initialization routine
 * (to get called, the function name must match init_FILENAME() 
 */
void
init_jwsTrapPowerSupply(void)
{
    trapCfgLoad();
    init_power_a();
    init_power_b();
    init_alarm_led();
    init_run_led();
    alarm_led_set(1);

    DEBUGMSGTL(("send_jwsTrapPowerSupply_alarm_led",
                "initializing (setting callback alarm)\n"));
    snmp_alarm_register(1,     /* seconds */
                        SA_REPEAT,      /* repeat (every 1 seconds). */
                        send_jwsTrapPowerSupply_alarm_led,      /* our callback */
                        NULL    /* no callback data needed */
        );
    
    if (0 != getPowerSupplyCfg(&powEnable)){
        LogWrite(ERROR, "file:%s line:%d func:%s, getPowerSupplyCfg failed\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    if(PW_ALARM_ENABLE != powEnable){
        LogWrite(INF, "file:%s line:%d func:%s, double power check disable\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    LogWrite(INF, "file:%s line:%d func:%s, double power check enable\n",
                __FILENAME__, __LINE__, __FUNCTION__);


    DEBUGMSGTL(("jwsTrapPowerSupply_notification",
                "initializing (setting callback alarm)\n"));
    snmp_alarm_register(1,     /* seconds */
                        SA_REPEAT,      /* repeat (every 1 seconds). */
                        send_jwsTrapPowerSupply_notification,      /* our callback */
                        NULL    /* no callback data needed */
        );
}
void
send_jwsTrapPowerSupply_alarm_led(unsigned int clientreg, void *clientarg)
{
    int status;
    enum PW_SUPPLY_STATUS pow1Status;
    enum PW_SUPPLY_STATUS pow2Status;
    static int run_led_flag = 0;

    if (run_led_flag == 1)
    {
        /* run led turn on */
        run_led_set(0);
        run_led_flag = 0;
    }else{
        /* run led turn off */
        run_led_set(1);
        run_led_flag = 1;
    }

    status = power_a_get((int *)&pow2Status);
    if (0 != status){
        LogWrite(ERROR, "file:%s line:%d func:%s, get power[1] status failed\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    status = power_b_get((int *)&pow1Status);
    if (0 != status){
        LogWrite(ERROR, "file:%s line:%d func:%s, get power[2] status failed\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    if(PW_SUPPLY_ON == pow1Status && PW_SUPPLY_ON == pow2Status){
        /* power supply alarm led turn off */
        alarm_led_set(1);
        LogWrite(DEBUG, "power supply alarm led turn off\n",
            __FILENAME__, __LINE__, __FUNCTION__);
    }else{
        /* power supply led turn on */
        alarm_led_set(0);
        LogWrite(DEBUG, "power supply alarm led turn on\n",
            __FILENAME__, __LINE__, __FUNCTION__);
    }
}

void
send_jwsTrapPowerSupply_notification(unsigned int clientreg, void *clientarg)
{
    int status;
    enum PW_SUPPLY_STATUS pow1Status;
    enum PW_SUPPLY_STATUS pow2Status;
    static enum PWSTATUS cur_pwStatus = PW1FAIL_AND_PW2FAIL;
    static enum PWSTATUS pre_pwStatus = PW1FAIL_AND_PW2FAIL;

    status = power_a_get((int *)&pow2Status);
    if (0 != status){
        LogWrite(ERROR, "file:%s line:%d func:%s, get power[1] status failed\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    status = power_b_get((int *)&pow1Status);
    if (0 != status){
        LogWrite(ERROR, "file:%s line:%d func:%s, get power[2] status failed\n",
            __FILENAME__, __LINE__, __FUNCTION__);
        return;
    }

    if(PW_SUPPLY_ON == pow1Status && PW_SUPPLY_ON == pow2Status){
        cur_pwStatus = PW1OK_AND_PW2OK;
    }else if(PW_SUPPLY_ON == pow1Status && PW_SUPPLY_OFF == pow2Status){
        cur_pwStatus = PW1OK_AND_PW2FAIL;
    }else if (PW_SUPPLY_OFF == pow1Status && PW_SUPPLY_ON == pow2Status){
        cur_pwStatus = PW1FAIL_AND_PW2OK;
    }else{
        cur_pwStatus = PW1FAIL_AND_PW2FAIL;
    }

    if (cur_pwStatus == pre_pwStatus)
        return;

    send_jwsTrapPowerSupply_trap(cur_pwStatus);
    LogWrite(DEBUG, "file:%s line:%d func:%s, power status:%s\n",
            __FILENAME__, __LINE__, __FUNCTION__,pow_status_print(cur_pwStatus));

    pre_pwStatus = cur_pwStatus;

    return;
}

int
send_jwsTrapPowerSupply_trap( enum PWSTATUS pwStatus )
{
    netsnmp_variable_list  *var_list = NULL;
    oid jwsTrapPowerSupply_oid[] = { 1,3,6,1,4,1,33444,2,2,100,3,1000 };
    oid jwsTrapObjPowerSupplyStatus_oid[] = { 1,3,6,1,4,1,33444,2,2,100,2,1, 0 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        (u_char *) jwsTrapPowerSupply_oid, sizeof(jwsTrapPowerSupply_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        jwsTrapObjPowerSupplyStatus_oid, OID_LENGTH(jwsTrapObjPowerSupplyStatus_oid),
        ASN_INTEGER,
        /* Set an appropriate value for jwsTrapObjPowerSupplyStatus */
        (u_char *) &pwStatus, sizeof(pwStatus));

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
